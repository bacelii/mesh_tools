<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mesh_tools.trimesh_utils &mdash; mesh_tools  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            mesh_tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">mesh_tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mesh_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mesh_tools.trimesh_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mesh_tools.trimesh_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>


<span class="sd">These functions just help with generically </span>
<span class="sd">helping with trimesh mesh manipulation</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">trimesh.grouping</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">trimesh.graph</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">open3d</span> <span class="k">as</span> <span class="nn">o3d</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">pymeshfix</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">trimesh.path.exchange.misc</span> <span class="kn">import</span> <span class="n">faces_to_path</span>
<span class="kn">from</span> <span class="nn">trimesh</span> <span class="kn">import</span> <span class="n">triangles</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cgal_Segmentation_Module</span> <span class="k">as</span> <span class="nn">csm</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="c1">#loading a mesh safely without any processing to mess up the vertices/faces</span>
<div class="viewcode-block" id="load_mesh_no_processing"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.load_mesh_no_processing">[docs]</a><span class="k">def</span> <span class="nf">load_mesh_no_processing</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    will load a mesh from .off file format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
        <span class="n">current_mesh_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">current_mesh_file</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
        <span class="n">current_mesh_file</span> <span class="o">+=</span> <span class="s2">&quot;.off&quot;</span>
    <span class="k">return</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">,</span><span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<span class="c1"># --------- Dealing with h5 files</span>
<div class="viewcode-block" id="load_mesh_no_processing_h5"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.load_mesh_no_processing_h5">[docs]</a><span class="k">def</span> <span class="nf">load_mesh_no_processing_h5</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will load a mesh from h5py file format</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
        <span class="n">current_mesh_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">current_mesh_file</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.h5&quot;</span><span class="p">:</span>
        <span class="n">current_mesh_file</span> <span class="o">+=</span> <span class="s2">&quot;.h5&quot;</span>
        
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hf</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">hf</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">][()]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">hf</span><span class="p">[</span><span class="s1">&#39;faces&#39;</span><span class="p">][()]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">)</span></div>

<div class="viewcode-block" id="mesh_from_vertices_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_from_vertices_faces">[docs]</a><span class="k">def</span> <span class="nf">mesh_from_vertices_faces</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">faces</span><span class="p">):</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">)</span></div>

<div class="viewcode-block" id="write_h5_file"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.write_h5_file">[docs]</a><span class="k">def</span> <span class="nf">write_h5_file</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">segment_id</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
                  <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span>
                 <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">return_file_path</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will write a h5 py file to store a mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Extract the vertices and the faces</span>
<span class="sd">    2) Create the complete file path with the write extension</span>
<span class="sd">    3) Write the .h5 file</span>
<span class="sd">    4) return the filepath </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#1) Extract the vertices and the faces</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;mesh none and vertices or faces are none &quot;</span><span class="p">)</span>
        <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span>
        
    <span class="c1">#2) Create the complete file path with the write extension</span>
    <span class="n">curr_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">curr_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">.h5&quot;</span>
    
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.h5&quot;</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span>
    
    <span class="n">total_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">((</span><span class="n">curr_path</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span>
    
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">total_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hf</span><span class="p">:</span>
        <span class="n">hf</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;segment_id&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">segment_id</span><span class="p">)</span>
        <span class="n">hf</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">hf</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;faces&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">faces</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_file_path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_path</span></div>
    



<span class="c1"># --------- Done with h5 files ---------------- #</span>


<div class="viewcode-block" id="mesh_center_vertex_average"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_center_vertex_average">[docs]</a><span class="k">def</span> <span class="nf">mesh_center_vertex_average</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
        <span class="n">mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_list</span><span class="p">]</span>
    <span class="n">mesh_list_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_list</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_list_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_list_centers</span></div>
    
    
        
<div class="viewcode-block" id="mesh_center_weighted_face_midpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_center_weighted_face_midpoints">[docs]</a><span class="k">def</span> <span class="nf">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: calculate a mesh center point</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    a) get the face midpoints</span>
<span class="sd">    b) get the surface area of all of the faces and total surface area</span>
<span class="sd">    c) multiply the surface area percentage by the midpoints</span>
<span class="sd">    d) sum up the products</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#a) get the face midpoints</span>
    <span class="n">face_midpoints</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span>
    <span class="c1">#b) get the surface area of all of the faces and total surface area</span>
    <span class="n">total_area</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">area</span>
    <span class="n">face_areas</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">area_faces</span>
    <span class="n">face_areas_prop</span> <span class="o">=</span> <span class="n">face_areas</span><span class="o">/</span><span class="n">total_area</span>

    <span class="c1">#c) multiply the surface area percentage by the midpoints</span>
    <span class="n">mesh_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">face_midpoints</span><span class="o">*</span><span class="n">face_areas_prop</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh_center</span></div>
        

<div class="viewcode-block" id="write_neuron_off"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.write_neuron_off">[docs]</a><span class="k">def</span> <span class="nf">write_neuron_off</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">main_mesh_path</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">main_mesh_path</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">main_mesh_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">main_mesh_path</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">main_mesh_path</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
        <span class="n">main_mesh_path</span> <span class="o">+=</span> <span class="s2">&quot;.off&quot;</span>
    <span class="n">current_mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">main_mesh_path</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">main_mesh_path</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">main_mesh_path</span></div>


<div class="viewcode-block" id="combine_meshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.combine_meshes">[docs]</a><span class="k">def</span> <span class="nf">combine_meshes</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">,</span><span class="n">merge_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">leftover_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
<span class="c1">#     for m in mesh_pieces:</span>
<span class="c1">#         leftover_mesh += m</span>

    <span class="n">leftover_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="n">mesh_pieces</span> <span class="o">+</span>  <span class="p">[</span><span class="n">leftover_mesh</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">merge_vertices</span><span class="p">:</span>
        <span class="n">leftover_mesh</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">leftover_mesh</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def bbox_mesh_restriction(curr_mesh,bbox_upper_corners,</span>
<span class="sd">                         mult_ratio = 1):</span>
<span class="sd">    bbox_center = np.mean(bbox_upper_corners,axis=0)</span>
<span class="sd">    bbox_distance = np.max(bbox_upper_corners,axis=0)-bbox_center</span>
<span class="sd">    </span>
<span class="sd">    #face_midpoints = np.mean(curr_mesh.vertices[curr_mesh.faces],axis=1)</span>
<span class="sd">    face_midpoints = curr_mesh.triangles_center</span>
<span class="sd">    </span>
<span class="sd">    sum_totals = np.invert(np.sum((np.abs(face_midpoints-bbox_center)-mult_ratio*bbox_distance) &gt; 0,axis=1).astype(&quot;bool&quot;).reshape(-1))</span>
<span class="sd">    #total_face_indexes = set(np.arange(0,len(sum_totals)))</span>
<span class="sd">    faces_bbox_inclusion = (np.arange(0,len(sum_totals)))[sum_totals]</span>
<span class="sd">    </span>
<span class="sd">    try:</span>
<span class="sd">        curr_mesh_bbox_restriction = curr_mesh.submesh([faces_bbox_inclusion],append=True)</span>
<span class="sd">        return curr_mesh_bbox_restriction,faces_bbox_inclusion</span>
<span class="sd">    except:</span>
<span class="sd">        #print(f&quot;faces_bbox_inclusion = {faces_bbox_inclusion}&quot;)</span>
<span class="sd">        #print(f&quot;curr_mesh = {curr_mesh}&quot;)</span>
<span class="sd">        #raise Exception(&quot;failed bbox_mesh&quot;)</span>
<span class="sd">        return curr_mesh,np.arange(0,len(curr_mesh.faces))</span>
<span class="sd">    </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># New bounding box method able to accept multiple</span>
<div class="viewcode-block" id="bbox_mesh_restriction"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_mesh_restriction">[docs]</a><span class="k">def</span> <span class="nf">bbox_mesh_restriction</span><span class="p">(</span><span class="n">curr_mesh</span><span class="p">,</span><span class="n">bbox_upper_corners</span><span class="p">,</span>
                         <span class="n">mult_ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Can send multiple bounding box corners to the function</span>
<span class="sd">    and it will restrict your mesh to only the faces that are within</span>
<span class="sd">    those bounding boxs</span>
<span class="sd">    ** currently doing bounding boxes that are axis aligned</span>
<span class="sd">    </span>
<span class="sd">    -- Future work --</span>
<span class="sd">    could get an oriented bounding box by doing</span>
<span class="sd">    </span>
<span class="sd">    elephant_skeleton_verts_mesh = trimesh.Trimesh(vertices=el_verts,faces=np.array([]))</span>
<span class="sd">    elephant_skeleton_verts_mesh.bounding_box_oriented </span>
<span class="sd">    </span>
<span class="sd">    but would then have to do a projection into the oriented bounding box</span>
<span class="sd">    plane to get all of the points contained within</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bbox_upper_corners</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">bbox_upper_corners</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbox_upper_corners</span><span class="p">]</span>
    
    <span class="n">sum_totals_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bb_corners</span> <span class="ow">in</span> <span class="n">bbox_upper_corners</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">):</span>
            <span class="n">bb_corners</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">)</span>
    
        <span class="n">bbox_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">bbox_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">bbox_center</span>

        <span class="c1">#face_midpoints = np.mean(curr_mesh.vertices[curr_mesh.faces],axis=1)</span>
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="n">curr_mesh</span><span class="o">.</span><span class="n">triangles_center</span>

        <span class="n">current_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">face_midpoints</span><span class="o">-</span><span class="n">bbox_center</span><span class="p">)</span><span class="o">-</span><span class="n">mult_ratio</span><span class="o">*</span><span class="n">bbox_distance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sum_totals_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_sums</span><span class="p">)</span>
    
    <span class="n">sum_totals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">sum_totals_list</span><span class="p">)</span>
    <span class="c1">#print(f&quot;sum_totals = {sum_totals}&quot;)</span>
    
    <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sum_totals</span><span class="p">)))[</span><span class="n">sum_totals</span><span class="p">]</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">curr_mesh_bbox_restriction</span> <span class="o">=</span> <span class="n">curr_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces_bbox_inclusion</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curr_mesh_bbox_restriction</span><span class="p">,</span><span class="n">faces_bbox_inclusion</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="c1">#print(f&quot;faces_bbox_inclusion = {faces_bbox_inclusion}&quot;)</span>
        <span class="c1">#print(f&quot;curr_mesh = {curr_mesh}&quot;)</span>
        <span class="c1">#raise Exception(&quot;failed bbox_mesh&quot;)</span>
        <span class="k">return</span> <span class="n">curr_mesh</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span></div>
    


<span class="c1"># -------------- 11/21 More bounding box functions ----- #</span>
<div class="viewcode-block" id="bounding_box"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box">[docs]</a><span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the mesh of the bounding box</span>
<span class="sd">    </span>
<span class="sd">    Input: Can take in the corners of a bounding box as well</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;did not recieve bounding box corners&quot;</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                              <span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]))</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box</span>
    
    <span class="k">if</span> <span class="n">oriented</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box</span></div>

<div class="viewcode-block" id="bounding_box_center"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box_center">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_center</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computed the center of the bounding box</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    ex_mesh = neuron_obj_with_web[axon_limb_name][9].mesh</span>
<span class="sd">    ipvu.plot_objects(ex_mesh,</span>
<span class="sd">                      scatters=[tu.bounding_box_center(ex_mesh)],</span>
<span class="sd">                      scatter_size=1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bb_corners</span> <span class="o">=</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">oriented</span> <span class="o">=</span> <span class="n">oriented</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="bounding_box_corners"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box_corners">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#bbox_verts = mesh.bounding_box.vertices</span>
    <span class="n">bbox_verts</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">oriented</span><span class="o">=</span><span class="n">oriented</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">bb_corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bbox_verts</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bbox_verts</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bbox_multiply_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bb_corners</span>
    
    <span class="n">bbox_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bbox_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bb_corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">bbox_center</span>
    <span class="n">new_corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bbox_center</span> <span class="o">-</span> <span class="n">bbox_multiply_ratio</span><span class="o">*</span><span class="n">bbox_distance</span><span class="p">,</span>
                            <span class="n">bbox_center</span> <span class="o">+</span> <span class="n">bbox_multiply_ratio</span><span class="o">*</span><span class="n">bbox_distance</span>
                           <span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_corners</span></div>

<div class="viewcode-block" id="bounding_box_corner_min"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box_corner_min">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_corner_min</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="bbox_min_x"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_min_x">[docs]</a><span class="k">def</span> <span class="nf">bbox_min_x</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>
<div class="viewcode-block" id="bbox_min_y"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_min_y">[docs]</a><span class="k">def</span> <span class="nf">bbox_min_y</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></div>
<div class="viewcode-block" id="bbox_min_z"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_min_z">[docs]</a><span class="k">def</span> <span class="nf">bbox_min_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="bounding_box_corner_max"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box_corner_max">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_corner_max</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="bbox_max_x"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_max_x">[docs]</a><span class="k">def</span> <span class="nf">bbox_max_x</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>
<div class="viewcode-block" id="bbox_max_y"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_max_y">[docs]</a><span class="k">def</span> <span class="nf">bbox_max_y</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></div>
<div class="viewcode-block" id="bbox_max_z"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_max_z">[docs]</a><span class="k">def</span> <span class="nf">bbox_max_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span></div>
        
<div class="viewcode-block" id="check_coordinates_inside_bounding_box"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.check_coordinates_inside_bounding_box">[docs]</a><span class="k">def</span> <span class="nf">check_coordinates_inside_bounding_box</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">coordinates</span><span class="p">,</span>
                                    <span class="n">bbox_coordinate_divisor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">return_inside_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="c1"># or else returns true/false mask of points inside</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the indices of points inside of the </span>
<span class="sd">    bounding box of  amesh</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    soma_mesh = neuron_obj.get_soma_meshes()[0]</span>
<span class="sd">    ex_verts = np.vstack([neuron_objs[0][1].mesh.vertices[:5],soma_mesh.vertices[:5]])</span>
<span class="sd">    tu.check_coordinates_inside_bounding_box(soma_mesh,ex_verts,return_inside_indices=False)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_inside_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span>
    
    
    <span class="n">curr_mesh_bounding_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">bbox_coordinate_divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_mesh_bounding_box before divisor (</span><span class="si">{</span><span class="n">bbox_coordinate_divisor</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">curr_mesh_bounding_box</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_mesh_bounding_box</span> <span class="o">=</span> <span class="n">curr_mesh_bounding_box</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bbox_coordinate_divisor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_mesh_bounding_box AFTER divisor (</span><span class="si">{</span><span class="n">bbox_coordinate_divisor</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">curr_mesh_bounding_box</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">inside_true_false_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">coordinates</span> <span class="o">&lt;=</span> <span class="n">curr_mesh_bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">coordinates</span> <span class="o">&gt;=</span> <span class="n">curr_mesh_bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_inside_indices</span><span class="p">:</span>
        <span class="n">points_inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside_true_false_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">points_inside</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inside_true_false_mask</span></div>
    
<div class="viewcode-block" id="vertices_mask_inside_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertices_mask_inside_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">vertices_mask_inside_mesh_bbox</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">mesh_for_bbox</span><span class="p">,</span>
    <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">main_mesh_bbox_corners</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh_for_bbox</span><span class="p">,</span><span class="n">bbox_multiply_ratio</span><span class="p">)</span>
    <span class="n">inside_results</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">main_mesh_bbox_corners</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">inside_results</span></div>


<div class="viewcode-block" id="vertices_mask_inside_meshes_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertices_mask_inside_meshes_bbox">[docs]</a><span class="k">def</span> <span class="nf">vertices_mask_inside_meshes_bbox</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">meshes_for_bbox</span><span class="p">,</span>
    <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">mesh_for_bbox</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">meshes_for_bbox</span><span class="p">)</span>
    <span class="n">vertices_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meshes_for_bbox</span><span class="p">:</span>
        <span class="n">vertices_mask</span> <span class="o">+=</span> <span class="n">tu</span><span class="o">.</span><span class="n">vertices_mask_inside_mesh_bbox</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="n">bbox_multiply_ratio</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vertices_mask</span></div>
    
<div class="viewcode-block" id="n_vertices_inside_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.n_vertices_inside_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">n_vertices_inside_mesh_bbox</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">mesh_for_bbox</span><span class="p">,</span>
    <span class="n">return_inside</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_percentage</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to return the number of faces within the bounding box of another face </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Get the bounding box corners of the main mesh</span>
    <span class="n">inside_results</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">vertices_mask_inside_meshes_bbox</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">mesh_for_bbox</span><span class="p">,</span>
        <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="n">bbox_multiply_ratio</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">n_inside_vertices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inside_results</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_inside</span><span class="p">:</span>
        <span class="n">n_inside_vertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_inside_vertices</span>
        
    <span class="n">inside_vertices_per</span> <span class="o">=</span> <span class="n">n_inside_vertices</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_inside_vertices = </span><span class="si">{</span><span class="n">n_inside_vertices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside_vertices_per = </span><span class="si">{</span><span class="n">inside_vertices_per</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_percentage</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inside_vertices_per</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_inside_vertices</span>    </div>
    
<div class="viewcode-block" id="n_vertices_outside_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.n_vertices_outside_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">n_vertices_outside_mesh_bbox</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">mesh_for_bbox</span><span class="p">,</span>
    <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_percentage</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">n_vertices_inside_mesh_bbox</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">mesh_for_bbox</span><span class="p">,</span>
    <span class="n">return_inside</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="n">bbox_multiply_ratio</span><span class="p">,</span>
    <span class="n">return_percentage</span> <span class="o">=</span> <span class="n">return_percentage</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span></div>
    


<div class="viewcode-block" id="check_meshes_outside_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.check_meshes_outside_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">check_meshes_outside_mesh_bbox</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">check_meshes_inside_mesh_bbox</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="n">return_indices</span><span class="p">,</span>
                                  <span class="n">return_inside</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_meshes_inside_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.check_meshes_inside_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">check_meshes_inside_mesh_bbox</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">return_inside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will check to see if any of the vertices</span>
<span class="sd">    of the test meshes are inside the bounding box of the main mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the bounding box corners of the main mesh</span>
<span class="sd">    2) For each test mesh</span>
<span class="sd">    - send the vertices to see if inside bounding box</span>
<span class="sd">    - if any are then add indices to the running list</span>
<span class="sd">    </span>
<span class="sd">    3) Return either the meshes/indices of the inside/outside pieces</span>
<span class="sd">    based on the parameters set</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Get the bounding box corners of the main mesh</span>
    <span class="n">main_mesh_bbox_corners</span> <span class="o">=</span> <span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">bbox_multiply_ratio</span><span class="p">)</span>
    
    <span class="c1">#2) Iterate through test meshes</span>
    <span class="n">inside_meshes_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">tm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">):</span>
        <span class="n">inside_results</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">main_mesh_bbox_corners</span><span class="p">,</span><span class="n">tm</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inside_results</span><span class="p">):</span>
            <span class="n">inside_meshes_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    
    <span class="c1">#3) Set the return values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_inside</span><span class="p">:</span>
        <span class="n">return_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">)),</span><span class="n">inside_meshes_idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inside_meshes_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">return_idx</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="check_meshes_outside_multiple_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.check_meshes_outside_multiple_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">check_meshes_outside_multiple_mesh_bbox</span><span class="p">(</span><span class="n">main_meshes</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">check_meshes_inside_multiple_mesh_bbox</span><span class="p">(</span><span class="n">main_meshes</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="n">return_indices</span><span class="p">,</span>
                                  <span class="n">return_inside</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="check_meshes_inside_multiple_mesh_bbox"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.check_meshes_inside_multiple_mesh_bbox">[docs]</a><span class="k">def</span> <span class="nf">check_meshes_inside_multiple_mesh_bbox</span><span class="p">(</span><span class="n">main_meshes</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">return_inside</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: will return all of the pieces inside or outside of </span>
<span class="sd">    multiple seperate main mesh bounding boxes</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For each main mesh</span>
<span class="sd">    1) Run the check_meshes_inside_mesh_bbox and collect the resulting indexes</span>
<span class="sd">    2) Combine the results based on the following:</span>
<span class="sd">    - If outside, then do intersetion of results (becuase need to be outside of all)</span>
<span class="sd">    - if inside, then return union of results (because if inside at least one then should be considered inside)</span>
<span class="sd">    3) Return either the meshes or indices</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from mesh_tools import trimesh_utils as tu</span>
<span class="sd">    tu = reload(tu)</span>
<span class="sd">    tu.check_meshes_inside_multiple_mesh_bbox([soma_mesh,soma_mesh,soma_mesh],neuron_obj.non_soma_touching_meshes,</span>
<span class="sd">                                 return_indices=False)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">main_meshes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Was expecting a list of main meshes&quot;</span><span class="p">)</span>
    
    <span class="c1">#1) Run the check_meshes_inside_mesh_bbox and collect the resulting indexes</span>
    
    <span class="n">all_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">main_mesh</span> <span class="ow">in</span> <span class="n">main_meshes</span><span class="p">:</span>
        <span class="n">curr_results</span> <span class="o">=</span> <span class="n">check_meshes_inside_mesh_bbox</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">test_meshes</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">return_inside</span><span class="o">=</span><span class="n">return_inside</span><span class="p">)</span>
        
        <span class="n">all_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_results</span><span class="p">)</span>
    
    <span class="c1">#2) Combine the results based on the following:</span>
    <span class="k">if</span> <span class="n">return_inside</span><span class="p">:</span>
        <span class="n">joining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">joining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span>
    
    <span class="n">final_indices</span> <span class="o">=</span> <span class="n">all_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">all_results</span><span class="p">)):</span>
        <span class="n">final_indices</span> <span class="o">=</span> <span class="n">joining_function</span><span class="p">(</span><span class="n">final_indices</span><span class="p">,</span><span class="n">all_results</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="c1">#3) Return either the meshes or indices</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">final_indices</span><span class="p">]</span></div>

    
    

<span class="c1"># main mesh cancellation</span>
<span class="c1"># --------------- 12/3 Addition: Made the connectivity matrix from the vertices by default ------------- #</span>
<div class="viewcode-block" id="split_significant_pieces_old"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_significant_pieces_old">[docs]</a><span class="k">def</span> <span class="nf">split_significant_pieces_old</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span>
                            <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                            <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">return_insignificant_pieces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside split_significant_pieces and was passed empty mesh so retruning empty list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------Starting the mesh filter for significant outside pieces-------&quot;</span><span class="p">)</span>
<span class="c1">#     from python_tools import system_utils as su</span>
<span class="c1">#     su.compressed_pickle(new_submesh,f&quot;new_submesh_{np.random.randint(10,1000)}&quot;)</span>
    <span class="k">if</span> <span class="n">connectivity</span><span class="o">==</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span>
        <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="n">new_submesh</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="n">split_by_vertices</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished splitting mesh_pieces into = </span><span class="si">{</span><span class="n">mesh_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">([])),</span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])),</span><span class="nb">list</span><span class="p">]:</span>
        <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_pieces</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2"> pieces after mesh split&quot;</span><span class="p">)</span>

    <span class="n">significant_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mesh_pieces</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">significance_threshold</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="n">insignificant_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mesh_pieces</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">significance_threshold</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2"> pieces found after size threshold&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">)</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;THERE WERE NO MESH PIECES GREATER THAN THE significance_threshold&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1">#arrange the significant pieces from largest to smallest</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">significant_pieces</span><span class="p">]</span>
    <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="n">sorted_indexes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sorted_significant_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">significant_pieces</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_indexes</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="c1">#arrange the significant pieces from largest to smallest</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">insignificant_pieces</span><span class="p">]</span>
        <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="n">sorted_indexes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sorted_significant_pieces_insig</span> <span class="o">=</span> <span class="p">[</span><span class="n">insignificant_pieces</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_indexes</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_significant_pieces</span><span class="p">,</span><span class="n">sorted_significant_pieces_insig</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_significant_pieces</span></div>
    
<div class="viewcode-block" id="face_idx_map_from_face_idx_list"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.face_idx_map_from_face_idx_list">[docs]</a><span class="k">def</span> <span class="nf">face_idx_map_from_face_idx_list</span><span class="p">(</span>
    <span class="n">face_idx_list</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_faces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To turn a list of face idx</span>
<span class="sd">    into an overall face idx mapping to each component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        
    <span class="n">face_map_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_faces</span><span class="p">)</span><span class="o">*</span><span class="n">default_value</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">face_idx_list</span><span class="p">):</span>
        <span class="n">face_map_idx</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        
    <span class="k">return</span> <span class="n">face_map_idx</span></div>


<div class="viewcode-block" id="split_significant_pieces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_significant_pieces">[docs]</a><span class="k">def</span> <span class="nf">split_significant_pieces</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span>
                            <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                            <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">return_insignificant_pieces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">return_face_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">return_face_map_for_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will split a mesh based on connectivity of edges or vertices</span>
<span class="sd">    (can return insiginifcant pieces and their face indices)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    (split_meshes,split_meshes_face_idx,</span>
<span class="sd">    split_meshes_insig,split_meshes_face_idx_insig) = tu.split_significant_pieces(main_mesh_total,connectivity=&quot;edges&quot;,</span>
<span class="sd">                                                                                  return_insignificant_pieces=True,</span>
<span class="sd">                                                                     return_face_indices=True)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside split_significant_pieces and was passed empty mesh so retruning empty list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------Starting the mesh filter for significant outside pieces-------&quot;</span><span class="p">)</span>
<span class="c1">#     from python_tools import system_utils as su</span>
<span class="c1">#     su.compressed_pickle(new_submesh,f&quot;new_submesh_{np.random.randint(10,1000)}&quot;)</span>
    <span class="k">if</span> <span class="n">connectivity</span><span class="o">==</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Old way that did not have options for the indices </span>
<span class="sd">        mesh_pieces = new_submesh.split(only_watertight=False,repair=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">mesh_pieces</span><span class="p">,</span><span class="n">mesh_pieces_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_pieces</span><span class="p">,</span><span class="n">mesh_pieces_idx</span> <span class="o">=</span> <span class="n">split_by_vertices</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished splitting mesh_pieces into = </span><span class="si">{</span><span class="n">mesh_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">([])),</span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])),</span><span class="nb">list</span><span class="p">]:</span>
        <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_pieces</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2"> pieces after mesh split&quot;</span><span class="p">)</span>

    <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span>
    <span class="n">mesh_pieces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_pieces_idx</span><span class="p">)</span>
    
    <span class="n">pieces_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mesh_pieces</span><span class="p">])</span>
    <span class="n">significant_pieces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pieces_len</span> <span class="o">&gt;=</span> <span class="n">significance_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">insignificant_pieces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pieces_len</span> <span class="o">&lt;</span> <span class="n">significance_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">significant_pieces</span> <span class="o">=</span> <span class="n">mesh_pieces</span><span class="p">[</span><span class="n">significant_pieces_idx</span><span class="p">]</span>
    <span class="n">significant_pieces_face_idx</span> <span class="o">=</span> <span class="n">mesh_pieces_idx</span><span class="p">[</span><span class="n">significant_pieces_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="n">insignificant_pieces</span> <span class="o">=</span> <span class="n">mesh_pieces</span><span class="p">[</span><span class="n">insignificant_pieces_idx</span><span class="p">]</span>
        <span class="n">insignificant_pieces_face_idx</span> <span class="o">=</span> <span class="n">mesh_pieces_idx</span><span class="p">[</span><span class="n">insignificant_pieces_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2"> pieces found after size threshold&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">)</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(&quot;THERE WERE NO MESH PIECES GREATER THAN THE significance_threshold&quot;)</span>
        <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[],[],[],[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[],[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1">#arrange the significant pieces from largest to smallest</span>
    <span class="n">sorted_significant_meshes</span><span class="p">,</span><span class="n">sorted_significant_meshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">sort_meshes_largest_to_smallest</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">,</span>
                                                                                                <span class="n">sort_attribute</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                                                                                                <span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sorted_significant_meshes_face_idx</span> <span class="o">=</span> <span class="n">significant_pieces_face_idx</span><span class="p">[</span><span class="n">sorted_significant_meshes_idx</span><span class="p">]</span>
    
    <span class="n">sorted_significant_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_significant_meshes</span><span class="p">)</span>
    <span class="n">sorted_significant_meshes_face_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_significant_meshes_face_idx</span><span class="p">)</span>
    
<span class="c1">#     x = [len(k.vertices) for k in significant_pieces]</span>
<span class="c1">#     sorted_indexes = sorted(range(len(x)), key=lambda k: x[k])a</span>
<span class="c1">#     sorted_indexes = sorted_indexes[::-1]</span>
<span class="c1">#     sorted_significant_pieces = [significant_pieces[k] for k in sorted_indexes]</span>
    
    <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="n">sorted_insignificant_meshes</span><span class="p">,</span><span class="n">sorted_insignificant_meshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">sort_meshes_largest_to_smallest</span><span class="p">(</span><span class="n">insignificant_pieces</span><span class="p">,</span>
                                                                                                <span class="n">sort_attribute</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                                                                                                <span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sorted_insignificant_meshes_face_idx</span> <span class="o">=</span> <span class="n">insignificant_pieces_face_idx</span><span class="p">[</span><span class="n">sorted_insignificant_meshes_idx</span><span class="p">]</span>
        
        <span class="n">sorted_insignificant_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_insignificant_meshes</span><span class="p">)</span>
        <span class="n">sorted_insignificant_meshes_face_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_insignificant_meshes_face_idx</span><span class="p">)</span>
        
<span class="c1">#         #arrange the significant pieces from largest to smallest</span>
<span class="c1">#         x = [len(k.vertices) for k in insignificant_pieces]</span>
<span class="c1">#         sorted_indexes = sorted(range(len(x)), key=lambda k: x[k])</span>
<span class="c1">#         sorted_indexes = sorted_indexes[::-1]</span>
<span class="c1">#         sorted_significant_pieces_insig = [insignificant_pieces[k] for k in sorted_indexes]</span>
        
        
    <span class="k">if</span> <span class="n">return_face_map_for_indices</span> <span class="ow">and</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="n">sorted_significant_meshes_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">face_idx_map_from_face_idx_list</span><span class="p">(</span><span class="n">sorted_significant_meshes_face_idx</span><span class="p">,</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">new_submesh</span><span class="p">)</span>
        <span class="n">sorted_insignificant_meshes_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">face_idx_map_from_face_idx_list</span><span class="p">(</span><span class="n">sorted_insignificant_meshes_face_idx</span><span class="p">,</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">new_submesh</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_insignificant_pieces</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
            
            <span class="k">return</span> <span class="p">(</span><span class="n">sorted_significant_meshes</span><span class="p">,</span><span class="n">sorted_significant_meshes_face_idx</span><span class="p">,</span>
                <span class="n">sorted_insignificant_meshes</span><span class="p">,</span><span class="n">sorted_insignificant_meshes_face_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sorted_significant_meshes</span><span class="p">,</span>
                <span class="n">sorted_insignificant_meshes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sorted_significant_meshes</span><span class="p">,</span><span class="n">sorted_significant_meshes_face_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sorted_significant_meshes</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">******* </span>
<span class="sd">The submesh function if doesn&#39;t have repair = False might</span>
<span class="sd">end up adding on some faces that you don&#39;t want!</span>
<span class="sd">*******</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="sort_meshes_largest_to_smallest"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.sort_meshes_largest_to_smallest">[docs]</a><span class="k">def</span> <span class="nf">sort_meshes_largest_to_smallest</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span>
                                    <span class="n">sort_attribute</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                                    <span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">sort_attribute</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">]</span>
    <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="n">sorted_indexes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sorted_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_indexes</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_meshes</span><span class="p">,</span><span class="n">sorted_indexes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_meshes</span></div>
    
    

<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">adjacency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
          <span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
          <span class="n">return_face_idx_map</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
          <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
          <span class="n">return_mesh_list</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a mesh into multiple meshes from face</span>
<span class="sd">    connectivity.</span>
<span class="sd">    If only_watertight is true it will only return</span>
<span class="sd">    watertight meshes and will attempt to repair</span>
<span class="sd">    single triangle or quad holes.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">    only_watertight: bool</span>
<span class="sd">      Only return watertight components</span>
<span class="sd">    adjacency : (n, 2) int</span>
<span class="sd">      Face adjacency to override full mesh</span>
<span class="sd">    engine : str or None</span>
<span class="sd">      Which graph engine to use</span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    meshes : (m,) trimesh.Trimesh</span>
<span class="sd">      Results of splitting</span>
<span class="sd">      </span>
<span class="sd">    ----------------***** THIS VERSION HAS BEEN ALTERED TO PASS BACK THE COMPONENTS INDICES TOO ****------------------</span>
<span class="sd">    </span>
<span class="sd">    if return_components=True then will return an array of arrays that contain face indexes for all the submeshes split off</span>
<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    tu.split(elephant_and_box)</span>
<span class="sd">    meshes = array([&lt;trimesh.Trimesh(vertices.shape=(2775, 3), faces.shape=(5558, 3))&gt;,</span>
<span class="sd">        &lt;trimesh.Trimesh(vertices.shape=(8, 3), faces.shape=(12, 3))&gt;],</span>
<span class="sd">       dtype=object)</span>
<span class="sd">    components = array([array([   0, 3710, 3709, ..., 1848, 1847, 1855]),</span>
<span class="sd">        array([5567, 5566, 5565, 5564, 5563, 5559, 5561, 5560, 5558, 5568, 5562,</span>
<span class="sd">        5569])], dtype=object)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="s2">&quot;vertices&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">split_by_vertices</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_components</span><span class="o">=</span><span class="n">return_components</span><span class="p">,</span>
            <span class="n">return_face_idx_map</span> <span class="o">=</span> <span class="n">return_face_idx_map</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">adjacency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_adjacency</span>

    <span class="c1"># if only watertight the shortest thing we can split has 3 triangles</span>
    <span class="k">if</span> <span class="n">only_watertight</span><span class="p">:</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="c1">#print(f&quot;only_watertight = {only_watertight}&quot;)</span>

    <span class="n">components</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span>
        <span class="n">edges</span><span class="o">=</span><span class="n">adjacency</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span>
        <span class="n">min_len</span><span class="o">=</span><span class="n">min_len</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
              
    
    <span class="c1">#print(f&quot;components = {[c.shape for c in components]}&quot;)</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">only_watertight</span><span class="o">=</span><span class="n">only_watertight</span><span class="p">,</span> <span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1">#print(f&quot;meshes = {meshes}&quot;)</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; 6 19, old way of doing checking that did not resolve anything</span>
<span class="sd">    if type(meshes) != type(np.array([])):</span>
<span class="sd">        print(f&quot;meshes = {meshes}, with type = {type(meshes)}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="c1">#print(f&quot;meshes = {sub_components}, with type = {type(sub_components)}&quot;)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">())</span> <span class="p">:</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;list was only one so surrounding them with list&quot;</span><span class="p">)</span>
            <span class="c1">#print(f&quot;meshes_before = {meshes}&quot;)</span>
            <span class="c1">#print(f&quot;components_before = {components}&quot;)</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshes</span><span class="p">]</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The sub_components were not an array, list or trimesh&quot;</span><span class="p">)</span>
            
    <span class="c1">#make sure they are in order from least to greatest size</span>
<span class="c1">#     current_array = [len(c) for c in components]</span>
<span class="c1">#     ordered_indices = np.flip(np.argsort(current_array))</span>
    
    <span class="c1"># order according to number of faces in meshes (SO DOESN&#39;T ERROR ANYMORE)</span>
    <span class="n">current_array</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">]</span>
    <span class="n">ordered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">current_array</span><span class="p">))</span>
              
    
    
    <span class="n">ordered_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ordered_indices</span><span class="p">])</span>
    <span class="n">ordered_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ordered_indices</span><span class="p">])</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span> <span class="p">:</span>
            <span class="c1">#print(f&quot;ordered_meshes = {ordered_meshes}&quot;)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split is not passing back ordered faces:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; ordered_meshes = </span><span class="si">{</span><span class="n">ordered_meshes</span><span class="si">}</span><span class="s2">,  &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;components= </span><span class="si">{</span><span class="n">components</span><span class="si">}</span><span class="s2">,  &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;meshes = </span><span class="si">{</span><span class="n">meshes</span><span class="si">}</span><span class="s2">,  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;current_array=</span><span class="si">{</span><span class="n">current_array</span><span class="si">}</span><span class="s2">,  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;ordered_indices=</span><span class="si">{</span><span class="n">ordered_indices</span><span class="si">}</span><span class="s2">,  &quot;</span>
                           <span class="p">)</span>
    
    <span class="c1">#control if the meshes is iterable or not</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ordered_comp_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_components</span><span class="p">])</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1"># from python_tools import system_utils as su</span>
        <span class="c1"># su.compressed_pickle(ordered_components,&quot;ordered_components&quot;)</span>
        <span class="c1"># print(f&quot;ordered_components = {ordered_components}&quot;)</span>
        <span class="c1"># raise Exception(&quot;ordered_components&quot;)</span>
    
    <span class="k">if</span> <span class="n">return_mesh_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1">#print(f&quot;meshes = {sub_components}, with type = {type(sub_components)}&quot;)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">())</span> <span class="p">:</span>
                <span class="n">ordered_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ordered_meshes</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The sub_components were not an array, list or trimesh&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_face_idx_map</span><span class="p">:</span>
        <span class="n">return_components</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ordered_comp_indices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">face_idx_map_from_face_idx_list</span><span class="p">(</span><span class="n">ordered_comp_indices</span><span class="p">,</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">return_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered_meshes</span><span class="p">,</span><span class="n">ordered_comp_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered_meshes</span></div>

<div class="viewcode-block" id="closest_distance_between_meshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_distance_between_meshes">[docs]</a><span class="k">def</span> <span class="nf">closest_distance_between_meshes</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                    <span class="n">submesh</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">attribute_name</span> <span class="o">=</span> <span class="s2">&quot;triangles_center&quot;</span><span class="p">):</span>
    <span class="n">global_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
    <span class="n">submesh_midpoints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">submesh</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
    
    <span class="c1">#1) Put the submesh face midpoints into a KDTree</span>
    <span class="n">submesh_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">submesh_midpoints</span><span class="p">)</span>
    <span class="c1">#2) Query the fae midpoints of submesh against KDTree</span>
    <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">submesh_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh distance: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span></div>

<div class="viewcode-block" id="compare_meshes_by_face_midpoints_list"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.compare_meshes_by_face_midpoints_list">[docs]</a><span class="k">def</span> <span class="nf">compare_meshes_by_face_midpoints_list</span><span class="p">(</span><span class="n">mesh1_list</span><span class="p">,</span><span class="n">mesh2_list</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">match_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mesh1</span><span class="p">,</span><span class="n">mesh2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mesh1_list</span><span class="p">,</span><span class="n">mesh2_list</span><span class="p">):</span>
        <span class="n">match_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="n">mesh1</span><span class="p">,</span><span class="n">mesh2</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">match_list</span></div>

<div class="viewcode-block" id="compare_meshes_by_face_midpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.compare_meshes_by_face_midpoints">[docs]</a><span class="k">def</span> <span class="nf">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="n">mesh1</span><span class="p">,</span><span class="n">mesh2</span><span class="p">,</span><span class="n">match_threshold</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#0) calculate the face midpoints of each of the faces for original and submesh</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">global_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">total_faces_greater_than_threshold</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">starting_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh1</span><span class="p">,</span><span class="n">mesh2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh1.faces.shape = </span><span class="si">{</span><span class="n">mesh1</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">,mesh2.faces.shape = </span><span class="si">{</span><span class="n">mesh2</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">starting_meshes</span><span class="p">)):</span>
        
        <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="n">starting_meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">triangles_center</span>
        <span class="n">submesh_midpoints</span> <span class="o">=</span> <span class="n">starting_meshes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">triangles_center</span>


        <span class="c1">#1) Put the submesh face midpoints into a KDTree</span>
        <span class="n">submesh_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">submesh_midpoints</span><span class="p">)</span>
        <span class="c1">#2) Query the fae midpoints of submesh against KDTree</span>
        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">submesh_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>

        <span class="n">faces_greater_than_treshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)))[</span><span class="n">distances</span> <span class="o">&gt;=</span> <span class="n">match_threshold</span><span class="p">]</span>
        <span class="n">total_faces_greater_than_threshold</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">faces_greater_than_treshold</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh mapping: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_faces_greater_than_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_faces_greater_than_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_faces_greater_than_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> face midpoints of mesh1 were farther than </span><span class="si">{</span><span class="n">match_threshold</span><span class="si">}</span><span class="s2"> &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;from the face midpoints of mesh2&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_faces_greater_than_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2"> face midpoints of mesh2 were farther than </span><span class="si">{</span><span class="n">match_threshold</span><span class="si">}</span><span class="s2"> &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;from the face midpoints of mesh1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">mesh1</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s2">&quot;mesh1_failed.off&quot;</span><span class="p">)</span>
            <span class="n">mesh2</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s2">&quot;mesh2_failed.off&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Meshes are equal!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="original_mesh_vertices_map"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.original_mesh_vertices_map">[docs]</a><span class="k">def</span> <span class="nf">original_mesh_vertices_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span> <span class="n">submesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">vertices_coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Given an original_mesh and either a </span>
<span class="sd">        i) submesh</span>
<span class="sd">        ii) list of vertices coordinates</span>
<span class="sd">    Find the indices of the original vertices in the</span>
<span class="sd">    original mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get vertices to map to original</span>
<span class="sd">    2) Construct a KDTree of the original mesh vertices</span>
<span class="sd">    3) query the closest vertices on the original mesh</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">submesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertices_coordinates</span> <span class="o">=</span> <span class="n">submesh</span><span class="o">.</span><span class="n">vertices</span>
    <span class="k">elif</span> <span class="n">vertices_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Both Submesh and vertices_coordinates are None&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="n">global_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#1) Put the submesh face midpoints into a KDTree</span>
    <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="c1">#2) Query the fae midpoints of submesh against KDTree</span>
    <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">vertices_coordinates</span><span class="p">)</span>

    <span class="c1">#check that all of them matched below the threshold</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">distances</span><span class="o">&gt;</span> <span class="n">match_threshold</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distances</span><span class="o">&gt;</span><span class="w"> </span><span class="n">match_threshold</span><span class="p">)</span><span class="si">}</span><span class="s2"> faces that did not have an exact match to the original mesh&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh mapping: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">closest_node</span></div>
    
<div class="viewcode-block" id="subtract_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.subtract_mesh">[docs]</a><span class="k">def</span> <span class="nf">subtract_mesh</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span><span class="n">subtract_mesh</span><span class="p">,</span>
                    <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">match_threshold</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                  <span class="n">error_for_exact_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="p">):</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">subtract_mesh</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtract_mesh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">original_mesh</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">subtract_mesh</span><span class="p">):</span>
        <span class="n">subtract_mesh</span> <span class="o">=</span> <span class="n">combine_meshes</span><span class="p">(</span><span class="n">subtract_mesh</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtract_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">original_mesh</span>
    <span class="k">return</span> <span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">original_mesh</span><span class="p">,</span>
                                   <span class="n">submesh</span><span class="o">=</span><span class="n">subtract_mesh</span><span class="p">,</span>
                                   <span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">return_mesh</span><span class="o">=</span><span class="n">return_mesh</span><span class="p">,</span>
                                   <span class="n">exact_match</span><span class="o">=</span><span class="n">exact_match</span><span class="p">,</span>
                                   <span class="n">match_threshold</span><span class="o">=</span><span class="n">match_threshold</span><span class="p">,</span>
                                   <span class="n">error_for_exact_match</span><span class="o">=</span><span class="n">error_for_exact_match</span><span class="p">,</span>
                                  <span class="p">)</span></div>

<div class="viewcode-block" id="restrict_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.restrict_mesh">[docs]</a><span class="k">def</span> <span class="nf">restrict_mesh</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span><span class="n">restrict_meshes</span><span class="p">,</span>
                    <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span>
                   <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">restrict_meshes</span><span class="p">):</span>
        <span class="n">restrict_meshes</span> <span class="o">=</span> <span class="n">combine_meshes</span><span class="p">(</span><span class="n">restrict_meshes</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">original_mesh</span><span class="p">,</span>
                                   <span class="n">submesh</span><span class="o">=</span><span class="n">restrict_meshes</span><span class="p">,</span>
                                   <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">return_mesh</span><span class="o">=</span><span class="n">return_mesh</span>
                                  <span class="p">)</span></div>

<div class="viewcode-block" id="original_mesh_faces_map"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.original_mesh_faces_map">[docs]</a><span class="k">def</span> <span class="nf">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span> <span class="n">submesh</span><span class="p">,</span>
                           <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                            <span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">error_for_exact_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="n">return_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PUrpose: Given a base mesh and mesh that was a submesh of that base mesh</span>
<span class="sd">    - find the original face indices of the submesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) calculate the face midpoints of each of the faces for original and submesh</span>
<span class="sd">    1) Put the base mesh face midpoints into a KDTree</span>
<span class="sd">    2) Query the fae midpoints of submesh against KDTree</span>
<span class="sd">    3) Only keep those that correspond to the faces or do not correspond to the faces</span>
<span class="sd">    based on the parameter setting</span>
<span class="sd">    </span>
<span class="sd">    Can be inversed so can find the mapping of all the faces that not match a mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">global_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()),</span><span class="n">trimesh</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">Box</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;original mesh must be trimesh object&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">submesh</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">non_empty_or_none</span><span class="p">(</span><span class="n">submesh</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matching</span><span class="p">:</span>
                <span class="n">return_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                                          <span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">original_mesh</span>
                
            <span class="k">return</span> <span class="n">return_faces</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="n">submesh</span> <span class="o">=</span> <span class="n">combine_meshes</span><span class="p">(</span><span class="n">submesh</span><span class="p">)</span>
    
    <span class="c1">#pre-check for emppty meshes</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">submesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">submesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">matching</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        
    
    
    <span class="c1">#0) calculate the face midpoints of each of the faces for original and submesh</span>
    <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span>
    <span class="n">submesh_midpoints</span> <span class="o">=</span> <span class="n">submesh</span><span class="o">.</span><span class="n">triangles_center</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exact_match</span><span class="p">:</span>
        <span class="c1">#This was the old way which was switching the order the new faces were found</span>
        <span class="c1">#1) Put the submesh face midpoints into a KDTree</span>
        <span class="n">submesh_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">submesh_midpoints</span><span class="p">)</span>
        <span class="c1">#2) Query the fae midpoints of submesh against KDTree</span>
        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">submesh_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
    

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh mapping: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#3) Only keep those that correspond to the faces or do not correspond to the faces</span>
        <span class="c1">#based on the parameter setting</span>
        <span class="k">if</span> <span class="n">matching</span><span class="p">:</span>
            <span class="n">return_faces</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)))[</span><span class="n">distances</span> <span class="o">&lt;</span> <span class="n">match_threshold</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_faces</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)))[</span><span class="n">distances</span> <span class="o">&gt;=</span> <span class="n">match_threshold</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="c1">#1) Put the submesh face midpoints into a KDTree</span>
        <span class="k">if</span> <span class="n">original_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
            
        <span class="c1">#2) Query the fae midpoints of submesh against KDTree</span>
        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">submesh_midpoints</span><span class="p">)</span>
        
        <span class="c1">#check that all of them matched below the threshold</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">distances</span><span class="o">&gt;</span> <span class="n">match_threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">error_for_exact_match</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distances</span><span class="o">&gt;</span><span class="w"> </span><span class="n">match_threshold</span><span class="p">)</span><span class="si">}</span><span class="s2"> faces that did not have an exact match to the original mesh&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keep_map</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">match_threshold</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">keep_map</span><span class="p">]</span>
                <span class="n">closest_node</span> <span class="o">=</span> <span class="n">closest_node</span><span class="p">[</span><span class="n">keep_map</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh mapping: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">matching</span><span class="p">:</span>
            <span class="n">return_faces</span> <span class="o">=</span> <span class="n">closest_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_faces</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">remove_indexes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)),</span><span class="n">closest_node</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">return_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_faces</span></div>

<div class="viewcode-block" id="shared_edges_between_faces_on_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.shared_edges_between_faces_on_mesh">[docs]</a><span class="k">def</span> <span class="nf">shared_edges_between_faces_on_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">faces_a</span><span class="p">,</span><span class="n">faces_b</span><span class="p">,</span>
                                 <span class="n">return_vertices_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two sets of faces, find the edges which are in both sets of faces.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    faces_a : (n, 3) int</span>
<span class="sd">      Array of faces</span>
<span class="sd">    faces_b : (m, 3) int</span>
<span class="sd">      Array of faces</span>
<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    shared : (p, 2) int</span>
<span class="sd">      Edges shared between faces</span>
<span class="sd">      </span>
<span class="sd">      </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the unique edges of each of the faces</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">faces_a_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces_unique_edges</span><span class="p">[</span><span class="n">faces_a</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">faces_b_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces_unique_edges</span><span class="p">[</span><span class="n">faces_b</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">shared_edges_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">faces_a_edges</span><span class="p">,</span><span class="n">faces_b_edges</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_vertices_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">[</span><span class="n">shared_edges_idx</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shared_edges_idx</span></div>
    
<div class="viewcode-block" id="mesh_pieces_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_pieces_connectivity">[docs]</a><span class="k">def</span> <span class="nf">mesh_pieces_connectivity</span><span class="p">(</span>
                <span class="n">main_mesh</span><span class="p">,</span>
                <span class="n">central_piece</span><span class="p">,</span>
                <span class="n">periphery_pieces</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                <span class="n">return_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_central_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_vertices_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">merge_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    purpose: function that will determine if certain pieces of mesh are touching in reference</span>
<span class="sd">    to a central mesh</span>

<span class="sd">    Pseudocde: </span>
<span class="sd">    1) Get the original faces of the central_piece and the periphery_pieces</span>
<span class="sd">    2) For each periphery piece, find if touching the central piece at all</span>
<span class="sd">    </span>
<span class="sd">    - get the vertices belonging to central mesh</span>
<span class="sd">    - get vertices belonging to current periphery</span>
<span class="sd">    - see if there is any overlap</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    2a) If yes then add to the list to return</span>
<span class="sd">    2b) if no, don&#39;t add to list</span>
<span class="sd">    </span>
<span class="sd">    Example of How to use it: </span>
<span class="sd">    </span>
<span class="sd">    connected_mesh_pieces = mesh_pieces_connectivity(</span>
<span class="sd">                    main_mesh=current_mesh,</span>
<span class="sd">                    central_piece=seperate_soma_meshes[0],</span>
<span class="sd">                    periphery_pieces = sig_non_soma_pieces)</span>
<span class="sd">    print(f&quot;connected_mesh_pieces = {connected_mesh_pieces}&quot;)</span>

<span class="sd">    Application: For finding connectivity to the somas</span>


<span class="sd">    Example: How to use merge vertices option</span>
<span class="sd">    import time</span>

<span class="sd">    start_time = time.time()</span>

<span class="sd">    #0) Getting the Soma border</span>

<span class="sd">    tu = reload(tu)</span>
<span class="sd">    new_mesh = tu.combine_meshes(touching_limbs_meshes + [curr_soma_mesh])</span>

<span class="sd">    soma_idx = 1</span>
<span class="sd">    curr_soma_mesh = current_neuron[nru.soma_label(soma_idx)].mesh</span>
<span class="sd">    touching_limbs = current_neuron.get_limbs_touching_soma(soma_idx)</span>
<span class="sd">    touching_limb_objs = [current_neuron[k] for k in touching_limbs]</span>

<span class="sd">    touching_limbs_meshes = [k.mesh for k in touching_limb_objs]</span>
<span class="sd">    touching_pieces,touching_vertices = tu.mesh_pieces_connectivity(main_mesh=new_mesh,</span>
<span class="sd">                                            central_piece = curr_soma_mesh,</span>
<span class="sd">                                            periphery_pieces = touching_limbs_meshes,</span>
<span class="sd">                                                             return_vertices=True,</span>
<span class="sd">                                                            return_central_faces=False,</span>
<span class="sd">                                                                    print_flag=False,</span>
<span class="sd">                                                                    merge_vertices=True,</span>
<span class="sd">                                                                                     )</span>
<span class="sd">    limb_to_soma_border = dict([(k,v) for k,v in zip(np.array(touching_limbs)[touching_pieces],touching_vertices)])</span>
<span class="sd">    limb_to_soma_border</span>

<span class="sd">    print(time.time() - start_time)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # 7-8 change: wanted to adapt so could give face ids as well instead of just meshes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">merge_vertices</span><span class="p">:</span>
        <span class="n">main_mesh</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">()</span>
    
    <span class="c1">#1) Get the original faces of the central_piece and the periphery_pieces</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">central_piece</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="n">central_piece_faces</span> <span class="o">=</span> <span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">central_piece</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#then what was passed were the face ids</span>
        <span class="n">central_piece_faces</span> <span class="o">=</span> <span class="n">central_piece</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;central_piece_faces = </span><span class="si">{</span><span class="n">central_piece_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">periphery_pieces_faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#periphery_pieces_faces = [original_mesh_faces_map(main_mesh,k) for k in periphery_pieces]</span>
    <span class="c1">#print(f&quot;periphery_pieces = {len(periphery_pieces)}&quot;)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">periphery_pieces</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="c1">#print(&quot;using trimesh pieces&quot;)</span>
            <span class="n">periphery_pieces_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&quot;just using face idxs&quot;)</span>
            <span class="n">periphery_pieces_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;periphery_pieces_faces = </span><span class="si">{</span><span class="n">periphery_pieces_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#2) For each periphery piece, find if touching the central piece at all</span>
    <span class="n">touching_periphery_pieces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">touching_periphery_pieces_intersecting_vertices</span><span class="o">=</span> <span class="p">[]</span>
    <span class="n">touching_periphery_pieces_intersecting_vertices_idx</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#the faces have the vertices indices stored so just comparing vertices indices!</span>
    
    <span class="k">if</span> <span class="n">connectivity</span><span class="o">!=</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span>
        <span class="n">central_p_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">central_piece_faces</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_p_faces</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">periphery_pieces_faces</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">connectivity</span><span class="o">==</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="c1">#will do connectivity based on edges</span>
            <span class="n">intersecting_vertices</span> <span class="o">=</span> <span class="n">shared_edges_between_faces_on_mesh</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span>
                                                                       <span class="n">faces_a</span><span class="o">=</span><span class="n">central_piece_faces</span><span class="p">,</span>
                                                                       <span class="n">faces_b</span><span class="o">=</span><span class="n">curr_p_faces</span><span class="p">,</span>
                                                                       <span class="n">return_vertices_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_p_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">curr_p_faces</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="n">intersecting_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">central_p_verts</span><span class="p">,</span><span class="n">curr_p_verts</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;intersecting_vertices = </span><span class="si">{</span><span class="n">intersecting_vertices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersecting_vertices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">touching_periphery_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">touching_periphery_pieces_intersecting_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">intersecting_vertices</span><span class="p">])</span>
            <span class="n">touching_periphery_pieces_intersecting_vertices_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intersecting_vertices</span><span class="p">)</span>
    
    
    
    <span class="c1">#redoing the return structure</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">touching_periphery_pieces</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_vertices</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">touching_periphery_pieces_intersecting_vertices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_central_faces</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">central_piece_faces</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_vertices_idx</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">touching_periphery_pieces_intersecting_vertices_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span></div>
    
    
<span class="c1">#     if not return_vertices and not return_central_faces:</span>
<span class="c1">#         return touching_periphery_pieces</span>
<span class="c1">#     else:</span>
<span class="c1">#         if return_vertices and return_central_faces:</span>
<span class="c1">#             return touching_periphery_pieces,touching_periphery_pieces_intersecting_vertices,central_piece_faces</span>
<span class="c1">#         elif return_vertices:</span>
<span class="c1">#             return touching_periphery_pieces,touching_periphery_pieces_intersecting_vertices</span>
<span class="c1">#         elif return_central_faces:</span>
<span class="c1">#             touching_periphery_pieces,central_piece_faces</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise Exception(&quot;Soething messed up with return in mesh connectivity&quot;)</span>
            

<div class="viewcode-block" id="two_mesh_list_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.two_mesh_list_connectivity">[docs]</a><span class="k">def</span> <span class="nf">two_mesh_list_connectivity</span><span class="p">(</span><span class="n">mesh_list_1</span><span class="p">,</span><span class="n">mesh_list_2</span><span class="p">,</span>
                               <span class="n">main_mesh</span><span class="p">,</span>
                              <span class="n">return_weighted_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the connectivity between two sets of </span>
<span class="sd">    mesh lists (and possibly return the number of vertices that are connecting them)</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Stack the somas meshes and other meshes</span>
<span class="sd">    2) Create a connectivity pairing to test</span>
<span class="sd">    3) Run the mesh connectivity to get the correct pairings and the weights</span>
<span class="sd">    4) Return the edges with the weights optionally attached</span>

<span class="sd">    **stacked meshes could be faces indices or meshes themselves</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">print_optimize</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">main_mesh</span>
    
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">mesh_list_1_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">convert_meshes_to_face_idxes</span><span class="p">(</span><span class="n">mesh_list_1</span><span class="p">,</span><span class="n">main_mesh_total</span><span class="p">)</span>
    <span class="n">mesh_list_2_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">convert_meshes_to_face_idxes</span><span class="p">(</span><span class="n">mesh_list_2</span><span class="p">,</span><span class="n">main_mesh_total</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Converting </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#1) Stack the somas meshes and other meshes</span>
    <span class="n">stacked_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mesh_list_1_face_idx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">mesh_list_2_face_idx</span><span class="p">)</span>

    <span class="c1">#2) Create a connectivity pairing to test</span>
    <span class="n">n_list_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_list_1</span><span class="p">)</span>
    <span class="n">pais_to_test</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">unique_pairings_between_2_arrays</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_list_1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list_2</span><span class="p">))</span> <span class="o">+</span> <span class="n">n_list_1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Unique pairing </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#3) Run the mesh connectivity to get the correct pairings and the weights</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">mesh_conn_edges</span><span class="p">,</span><span class="n">conn_weights</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_connectivity</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">stacked_meshes</span><span class="p">,</span>
                             <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">main_mesh_total</span><span class="p">,</span>
                             <span class="n">pairs_to_test</span><span class="o">=</span><span class="n">pais_to_test</span><span class="p">,</span>
                             <span class="n">weighted_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">mesh_conn_edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_conn_edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">n_list_1</span>
    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Mesh connectivity </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">return_weighted_edges</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh_conn_edges</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">conn_weights</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_conn_edges</span></div>
    
    
    
<div class="viewcode-block" id="convert_meshes_to_face_idxes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.convert_meshes_to_face_idxes">[docs]</a><span class="k">def</span> <span class="nf">convert_meshes_to_face_idxes</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                              <span class="n">main_mesh</span><span class="p">,</span>
                              <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">original_mesh_kd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will convert a list of </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">original_mesh_kd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">triangles_center</span>
        <span class="n">original_mesh_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
    
    
    <span class="n">periphery_pieces_faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="c1">#print(&quot;using trimesh pieces&quot;)</span>
            <span class="n">periphery_pieces_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">k</span><span class="p">,</span>
                                                                 <span class="n">exact_match</span><span class="o">=</span><span class="n">exact_match</span><span class="p">,</span>
                                                                 <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kd</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&quot;just using face idxs&quot;)</span>
            <span class="n">periphery_pieces_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">periphery_pieces_faces</span></div>
    
            
<div class="viewcode-block" id="mesh_list_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_list_connectivity">[docs]</a><span class="k">def</span> <span class="nf">mesh_list_connectivity</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span>
                        <span class="n">main_mesh</span><span class="p">,</span>
                           <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                           <span class="n">pairs_to_test</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">min_common_vertices</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">weighted_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">return_vertex_connection_groups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">return_largest_vertex_connection_group</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">return_connected_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Build an edge list</span>
<span class="sd">    2) Use the edgelist to find connected components</span>

<span class="sd">    Arguments:</span>
<span class="sd">    - meshes (list of trimesh.Trimesh) #</span>
<span class="sd">    - retrun_vertex_connection_groups (bool): whether to return the touching vertices</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">print_flag</span> <span class="o">=</span> <span class="n">verbose</span>

    <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">meshes</span>
    <span class="n">meshes_connectivity_edge_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_connectivity_edge_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_connectivity_vertex_connection_groups</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">vertex_graph</span> <span class="o">=</span> <span class="kc">None</span>
    
        

    <span class="n">periphery_pieces_faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#periphery_pieces_faces = [original_mesh_faces_map(main_mesh,k) for k in periphery_pieces]</span>
    <span class="c1">#print(f&quot;periphery_pieces = {len(periphery_pieces)}&quot;)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">periphery_pieces</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="c1">#print(&quot;using trimesh pieces&quot;)</span>
            <span class="n">periphery_pieces_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&quot;just using face idxs&quot;)</span>
            <span class="n">periphery_pieces_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>


<span class="w">    </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        Iterates through all combinations of meshes</span>
<span class="sd">        1) get the faces of both meshes in the pair</span>
<span class="sd">        2) using the faces get the shared edges between them (if any)</span>
<span class="sd">        3) If there were shared edges then save them as intersecting vertices</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pairs_to_test</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pairs_to_test</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">all_unique_choose_2_combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">periphery_pieces_faces</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">pairs_to_test</span><span class="p">:</span>
        <span class="n">central_p_faces</span> <span class="o">=</span> <span class="n">periphery_pieces_faces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">connectivity</span><span class="o">!=</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span>
            <span class="n">central_p_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">central_p_faces</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="n">curr_p_faces</span> <span class="o">=</span> <span class="n">periphery_pieces_faces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">connectivity</span><span class="o">==</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="c1">#will do connectivity based on edges</span>
            <span class="n">intersecting_vertices</span> <span class="o">=</span> <span class="n">shared_edges_between_faces_on_mesh</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span>
                                                                       <span class="n">faces_a</span><span class="o">=</span><span class="n">central_p_faces</span><span class="p">,</span>
                                                                       <span class="n">faces_b</span><span class="o">=</span><span class="n">curr_p_faces</span><span class="p">,</span>
                                                                       <span class="n">return_vertices_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1">#then do the vertex way</span>

            <span class="n">curr_p_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">curr_p_faces</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

            <span class="n">intersecting_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">central_p_verts</span><span class="p">,</span><span class="n">curr_p_verts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;intersecting_vertices = </span><span class="si">{</span><span class="n">intersecting_vertices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersecting_vertices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_common_vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_vertex_connection_groups</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">vertex_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">mesh_vertex_graph</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">)</span>

                <span class="n">curr_vertex_connection_groups</span> <span class="o">=</span> <span class="n">split_vertex_list_into_connected_components</span><span class="p">(</span>
                                                <span class="n">vertex_indices_list</span><span class="o">=</span><span class="n">intersecting_vertices</span><span class="p">,</span>
                                                <span class="n">mesh</span><span class="o">=</span><span class="n">main_mesh</span><span class="p">,</span>
                                                <span class="n">vertex_graph</span><span class="o">=</span><span class="n">vertex_graph</span><span class="p">,</span>
                                                <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="p">)</span>
                <span class="k">if</span> <span class="n">return_largest_vertex_connection_group</span><span class="p">:</span>
                    <span class="n">curr_vertex_connection_groups_len</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_vertex_connection_groups</span><span class="p">]</span>
                    <span class="n">largest_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">curr_vertex_connection_groups_len</span><span class="p">)</span>
                    <span class="n">curr_vertex_connection_groups</span> <span class="o">=</span> <span class="n">curr_vertex_connection_groups</span><span class="p">[</span><span class="n">largest_group</span><span class="p">]</span>

                <span class="n">meshes_connectivity_vertex_connection_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_vertex_connection_groups</span><span class="p">)</span>


            <span class="n">meshes_connectivity_edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
            <span class="n">meshes_connectivity_edge_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intersecting_vertices</span><span class="p">))</span>
                
                    

    <span class="n">meshes_connectivity_edge_list</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">sort_elements_in_every_row</span><span class="p">(</span><span class="n">meshes_connectivity_edge_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_vertex_connection_groups</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">meshes_connectivity_edge_list</span><span class="p">,</span><span class="n">meshes_connectivity_vertex_connection_groups</span>
    <span class="k">elif</span> <span class="n">return_connected_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components_from_nodes_edges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">)),</span><span class="n">meshes_connectivity_edge_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weighted_edges</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">meshes_connectivity_edge_list</span><span class="p">,</span><span class="n">meshes_connectivity_edge_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">meshes_connectivity_edge_list</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Saved method before added in vertex options</span>


<span class="sd">def mesh_list_connectivity(meshes,</span>
<span class="sd">                        main_mesh,</span>
<span class="sd">                           min_common_vertices=1,</span>
<span class="sd">                           return_vertex_connection_groups=False,</span>
<span class="sd">                           return_largest_vertex_connection_group=False,</span>
<span class="sd">                        print_flag = False):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Build an edge list</span>
<span class="sd">    2) Use the edgelist to find connected components</span>

<span class="sd">    Arguments:</span>
<span class="sd">    - meshes (list of trimesh.Trimesh) #</span>
<span class="sd">    - retrun_vertex_connection_groups (bool): whether to return the touching vertices</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    periphery_pieces = meshes</span>
<span class="sd">    meshes_connectivity_edge_list = []</span>
<span class="sd">    meshes_connectivity_vertex_connection_groups = []</span>
<span class="sd">    </span>
<span class="sd">    vertex_graph = None</span>
<span class="sd">    </span>
<span class="sd">        </span>

<span class="sd">    periphery_pieces_faces = []</span>
<span class="sd">    #periphery_pieces_faces = [original_mesh_faces_map(main_mesh,k) for k in periphery_pieces]</span>
<span class="sd">    #print(f&quot;periphery_pieces = {len(periphery_pieces)}&quot;)</span>
<span class="sd">    for k in periphery_pieces:</span>
<span class="sd">        if type(k) == type(trimesh.Trimesh()):</span>
<span class="sd">            #print(&quot;using trimesh pieces&quot;)</span>
<span class="sd">            periphery_pieces_faces.append(original_mesh_faces_map(main_mesh,k))</span>
<span class="sd">        else:</span>
<span class="sd">            #print(&quot;just using face idxs&quot;)</span>
<span class="sd">            periphery_pieces_faces.append(k)</span>


<span class="sd">    for j,central_p_faces in enumerate(periphery_pieces_faces):</span>
<span class="sd">        central_p_verts = np.unique(main_mesh.faces[central_p_faces].ravel())</span>
<span class="sd">        for i in range(0,j):</span>
<span class="sd">            curr_p_faces = periphery_pieces_faces[i]</span>
<span class="sd">            curr_p_verts = np.unique(main_mesh.faces[curr_p_faces].ravel())</span>

<span class="sd">            intersecting_vertices = np.intersect1d(central_p_verts,curr_p_verts)</span>
<span class="sd">            if print_flag:</span>
<span class="sd">                print(f&quot;intersecting_vertices = {intersecting_vertices}&quot;)</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            </span>

<span class="sd">            if len(intersecting_vertices) &gt;= min_common_vertices:</span>
<span class="sd">                if return_vertex_connection_groups:</span>
<span class="sd">                    </span>
<span class="sd">                    if vertex_graph is None:</span>
<span class="sd">                        vertex_graph = mesh_vertex_graph(main_mesh)</span>
<span class="sd">                    </span>
<span class="sd">                    curr_vertex_connection_groups = split_vertex_list_into_connected_components(</span>
<span class="sd">                                                    vertex_indices_list=intersecting_vertices,</span>
<span class="sd">                                                    mesh=main_mesh,</span>
<span class="sd">                                                    vertex_graph=vertex_graph,</span>
<span class="sd">                                                    return_coordinates=True,</span>
<span class="sd">                                                   )</span>
<span class="sd">                    if return_largest_vertex_connection_group:</span>
<span class="sd">                        curr_vertex_connection_groups_len = [len(k) for k in curr_vertex_connection_groups]</span>
<span class="sd">                        largest_group = np.argmax(curr_vertex_connection_groups_len)</span>
<span class="sd">                        curr_vertex_connection_groups = curr_vertex_connection_groups[largest_group]</span>
<span class="sd">                </span>
<span class="sd">                    meshes_connectivity_vertex_connection_groups.append(curr_vertex_connection_groups)</span>
<span class="sd">                    </span>
<span class="sd">                meshes_connectivity_edge_list.append((j,i))</span>

<span class="sd">    meshes_connectivity_edge_list = nu.sort_elements_in_every_row(meshes_connectivity_edge_list)</span>
<span class="sd">    if return_vertex_connection_groups:</span>
<span class="sd">        return meshes_connectivity_edge_list,meshes_connectivity_vertex_connection_groups</span>
<span class="sd">    else:</span>
<span class="sd">        return meshes_connectivity_edge_list</span>
<span class="sd">    </span>






<span class="sd">&#39;&#39;&#39;</span>
    
    


<div class="viewcode-block" id="split_vertex_list_into_connected_components_old"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_vertex_list_into_connected_components_old">[docs]</a><span class="k">def</span> <span class="nf">split_vertex_list_into_connected_components_old</span><span class="p">(</span>
    <span class="n">vertex_indices_list</span><span class="p">,</span> <span class="c1">#list of vertices referencing the mesh</span>
    <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#the main mesh the vertices list references</span>
    <span class="n">vertex_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># a precomputed vertex graph if available</span>
    <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#whether to return the groupings as coordinates (if False the returns them as indices)</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    Given a list of vertices (in reference to a main mesh),</span>
<span class="sd">    returns the vertices divided into connected components on the graph</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Build graph from vertex and edges of mesh</span>
<span class="sd">    2) Create a subgraph from the vertices list</span>
<span class="sd">    3) Find the connected components of the subgraph</span>
<span class="sd">    4) Either return the vertex coordinates or indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vertex_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#1) Build graph from vertex and edges of mesh</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Neither the vertex graph or mesh argument were non None&quot;</span><span class="p">)</span>
            
        <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">mesh_vertex_graph</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="c1">#2) Create a subgraph from the vertices list</span>
    <span class="n">vertex_subgraph</span> <span class="o">=</span> <span class="n">vertex_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertex_indices_list</span><span class="p">)</span>
    
    <span class="n">vertex_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">vertex_subgraph</span><span class="p">))]</span>
    
    <span class="k">if</span> <span class="n">return_coordinates</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vertex_groups</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vertex_groups</span></div>
    
<div class="viewcode-block" id="vertex_indices_subgraph"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertex_indices_subgraph">[docs]</a><span class="k">def</span> <span class="nf">vertex_indices_subgraph</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">vertex_indices</span><span class="p">,</span>
    <span class="n">plot_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return a connectivity</span>
<span class="sd">    subgraph of the vertex indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_edge_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v_idx</span> <span class="ow">in</span> <span class="n">vertex_indices</span><span class="p">:</span>
        <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">v_idx</span> <span class="p">)</span> <span class="o">|</span> 
         <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">v_idx</span> <span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">total_edge_indices</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_edge_indices = </span><span class="si">{</span><span class="n">total_edge_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">edges</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">[</span><span class="n">total_edge_indices</span><span class="p">]</span>
    <span class="n">edges_lengths</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique_length</span><span class="p">[</span><span class="n">total_edge_indices</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_edge_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    
    <span class="n">curr_weighted_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">edges</span><span class="p">,</span>
                                     <span class="n">edges_lengths</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  
    <span class="n">vertex_graph</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">curr_weighted_edges</span><span class="p">)</span>
    <span class="n">curr_G</span> <span class="o">=</span> <span class="n">vertex_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertex_indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_graph</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">curr_G</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">curr_G</span></div>
    
    
<div class="viewcode-block" id="split_vertex_list_into_connected_components"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_vertex_list_into_connected_components">[docs]</a><span class="k">def</span> <span class="nf">split_vertex_list_into_connected_components</span><span class="p">(</span>
    <span class="n">vertex_indices_list</span><span class="p">,</span> <span class="c1">#list of vertices referencing the mesh</span>
    <span class="n">mesh</span><span class="p">,</span> <span class="c1">#the main mesh the vertices list references</span>
    <span class="n">vertex_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># NOT USED</span>
    <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#whether to return the groupings as coordinates (if False the returns them as indices)</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    Given a list of vertices (in reference to a main mesh),</span>
<span class="sd">    returns the vertices divided into connected components on the graph</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the subgraph of vertices in list</span>
<span class="sd">    2) Create a subgraph from the vertices list</span>
<span class="sd">    3) Find the connected components of the subgraph</span>
<span class="sd">    4) Either return the vertex coordinates or indices</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#2) Create a subgraph from the vertices list</span>
    <span class="k">if</span> <span class="n">vertex_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">vertex_indices_subgraph</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">vertex_indices_list</span><span class="p">)</span>
    
    <span class="n">vertex_subgraph</span> <span class="o">=</span> <span class="n">vertex_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertex_indices_list</span><span class="p">)</span>
    
    <span class="n">vertex_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">vertex_subgraph</span><span class="p">))]</span>
    
    <span class="k">if</span> <span class="n">return_coordinates</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vertex_groups</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vertex_groups</span></div>


<div class="viewcode-block" id="split_mesh_into_face_groups"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_mesh_into_face_groups">[docs]</a><span class="k">def</span> <span class="nf">split_mesh_into_face_groups</span><span class="p">(</span>
    <span class="n">base_mesh</span><span class="p">,</span><span class="n">face_mapping</span><span class="p">,</span>
    <span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will split a mesh according to a face coloring of labels to split into </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">face_mapping</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">sorted_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">face_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">face_mapping</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;face mapping does not have same length as mesh faces&quot;</span><span class="p">)</span>
    
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">face_mapping</span><span class="p">))</span>
    <span class="n">total_submeshes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">total_submeshes_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">):</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_mapping</span><span class="o">==</span><span class="n">lab</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">total_submeshes_idx</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">faces</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">check_connect_comp</span><span class="p">:</span>
            <span class="n">total_submeshes</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">curr_submeshes</span> <span class="o">=</span> <span class="n">base_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#print(f&quot;len(curr_submeshes) = {len(curr_submeshes)}&quot;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_submeshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">total_submeshes</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_submeshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Label </span><span class="si">{</span><span class="n">lab</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_submeshes</span><span class="p">)</span><span class="si">}</span><span class="s2"> disconnected submeshes&quot;</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(usually when checking after the waterfilling algorithm)&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="n">total_submeshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">total_submeshes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">total_submeshes_idx</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">total_submeshes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">total_submeshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">total_submeshes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">total_submeshes</span><span class="p">),</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_submeshes</span><span class="p">,</span><span class="n">total_submeshes_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_submeshes</span></div>
    
<div class="viewcode-block" id="split_mesh_by_closest_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_mesh_by_closest_skeleton">[docs]</a><span class="k">def</span> <span class="nf">split_mesh_by_closest_skeleton</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">skeletons</span><span class="p">,</span><span class="n">return_meshes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For each N branch: </span>
<span class="sd">    1) Build a KDTree of the skeleton</span>
<span class="sd">    2) query the mesh against the skeleton, get distances</span>

<span class="sd">    3) Concatenate all the distances and turn into (DxN) matrix </span>
<span class="sd">    4) Find the argmin of each row and that is the assignment</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">dist_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">skeletons</span><span class="p">:</span>
        <span class="n">sk_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sk_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
        <span class="n">dist_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_list</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">face_assignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">split_meshes_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_assignment</span> <span class="o">==</span> <span class="n">s_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skeletons</span><span class="p">))]</span>
    
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="n">split_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">split_meshes_faces</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_faces</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">split_meshes_faces</span></div>
        
<span class="c1">#     split_meshes,split_meshes_faces = tu.split_mesh_into_face_groups(mesh,face_assignment,return_dict=False)</span>
<span class="c1">#     return split_meshes,split_meshes_faces </span>


<span class="w"> </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">https://github.com/GPUOpen-LibrariesAndSDKs/RadeonProRenderUSD/issues/2</span>


<span class="sd">apt-get update</span>
<span class="sd">apt-get install -y wget</span>

<span class="sd">#explains why has to do this so can see the shared library: </span>
<span class="sd">#https://stackoverflow.com/questions/1099981/why-cant-python-find-shared-objects-that-are-in-directories-in-sys-path</span>
<span class="sd">echo &#39;export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH&#39; &gt;&gt; ~/.bashrc </span>
<span class="sd">source ~/.bashrc</span>



<span class="sd">https://github.com/embree/embree#linux-and-macos (for the dependencies)</span>

<span class="sd">#for the dependencies</span>
<span class="sd">sudo apt-get install -y cmake-curses-gui</span>
<span class="sd">sudo apt-get install -y libtbb-dev</span>
<span class="sd">sudo apt-get install -y libglfw3-dev</span>

<span class="sd">Then run the following bash script (bash embree.bash)</span>

<span class="sd">trimesh bash file</span>

<span class="sd">---------------------------</span>
<span class="sd">set -xe</span>
<span class="sd">​</span>
<span class="sd"># Fetch the archive from GitHub releases.</span>
<span class="sd">wget https://github.com/embree/embree/releases/download/v2.17.7/embree-2.17.7.x86_64.linux.tar.gz -O /tmp/embree.tar.gz -nv</span>
<span class="sd">echo &quot;2c4bdacd8f3c3480991b99e85b8f584975ac181373a75f3e9675bf7efae501fe  /tmp/embree.tar.gz&quot; | sha256sum --check</span>
<span class="sd">tar -xzf /tmp/embree.tar.gz --strip-components=1 -C /usr/local</span>
<span class="sd"># remove archive</span>
<span class="sd">rm -rf /tmp/embree.tar.gz</span>
<span class="sd">​</span>
<span class="sd"># Install python bindings for embree (and upstream requirements).</span>
<span class="sd">pip3 install --no-cache-dir numpy cython</span>
<span class="sd">pip3 install --no-cache-dir https://github.com/scopatz/pyembree/releases/download/0.1.6/pyembree-0.1.6.tar.gz</span>

<span class="sd">-------------------------------</span>





<span class="sd">&quot;&quot;&quot;</span>    
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">trimesh.ray</span> <span class="kn">import</span> <span class="n">ray_pyembree</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
<div class="viewcode-block" id="ray_trace_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ray_trace_distance">[docs]</a><span class="k">def</span> <span class="nf">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> 
                    <span class="n">face_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                   <span class="n">vertex_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">ray_origins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">ray_directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                   <span class="n">rand_jitter</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> 
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">ray_inter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">replace_zero_values_with_center_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the distance from a vertex or face</span>
<span class="sd">    midpoint to an intersecting side of the mesh</span>
<span class="sd">    - To help with width calculations</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the ray origins and directions</span>
<span class="sd">    2) Create a mask that tells which ray origins we have</span>
<span class="sd">    calculated a valid width for and an array to store the widths (start as -1)</span>
<span class="sd">    3) Start an iteration loop that will only stop</span>
<span class="sd">    when have a valid width for all origin points</span>
<span class="sd">        a. get the indices of which points we don&#39;t have valid sdfs for</span>
<span class="sd">        and restrict the run to only those </span>
<span class="sd">        b. Add some gaussian noise to the normals of these rays</span>
<span class="sd">        c. Run the ray intersection to get the (multiple=False)</span>
<span class="sd">            - locations of intersections (mx3)</span>
<span class="sd">            - index_ray responsible for that intersection (m,)</span>
<span class="sd">            - mesh face that was intersected (m,)</span>
<span class="sd">        d. Update the width array for the origins that returned</span>
<span class="sd">           a valid width (using the diagonal_dot instead of linalg.norm because faster )</span>
<span class="sd">        e. Update the mask that shows which ray_origins have yet to be processed</span>
<span class="sd">    </span>
<span class="sd">    4) Return the width array</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">ray</span><span class="o">.</span><span class="n">has_embree</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;calculating rays without pyembree, conda install pyembree for large speedup&quot;</span><span class="p">)</span>

    <span class="c1">#initializing the obejct that can perform ray tracing</span>
    <span class="k">if</span> <span class="n">ray_inter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">face_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ray_origins</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[</span><span class="n">face_inds</span><span class="p">]</span>
        <span class="n">ray_directions</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_normals</span><span class="p">[</span><span class="n">face_inds</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">vertex_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ray_origins</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_inds</span><span class="p">]</span>
        <span class="n">ray_directions</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span><span class="p">[</span><span class="n">vertex_inds</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ray_origins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ray_directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">face_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        <span class="n">ray_origins</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[</span><span class="n">face_inds</span><span class="p">]</span>
        <span class="n">ray_directions</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_normals</span><span class="p">[</span><span class="n">face_inds</span><span class="p">]</span>
        
    
    <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ray_origins</span><span class="p">))</span> <span class="c1">#array to hold the widths when calculated</span>
    <span class="n">good_rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rs</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span> <span class="c1">#mask that keeps track of how many widths have been calculated</span>

    <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">good_rs</span><span class="p">):</span> <span class="c1">#continue until all sdf widths are calculated</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> --- Iteration = </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> -----&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of non_good rs = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">good_rs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#this is the indices of where the mask [~good_rs,:] is true</span>
        <span class="n">blank_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">good_rs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#the vertices who still need widths calculated</span>
        
        <span class="c1">#</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">ray_origins</span><span class="p">[</span><span class="n">blank_inds</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray_directions</span><span class="p">[</span><span class="n">blank_inds</span><span class="p">]</span>
        
        <span class="c1">#gets the opposite of the vertex normal so is pointing inwards</span>
        <span class="c1">#then adds jitter that gets bigger and bigger</span>
        <span class="n">ray_directions_with_jitter</span> <span class="o">=</span> <span class="o">-</span><span class="n">ray_directions</span><span class="p">[</span><span class="n">blank_inds</span><span class="p">]</span> \
            <span class="o">+</span> <span class="p">(</span><span class="mf">1.2</span><span class="o">**</span><span class="n">it</span><span class="p">)</span><span class="o">*</span><span class="n">rand_jitter</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span> <span class="c1">#the * is to expand out the shape tuple</span>
                                                   <span class="n">ray_directions</span><span class="p">[</span><span class="n">blank_inds</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="c1">#computes the locations, index_ray and index of hit mesh</span>
        <span class="n">intersect_locations</span><span class="p">,</span><span class="n">intersect_ray_index</span><span class="p">,</span><span class="n">intersect_mesh_index</span> <span class="o">=</span> <span class="n">ray_inter</span><span class="o">.</span><span class="n">intersects_location</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ray_directions_with_jitter</span><span class="p">,</span> <span class="n">multiple_hits</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(intersect_locations) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">intersect_locations</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect_locations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1">#rs[blank_inds[intersect_ray_index]] = np.linalg.norm(starts[intersect_ray_index]-intersect_locations,axis=1)</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">diagonal_dot</span><span class="p">(</span><span class="n">intersect_locations</span> <span class="o">-</span> <span class="n">starts</span><span class="p">[</span><span class="n">intersect_ray_index</span><span class="p">],</span>
                                      <span class="n">ray_directions_with_jitter</span><span class="p">[</span><span class="n">intersect_ray_index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of dephts that are 0 = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">depths</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rs</span><span class="p">[</span><span class="n">blank_inds</span><span class="p">[</span><span class="n">intersect_ray_index</span><span class="p">]]</span> <span class="o">=</span> <span class="n">depths</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of rs == 0: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rs</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.sum(~good_rs) BEFORE UPDATE= </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">good_rs</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">400</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;depths = </span><span class="si">{</span><span class="n">depths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;blank_inds[intersect_ray_index] = </span><span class="si">{</span><span class="n">blank_inds</span><span class="p">[</span><span class="n">intersect_ray_index</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.where(rs==0)[0] = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rs</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">good_rs</span><span class="p">[</span><span class="n">blank_inds</span><span class="p">[</span><span class="n">intersect_ray_index</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.sum(~good_rs) AFTER UPDATE = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">good_rs</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.all(good_rs) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">good_rs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">max_iter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hit max iterations </span><span class="si">{</span><span class="n">max_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span>
            
    <span class="k">if</span> <span class="n">replace_zero_values_with_center_distance</span><span class="p">:</span>
        <span class="n">m_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">zero_map</span> <span class="o">=</span> <span class="n">rs</span> <span class="o">&lt;=</span> <span class="mf">0.01</span>
        <span class="n">rs</span><span class="p">[</span><span class="n">zero_map</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[</span><span class="n">zero_map</span><span class="p">]</span> <span class="o">-</span> <span class="n">m_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rs</span></div>

<div class="viewcode-block" id="ray_trace_distance_by_mesh_center_dist"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ray_trace_distance_by_mesh_center_dist">[docs]</a><span class="k">def</span> <span class="nf">ray_trace_distance_by_mesh_center_dist</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: In case the ray trace comes</span>
<span class="sd">    back with an error or a measure of 0</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get the center of the mesh</span>
<span class="sd">    2) Find the distance of all face midpoints to mesh center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#1) get the center of the mesh</span>
    <span class="n">m_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="n">m_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">m_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m_dist</span></div>
        
<div class="viewcode-block" id="vertices_coordinates_to_vertex_index"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertices_coordinates_to_vertex_index">[docs]</a><span class="k">def</span> <span class="nf">vertices_coordinates_to_vertex_index</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">vertex_coordinates</span><span class="p">,</span><span class="n">error_on_unmatches</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To map the vertex coordinates to vertex indices</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_vertex</span> <span class="o">=</span> <span class="n">m_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">vertex_coordinates</span><span class="p">)</span>
    <span class="n">zero_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">error_on_unmatches</span><span class="p">:</span>
        <span class="n">mismatch_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_coordinates</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">zero_dist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mismatch_number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mismatch_number</span><span class="si">}</span><span class="s2"> of the vertices coordinates were not a perfect match&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">closest_vertex</span><span class="p">[</span><span class="n">zero_dist</span><span class="p">]</span></div>

<div class="viewcode-block" id="vertices_coordinates_to_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertices_coordinates_to_faces">[docs]</a><span class="k">def</span> <span class="nf">vertices_coordinates_to_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">vertex_coordinates</span><span class="p">,</span><span class="n">error_on_unmatches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">concatenate_unique_list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">vertex_indices</span> <span class="o">=</span> <span class="n">vertices_coordinates_to_vertex_index</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">vertex_coordinates</span><span class="p">,</span><span class="n">error_on_unmatches</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vertices_to_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">vertex_indices</span><span class="p">,</span><span class="n">concatenate_unique_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="vertices_to_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertices_to_faces">[docs]</a><span class="k">def</span> <span class="nf">vertices_to_faces</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">vertices</span><span class="p">,</span>
                     <span class="n">concatenate_unique_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: If have a list of vertex indices, to get the face indices associated with them</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="n">intermediate_face_list</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">vertex_faces</span><span class="p">[</span><span class="n">vertices</span><span class="p">]</span>
        <span class="n">faces_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">intermediate_face_list</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">concatenate_unique_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">faces_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">faces_list</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;vertices = </span><span class="si">{</span><span class="n">vertices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="s2">&quot;current_mesh_error_v_to_f&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="s2">&quot;vertices_error_v_to_f&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong in vertices to faces&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="vertices_coordinates_to_faces_old"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertices_coordinates_to_faces_old">[docs]</a><span class="k">def</span> <span class="nf">vertices_coordinates_to_faces_old</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">vertex_coordinates</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    Purpose: If have a list of vertex coordinates, to get the face indices associated with them</span>
<span class="sd">    </span>
<span class="sd">    Example: To check that it worked well with picking out border</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[curr_branch.mesh,curr_branch.mesh.submesh([unique_border_faces],append=True)],</span>
<span class="sd">                              other_meshes_colors=[&quot;red&quot;,&quot;black&quot;],</span>
<span class="sd">                              mesh_alpha=1)</span>

<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">border_vertices_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex_coordinates</span><span class="p">:</span>
            <span class="n">curr_match_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_match_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">border_vertices_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_match_idx</span><span class="p">)</span>
        <span class="n">border_vertices_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">border_vertices_idx</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="s2">&quot;current_mesh&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">vertex_coordinates</span><span class="p">,</span><span class="s2">&quot;vertex_coordinates&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went from for matching_rows&quot;</span><span class="p">)</span>
        
    <span class="n">border_faces</span> <span class="o">=</span> <span class="n">vertices_to_faces</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">vertices</span><span class="o">=</span><span class="n">border_vertices_idx</span><span class="p">)</span>
    <span class="n">unique_border_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">border_faces</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unique_border_faces</span></div>


<div class="viewcode-block" id="mesh_vertex_graph"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_vertex_graph">[docs]</a><span class="k">def</span> <span class="nf">mesh_vertex_graph</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Creates a weighted connectivity graph from the vertices and edges</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_weighted_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique_length</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  
    <span class="n">vertex_graph</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">curr_weighted_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vertex_graph</span></div>

<span class="c1"># ------------ Algorithms used for checking the spines -------- #</span>


<div class="viewcode-block" id="waterfilling_face_idx"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.waterfilling_face_idx">[docs]</a><span class="k">def</span> <span class="nf">waterfilling_face_idx</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                      <span class="n">starting_face_idx</span><span class="p">,</span>
                      <span class="n">n_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                         <span class="n">return_submesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will extend certain faces by infecting neighbors </span>
<span class="sd">    for a certain number of iterations:</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    curr_border_faces = tu.find_border_faces(curr_branch.mesh)</span>
<span class="sd">    expanded_border_mesh = tu.waterfilling_face_idx(curr_branch.mesh,</span>
<span class="sd">                                                    curr_border_faces,</span>
<span class="sd">                                                     n_iterations=10,</span>
<span class="sd">                                                    return_submesh=True)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[curr_branch.mesh,expanded_border_mesh],</span>
<span class="sd">                              other_meshes_colors=[&quot;black&quot;,&quot;red&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) set the starting faces</span>
    <span class="n">final_faces</span> <span class="o">=</span> <span class="n">starting_face_idx</span>
    
    <span class="c1">#0) Turn the mesh into a graph</span>
    <span class="k">if</span> <span class="n">connectivity</span><span class="o">==</span><span class="s2">&quot;edges&quot;</span><span class="p">:</span>
        <span class="n">total_mesh_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">face_adjacency</span><span class="p">)</span>
        <span class="c1">#2) expand the faces</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iterations</span><span class="p">):</span>
            <span class="n">final_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">total_mesh_graph</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">final_faces</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iterations</span><span class="p">):</span>
            <span class="n">final_faces</span> <span class="o">=</span> <span class="n">face_neighbors_by_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">final_faces</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="n">return_submesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">final_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_faces</span></div>
    
    
<div class="viewcode-block" id="find_border_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_border_vertices">[docs]</a><span class="k">def</span> <span class="nf">find_border_vertices</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># we know that in a watertight mesh every edge will be included twice</span>
    <span class="c1"># thus every edge which appears only once is part of a hole boundary</span>
    <span class="n">boundary_groups</span> <span class="o">=</span> <span class="n">group_rows</span><span class="p">(</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">edges_sorted</span><span class="p">,</span> <span class="n">require_count</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="n">vertices_idx</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_sorted</span><span class="p">[</span><span class="n">boundary_groups</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertices_idx</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_coordinates</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertices_idx</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vertices_idx</span></div>

<div class="viewcode-block" id="find_border_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_border_faces">[docs]</a><span class="k">def</span> <span class="nf">find_border_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">border_verts</span> <span class="o">=</span> <span class="n">find_border_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">border_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vertices_to_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">find_border_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())))</span>
    <span class="k">return</span> <span class="n">border_faces</span></div>


<div class="viewcode-block" id="find_border_vertex_groups"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_border_vertex_groups">[docs]</a><span class="k">def</span> <span class="nf">find_border_vertex_groups</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_cycles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_sizes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return all borders as faces and grouped together</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning because watertight or less than 3 edges&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_sizes</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]],[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]]</span>


    <span class="c1"># we know that in a watertight mesh every edge will be included twice</span>
    <span class="c1"># thus every edge which appears only once is part of a hole boundary</span>
    <span class="n">boundary_groups</span> <span class="o">=</span> <span class="n">group_rows</span><span class="p">(</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">edges_sorted</span><span class="p">,</span> <span class="n">require_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(boundary_groups) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_groups</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># mesh is not watertight and we have too few edges</span>
    <span class="c1"># edges to do a repair</span>
    <span class="c1"># since we haven&#39;t changed anything return False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_groups</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">boundary_edges</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">boundary_groups</span><span class="p">]</span>
    <span class="n">index_as_dict</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_groups</span><span class="p">]</span>

    <span class="c1"># we create a graph of the boundary edges, and find cycles.</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">boundary_edges</span><span class="p">,</span>
                         <span class="n">index_as_dict</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">return_cycles</span><span class="p">:</span>
        <span class="n">border_edge_groups</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_all_cycles</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">time_limit</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_edge_groups</span><span class="p">)</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finding the cycles did not work when doing the border vertex edge so using connected components&quot;</span><span class="p">)</span>
        <span class="n">border_edge_groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">border_edge_groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Psuedocode on converting list of edges to </span>
<span class="sd">    list of faces</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_edge_groups</span><span class="p">]</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">scatters</span><span class="o">=</span> <span class="n">scatters</span><span class="p">,</span><span class="n">scatters_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_coordinates</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_edge_groups</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_edge_groups</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_sizes</span><span class="p">:</span>
        <span class="n">border_groups_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_value</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">border_groups_len</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span></div>
    
    

<div class="viewcode-block" id="find_border_face_groups"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_border_face_groups">[docs]</a><span class="k">def</span> <span class="nf">find_border_face_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_sizes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return all borders as faces and grouped together</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># we know that in a watertight mesh every edge will be included twice</span>
    <span class="c1"># thus every edge which appears only once is part of a hole boundary</span>
    <span class="n">boundary_groups</span> <span class="o">=</span> <span class="n">group_rows</span><span class="p">(</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">edges_sorted</span><span class="p">,</span> <span class="n">require_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># mesh is not watertight and we have too few edges</span>
    <span class="c1"># edges to do a repair</span>
    <span class="c1"># since we haven&#39;t changed anything return False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_groups</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">boundary_edges</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">boundary_groups</span><span class="p">]</span>
    <span class="n">index_as_dict</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundary_groups</span><span class="p">]</span>

    <span class="c1"># we create a graph of the boundary edges, and find cycles.</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">boundary_edges</span><span class="p">,</span>
                         <span class="n">index_as_dict</span><span class="p">)))</span>
    <span class="n">border_edge_groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Psuedocode on converting list of edges to </span>
<span class="sd">    list of faces</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">border_face_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices_to_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">concatenate_unique_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">border_edge_groups</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_sizes</span><span class="p">:</span>
        <span class="n">border_groups_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_face_groups</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">border_face_groups</span><span class="p">,</span><span class="n">border_groups_len</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">border_face_groups</span></div>
    
<div class="viewcode-block" id="border_euclidean_length"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.border_euclidean_length">[docs]</a><span class="k">def</span> <span class="nf">border_euclidean_length</span><span class="p">(</span><span class="n">border</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The border does have to be specified as ordered coordinates</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ex_border_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">border</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">border</span> <span class="o">-</span> <span class="n">ex_border_shift</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="largest_hole_length"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.largest_hole_length">[docs]</a><span class="k">def</span> <span class="nf">largest_hole_length</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">euclidean_length</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find either the vertex count or the euclidean distance</span>
<span class="sd">    of the largest hole in a mesh</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">border_vert_groups</span><span class="p">,</span><span class="n">border_vert_sizes</span> <span class="o">=</span> <span class="n">find_border_vertex_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">return_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">return_sizes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                       <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="c1">#accounting for if found no holes</span>
    <span class="k">if</span> <span class="n">border_vert_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">euclidean_length</span><span class="p">:</span>
        <span class="n">border_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">border_euclidean_length</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_vert_groups</span><span class="p">]</span>
        <span class="n">largest_border_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">border_lengths</span><span class="p">)</span>
        <span class="n">largest_border_size</span> <span class="o">=</span> <span class="n">border_lengths</span><span class="p">[</span><span class="n">largest_border_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">largest_border_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">border_vert_sizes</span><span class="p">)</span></div>

<div class="viewcode-block" id="expand_border_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.expand_border_faces">[docs]</a><span class="k">def</span> <span class="nf">expand_border_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">n_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">return_submesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">curr_border_faces_groups</span> <span class="o">=</span> <span class="n">find_border_face_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">expanded_border_face_groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_border_faces</span> <span class="ow">in</span> <span class="n">curr_border_faces_groups</span><span class="p">:</span>
        <span class="n">expanded_border_mesh</span> <span class="o">=</span> <span class="n">waterfilling_face_idx</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                    <span class="n">curr_border_faces</span><span class="p">,</span>
                                                     <span class="n">n_iterations</span><span class="o">=</span><span class="n">n_iterations</span><span class="p">,</span>
                                                    <span class="n">return_submesh</span><span class="o">=</span><span class="n">return_submesh</span><span class="p">)</span>
        <span class="n">expanded_border_face_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expanded_border_mesh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expanded_border_face_groups</span></div>
    
<div class="viewcode-block" id="mesh_with_ends_cutoff"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_with_ends_cutoff">[docs]</a><span class="k">def</span> <span class="nf">mesh_with_ends_cutoff</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">n_iterations</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                         <span class="n">return_largest_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return a mesh with the ends with a border</span>
<span class="sd">    that are cut off by finding the border, expanding the border</span>
<span class="sd">    and then removing these faces and returning the largest piece</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Expand he border meshes</span>
<span class="sd">    2) Get a submesh without the border faces</span>
<span class="sd">    3) Split the mesh into significants pieces</span>
<span class="sd">    3b) Error if did not find any significant meshes</span>
<span class="sd">    4) If return largest mesh is True, only return the top one</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Expand he border meshes</span>
    <span class="n">curr_border_faces</span> <span class="o">=</span> <span class="n">expand_border_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">n_iterations</span><span class="o">=</span><span class="n">n_iterations</span><span class="p">,</span><span class="n">return_submesh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1">#2) Get a submesh without the border faces</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_border_faces</span><span class="p">)</span><span class="si">}</span><span class="s2"> border meshes of sizes: </span><span class="si">{</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">curr_border_faces</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
    <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">curr_border_faces</span><span class="p">))</span>
    <span class="n">leftover_submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces_to_keep</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Leftover submesh size: </span><span class="si">{leftover_submesh}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#3) Split the mesh into significants pieces</span>
    <span class="n">sig_leftover_pieces</span> <span class="o">=</span> <span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">leftover_submesh</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="n">significance_threshold</span><span class="p">)</span>
    
    <span class="c1">#3b) Error if did not find any significant meshes</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig_leftover_pieces</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No significant leftover pieces were detected after border subtraction&quot;</span><span class="p">)</span>
        
    <span class="c1">#4) If return largest mesh is True, only return the top one</span>
    <span class="k">if</span> <span class="n">return_largest_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sig_leftover_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sig_leftover_pieces</span></div>
<span class="w">    </span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Old method that only computed percentage of total number of border vertices</span>
<span class="sd">def filter_away_border_touching_submeshes(</span>
<span class="sd">                            mesh,</span>
<span class="sd">                            submesh_list,</span>
<span class="sd">                            border_percentage_threshold=0.5,#would make 0.00001 if wanted to enforce nullification if at most one touchedss</span>
<span class="sd">                            verbose = False,</span>
<span class="sd">                            return_meshes=True,</span>
<span class="sd">                            ):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return submeshes or indices that </span>
<span class="sd">    do not touch a border edge of the parenet mesh</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the border vertices of mesh</span>
<span class="sd">    2) For each submesh</span>
<span class="sd">    - do KDTree between submesh vertices and border vertices</span>
<span class="sd">    - if one of distances is equal to 0 then nullify</span>

<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    return_value = filter_away_border_touching_submeshes(</span>
<span class="sd">                                mesh = eraser_branch.mesh,</span>
<span class="sd">                                submesh_list = eraser_branch.spines,</span>
<span class="sd">                                verbose = True,</span>
<span class="sd">                                return_meshes=True)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(main_mesh_verts=mesh.vertices,</span>
<span class="sd">                           main_mesh_faces=mesh.faces,</span>
<span class="sd">                            other_meshes=eraser_branch.spines,</span>
<span class="sd">                                                  other_meshes_colors=&quot;red&quot;)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(main_mesh_verts=mesh.vertices,</span>
<span class="sd">                           main_mesh_faces=mesh.faces,</span>
<span class="sd">                            other_meshes=return_value,</span>
<span class="sd">                                other_meshes_colors=&quot;red&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    #1) Get the border vertices of mesh</span>
<span class="sd">    border_verts_idx = find_border_vertices(mesh)</span>
<span class="sd">    if len(border_verts_idx) == 0:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(&quot;There were no border edges for the main mesh&quot;)</span>
<span class="sd">        passed_idx = np.arange(len(submesh_list))</span>
<span class="sd">    else:</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        Want to just find a matching border group and then look </span>
<span class="sd">        at percentage</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="sd">        passed_idx = []</span>
<span class="sd">        for i,subm in enumerate(submesh_list):</span>
<span class="sd">            spine_kdtree = KDTree(subm.vertices)</span>
<span class="sd">            dist,closest_vert_idx = spine_kdtree.query(mesh.vertices[border_verts_idx])</span>
<span class="sd">            </span>
<span class="sd">            if len(dist[dist == 0])/len(border_verts_idx) &lt; border_percentage_threshold:</span>
<span class="sd">                passed_idx.append(i)</span>


<span class="sd">        passed_idx = np.array(passed_idx)</span>

<span class="sd">    if return_meshes:</span>
<span class="sd">        return [k for i,k in enumerate(submesh_list) if i in passed_idx]</span>
<span class="sd">    else:</span>
<span class="sd">        return passed_idx</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="filter_away_border_touching_submeshes_by_group"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_away_border_touching_submeshes_by_group">[docs]</a><span class="k">def</span> <span class="nf">filter_away_border_touching_submeshes_by_group</span><span class="p">(</span>
                            <span class="n">mesh</span><span class="p">,</span>
                            <span class="n">submesh_list</span><span class="p">,</span>
                            <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="c1">#would make 0.00001 if wanted to enforce nullification if at most one touchedss</span>
                            <span class="n">inverse_border_percentage_threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">return_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    
                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return submeshes or indices that </span>
<span class="sd">    do not touch a border edge of the parenet mesh</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the border vertices of mesh grouped</span>
<span class="sd">    2) For each submesh</span>
<span class="sd">       a. Find which border group the vertices overlap with (0 distances)</span>
<span class="sd">       b. For each group that it is touching </span>
<span class="sd">          i) Find the number of overlap</span>
<span class="sd">          ii) if the percentage is greater than threshold then nullify</span>
<span class="sd">    - </span>

<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    return_value = filter_away_border_touching_submeshes(</span>
<span class="sd">                                mesh = eraser_branch.mesh,</span>
<span class="sd">                                submesh_list = eraser_branch.spines,</span>
<span class="sd">                                verbose = True,</span>
<span class="sd">                                return_meshes=True)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(main_mesh_verts=mesh.vertices,</span>
<span class="sd">                           main_mesh_faces=mesh.faces,</span>
<span class="sd">                            other_meshes=eraser_branch.spines,</span>
<span class="sd">                                                  other_meshes_colors=&quot;red&quot;)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(main_mesh_verts=mesh.vertices,</span>
<span class="sd">                           main_mesh_faces=mesh.faces,</span>
<span class="sd">                            other_meshes=return_value,</span>
<span class="sd">                                other_meshes_colors=&quot;red&quot;)</span>
<span class="sd">                                </span>
<span class="sd">    Ex 2:</span>
<span class="sd">    tu = reload(tu)</span>
<span class="sd">    tu.filter_away_border_touching_submeshes_by_group(</span>
<span class="sd">        mesh=curr_branch.mesh,</span>
<span class="sd">        submesh_list=curr_branch.spines</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;border_percentage_threshold = </span><span class="si">{</span><span class="n">border_percentage_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#1) Get the border vertices of mesh</span>
    <span class="n">border_vertex_groups</span> <span class="o">=</span> <span class="n">find_border_vertex_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_vertex_groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There were no border edges for the main mesh&quot;</span><span class="p">)</span>
        <span class="n">passed_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">submesh_list</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Want to just find a matching border group and then look </span>
<span class="sd">        at percentage</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">passed_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">subm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">submesh_list</span><span class="p">):</span>
            <span class="c1">#creates KDTree for the submesh</span>
            <span class="n">spine_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">subm</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            
            <span class="n">not_touching_significant_border</span><span class="o">=</span><span class="kc">True</span>
            
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span><span class="n">b_verts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">border_vertex_groups</span><span class="p">):</span>
                <span class="n">dist</span><span class="p">,</span><span class="n">closest_vert_idx</span> <span class="o">=</span> <span class="n">spine_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">b_verts</span><span class="p">)])</span>
                <span class="n">touching_perc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">b_verts</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Submesh </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> touching percentage for border </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">touching_perc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">touching_perc</span> <span class="o">&gt;</span> <span class="n">border_percentage_threshold</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Submesh </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2"> was touching a greater percentage (</span><span class="si">{</span><span class="n">touching_perc</span><span class="si">}</span><span class="s2">) of border vertices than threshold (</span><span class="si">{</span><span class="n">border_percentage_threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="n">not_touching_significant_border</span><span class="o">=</span><span class="kc">False</span>
                    <span class="k">break</span>
            
            <span class="c1">#apply the spine check that will see if percentage of border vertices of spine touching mesh border vertices</span>
            <span class="c1">#is above some threshold</span>
            <span class="k">if</span> <span class="n">inverse_border_percentage_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying inverse_border_percentage_threshold = </span><span class="si">{</span><span class="n">inverse_border_percentage_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;border_vertex_groups = </span><span class="si">{</span><span class="n">border_vertex_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">all_border_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_vertex_groups</span><span class="p">])</span>
                <span class="n">whole_border_kdtree</span><span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">all_border_verts</span><span class="p">])</span>
                <span class="n">dist</span><span class="p">,</span><span class="n">closest_vert_idx</span> <span class="o">=</span> <span class="n">whole_border_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">subm</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">touching_perc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">touching_perc</span> <span class="o">&gt;</span> <span class="n">inverse_border_percentage_threshold</span><span class="p">:</span>
                    <span class="n">not_touching_significant_border</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="n">not_touching_significant_border</span><span class="p">:</span>
                <span class="n">passed_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


        <span class="n">passed_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">passed_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At end passed_idx = </span><span class="si">{</span><span class="n">passed_idx</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">submesh_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">passed_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">passed_idx</span></div>

    
<div class="viewcode-block" id="max_distance_betwee_mesh_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.max_distance_betwee_mesh_vertices">[docs]</a><span class="k">def</span> <span class="nf">max_distance_betwee_mesh_vertices</span><span class="p">(</span><span class="n">mesh_1</span><span class="p">,</span><span class="n">mesh_2</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">max_distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will calculate the maximum distance between vertices of two meshes</span>
<span class="sd">    </span>
<span class="sd">    Application: Can be used to see how well a poisson reconstruction</span>
<span class="sd">    estimate of a soma and the actual soma that was backtracked to </span>
<span class="sd">    the mesh are in order to identify true somas and not</span>
<span class="sd">    get fooled by the glia / neural error checks</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Make a KDTree from the new backtracked soma</span>
<span class="sd">    2) Do a query of the poisson soma vertices</span>
<span class="sd">    3) If a certain distance is too far then fail</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#print(f&quot;mesh_1={mesh_1},mesh_2 = {mesh_2}&quot;)</span>
    <span class="c1">#1) Make a KDTree from the new backtracked soma</span>
    <span class="n">backtrack_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh_1</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="c1">#2) Do a query of the poisson soma vertices</span>
    <span class="n">check_mesh_distances</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">backtrack_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh_2</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="c1">#print(f&quot;check_mesh_distances = {check_mesh_distances}&quot;)</span>
    <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">check_mesh_distances</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;maximum distance from mesh_2 vertices to mesh_1 vertices is = </span><span class="si">{</span><span class="n">max_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">max_distance_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_dist</span> <span class="o">&gt;</span> <span class="n">max_distance_threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshlab</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="fill_holes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.fill_holes">[docs]</a><span class="k">def</span> <span class="nf">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
              <span class="n">max_hole_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
              <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="p">):</span>
    
    <span class="n">mesh</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">()</span>
    
    
    <span class="c1">#if len(tu.find_border_face_groups(mesh))==0 and tu.is_manifold(mesh) and tu.is_watertight(mesh):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">find_border_face_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No holes needed to fill and mesh was watertight and no vertex group&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mesh</span>
        
    <span class="n">lrg_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">with</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">FillHoles</span><span class="p">(</span><span class="n">max_hole_size</span><span class="o">=</span><span class="n">max_hole_size</span><span class="p">,</span><span class="n">self_itersect_faces</span><span class="o">=</span><span class="n">self_itersect_faces</span><span class="p">)</span> <span class="k">as</span> <span class="n">fill_hole_obj</span><span class="p">:</span>

        <span class="n">mesh_filled_holes</span><span class="p">,</span><span class="n">fillholes_file_obj</span> <span class="o">=</span> <span class="n">fill_hole_obj</span><span class="p">(</span>   
                                            <span class="n">vertices</span><span class="o">=</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                             <span class="n">faces</span><span class="o">=</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                             <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh_filled_holes</span></div>

<div class="viewcode-block" id="filter_meshes_by_containing_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_meshes_by_containing_coordinates">[docs]</a><span class="k">def</span> <span class="nf">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span><span class="n">nullifying_points</span><span class="p">,</span>
                                                <span class="n">filter_away</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">method</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
                                           <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will either filter away or keep meshes from a list of meshes</span>
<span class="sd">    based on points based to the function</span>
<span class="sd">    </span>
<span class="sd">    Application: Can filter away spines that are too close to the endpoints of skeletons</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    import trimesh</span>
<span class="sd">    from python_tools import numpy_dep as np</span>
<span class="sd">    tu = reload(tu)</span>

<span class="sd">    curr_limb = recovered_neuron[2]</span>
<span class="sd">    curr_limb_end_coords = find_skeleton_endpoint_coordinates(curr_limb.skeleton)</span>


<span class="sd">    kept_spines = []</span>

<span class="sd">    for curr_branch in curr_limb:</span>
<span class="sd">        #a) get the spines</span>
<span class="sd">        curr_spines = curr_branch.spines</span>

<span class="sd">        #For each spine:</span>
<span class="sd">        if not curr_spines is None:</span>
<span class="sd">            curr_kept_spines = tu.filter_meshes_by_bbox_containing_coordinates(curr_spines,</span>
<span class="sd">                                                                            curr_limb_end_coords)</span>
<span class="sd">            print(f&quot;curr_kept_spines = {curr_kept_spines}&quot;)</span>
<span class="sd">            kept_spines += curr_kept_spines</span>

<span class="sd">    ipvu.plot_objects(meshes=kept_spines)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
        <span class="n">mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_list</span><span class="p">]</span>
        
    <span class="n">nullifying_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nullifying_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="n">containing_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">containing_meshes_idx</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">non_containing_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">non_containing_meshes_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sp_m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
        <span class="c1"># tried filling hole and using contains</span>
        <span class="c1">#sp_m_filled = tu.fill_holes(sp_m)</span>
        <span class="c1">#contains_results = sp_m.bounds.contains(currc_limb_end_coords)</span>

        <span class="c1">#tried using the bounds method</span>
        <span class="c1">#contains_results = trimesh.bounds.contains(sp_m.bounds,currc_limb_end_coords.reshape(-1,3))</span>

        <span class="c1">#final version</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;bounding_box&quot;</span><span class="p">:</span>
            <span class="n">contains_results</span> <span class="o">=</span> <span class="n">sp_m</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">nullifying_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="n">sp_m_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">sp_m</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">distances</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">sp_m_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">nullifying_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">contains_results</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">distance_threshold</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Submesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">sp_m</span><span class="si">}</span><span class="s2">) distances = </span><span class="si">{</span><span class="n">distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Min distance </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;contains_results = </span><span class="si">{</span><span class="n">contains_results</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented method (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">) requested&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.sum(contains_results) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contains_results</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contains_results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">containing_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_m</span><span class="p">)</span>
            <span class="n">containing_meshes_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_containing_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_m</span><span class="p">)</span>
            <span class="n">non_containing_meshes_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;containing_meshes = </span><span class="si">{</span><span class="n">containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;non_containing_meshes = </span><span class="si">{</span><span class="n">non_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">filter_away</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">non_containing_meshes_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">non_containing_meshes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">containing_meshes_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">containing_meshes</span></div>
    

<span class="c1"># --------------- 11/11 ---------------------- #</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshlab</span> 
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="poisson_surface_reconstruction"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.poisson_surface_reconstruction">[docs]</a><span class="k">def</span> <span class="nf">poisson_surface_reconstruction</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                   <span class="n">output_folder</span><span class="o">=</span><span class="s2">&quot;./temp&quot;</span><span class="p">,</span>
                                  <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">return_largest_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">return_significant_meshes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">significant_mesh_threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                  <span class="n">manifold_clean</span> <span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
        <span class="n">output_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_folder</span><span class="p">))</span>
        <span class="n">output_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># CGAL Step 1: Do Poisson Surface Reconstruction</span>
    <span class="n">Poisson_obj</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;mesh_</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    
    <span class="n">skeleton_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     Starting Screened Poisson&quot;</span><span class="p">)</span>
    <span class="n">new_mesh</span><span class="p">,</span><span class="n">output_subprocess_obj</span> <span class="o">=</span> <span class="n">Poisson_obj</span><span class="p">(</span>   
                                <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                 <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                <span class="n">mesh_filename</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.off&quot;</span><span class="p">,</span>
                                 <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">delete_temp_files</span><span class="o">=</span><span class="n">delete_temp_files</span><span class="p">,</span>
                                <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-----Time for Screened Poisson= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">skeleton_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_largest_mesh</span><span class="p">:</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">,</span>
                                               <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                               <span class="n">connectivity</span><span class="o">=</span><span class="s1">&#39;edges&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#only want to check manifoldness if it is one piece</span>
        <span class="k">if</span> <span class="n">manifold_clean</span><span class="p">:</span>
            <span class="n">new_mesh</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">()</span>
            <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">)</span>
            <span class="c1">#new_mesh = tu.connected_nondegenerate_mesh(mesh)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh manifold status: </span><span class="si">{</span><span class="n">tu</span><span class="o">.</span><span class="n">is_manifold</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh watertight status: </span><span class="si">{</span><span class="n">tu</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_significant_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">,</span>
                                               <span class="n">significance_threshold</span><span class="o">=</span><span class="n">significant_mesh_threshold</span><span class="p">,</span>
                                               <span class="n">connectivity</span><span class="o">=</span><span class="s1">&#39;edges&#39;</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">new_mesh</span></div>


<div class="viewcode-block" id="decimate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.decimate">[docs]</a><span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
               <span class="n">decimation_ratio</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
               <span class="n">output_folder</span><span class="o">=</span><span class="s2">&quot;./temp&quot;</span><span class="p">,</span>
              <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
        <span class="n">output_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_folder</span><span class="p">))</span>
        <span class="n">output_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># CGAL Step 1: Do Poisson Surface Reconstruction</span>
    <span class="n">Decimator_obj</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Decimator</span><span class="p">(</span><span class="n">decimation_ratio</span><span class="p">,</span><span class="n">output_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;mesh_</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">skeleton_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     Starting Screened Poisson&quot;</span><span class="p">)</span>
    <span class="c1">#Step 1: Decimate the Mesh and then split into the seperate pieces</span>
    <span class="n">new_mesh</span><span class="p">,</span><span class="n">output_obj</span> <span class="o">=</span> <span class="n">Decimator_obj</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
             <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
             <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-----Time for Screened Poisson= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">skeleton_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">new_mesh</span></div>
        


<div class="viewcode-block" id="pymeshfix_clean"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.pymeshfix_clean">[docs]</a><span class="k">def</span> <span class="nf">pymeshfix_clean</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                    <span class="n">joincomp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">remove_smallest_components</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will apply the pymeshfix algorithm</span>
<span class="sd">    to clean the mesh</span>
<span class="sd">    </span>
<span class="sd">    Application: Can help with soma identificaiton</span>
<span class="sd">    because otherwise nucleus could interfere with the segmentation</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Staring pymeshfix on </span><span class="si">{</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">meshfix</span> <span class="o">=</span> <span class="n">pymeshfix</span><span class="o">.</span><span class="n">MeshFix</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    
    <span class="n">meshfix</span><span class="o">.</span><span class="n">repair</span><span class="p">(</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">joincomp</span><span class="o">=</span><span class="n">joincomp</span><span class="p">,</span>
                   <span class="n">remove_smallest_components</span><span class="o">=</span><span class="n">remove_smallest_components</span>
                  <span class="p">)</span>
    <span class="n">current_neuron_poisson_pymeshfix</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">meshfix</span><span class="o">.</span><span class="n">v</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">meshfix</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for pymeshfix = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">current_neuron_poisson_pymeshfix</span></div>




<div class="viewcode-block" id="mesh_segmentation_largest_conn_comp"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_segmentation_largest_conn_comp">[docs]</a><span class="k">def</span> <span class="nf">mesh_segmentation_largest_conn_comp</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">smoothness</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="p">),</span>
        <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>


        <span class="n">delete_temp_files</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">,</span>
        <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="c1">#will only be used if returning meshes</span>
        <span class="n">return_ordered_by_size</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_mesh_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function tha segments the mesh and then </span>
<span class="sd">    either returns:</span>
<span class="sd">    1) Face indexes of different mesh segments</span>
<span class="sd">    2) The cut up mesh into different mesh segments</span>
<span class="sd">    3) Can optionally return the sdf values of the different mesh</span>

<span class="sd">    Example: </span>
<span class="sd">    tu = reload(tu)</span>

<span class="sd">    meshes_split,meshes_split_sdf = tu.mesh_segmentation(</span>
<span class="sd">        mesh = real_soma</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="c1"># ------- 1/14 Additon: Going to make sure mesh has no degenerate faces --- #</span>
    <span class="n">mesh_to_segment</span><span class="p">,</span><span class="n">faces_kept</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">connected_nondegenerate_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                                 <span class="n">return_kept_faces_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">return_removed_faces_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1">#-------- 1/14 Addition: Will check for just a sheet of mesh with a 0 sdf ---------#</span>
    <span class="n">sdf_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh_to_segment</span><span class="p">)</span>
    <span class="n">perc_0_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sdf_faces</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">sdf_faces</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_0_faces = </span><span class="si">{</span><span class="n">perc_0_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perc_0_faces</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">cgal_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        <span class="n">cgal_sdf_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        
        <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cgal_folder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">cgal_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">mesh_temp_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Both mesh and filepath are None&quot;</span><span class="p">)</span>
            <span class="n">file_dest</span> <span class="o">=</span> <span class="n">cgal_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">_mesh.off&quot;</span><span class="p">)</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">write_neuron_off</span><span class="p">(</span><span class="n">mesh_to_segment</span><span class="p">,</span><span class="n">file_dest</span><span class="p">)</span>
            <span class="n">mesh_temp_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">filepath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">filepath</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span>
        <span class="n">filepath_no_ext</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">filepath</span><span class="o">.</span><span class="n">stem</span>


        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Going to run cgal segmentation with:&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">File: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">clusters:</span><span class="si">{</span><span class="n">clusters</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">smoothness:</span><span class="si">{</span><span class="n">smoothness</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">csm</span><span class="o">.</span><span class="n">cgal_segmentation</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">),</span><span class="n">clusters</span><span class="p">,</span><span class="n">smoothness</span><span class="p">)</span>

        <span class="c1">#read in the csv file</span>
        <span class="n">cgal_output_file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-cgal_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothness</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span> <span class="p">)</span>
        <span class="n">cgal_output_file_sdf</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-cgal_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothness</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_sdf.csv&quot;</span> <span class="p">)</span>

        <span class="n">cgal_data_pre_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cgal_output_file</span><span class="o">.</span><span class="n">absolute</span><span class="p">()),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">cgal_sdf_data_pre_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cgal_output_file_sdf</span><span class="o">.</span><span class="n">absolute</span><span class="p">()),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; 1/14: Need to adjust for the degenerate faces removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cgal_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cgal_data_pre_filt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cgal_data</span><span class="p">[</span><span class="n">faces_kept</span><span class="p">]</span> <span class="o">=</span> <span class="n">cgal_data_pre_filt</span>

        <span class="n">cgal_sdf_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        <span class="n">cgal_sdf_data</span><span class="p">[</span><span class="n">faces_kept</span><span class="p">]</span> <span class="o">=</span> <span class="n">cgal_sdf_data_pre_filt</span>
    
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span> <span class="o">=</span> <span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">cgal_data</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="n">check_connect_comp</span><span class="p">,</span>
                                                                  <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_segmentation</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial segmentation with clusters = </span><span class="si">{</span><span class="n">clusters</span><span class="si">}</span><span class="s2">, smoothness = </span><span class="si">{</span><span class="n">smoothness</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">split_meshes</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)))</span>
    
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; OLD METHOD NOT DOING SORTING CORRECTLY</span>
<span class="sd">        if return_ordered_by_size:</span>
<span class="sd">            split_meshes,split_meshes_sort_idx = sort_meshes_largest_to_smallest(split_meshes,return_idx=True)</span>
<span class="sd">            split_meshes_idx = split_meshes_idx[split_meshes_sort_idx]</span>

<span class="sd">        if return_sdf:</span>
<span class="sd">            #will return sdf data for all of the meshes</span>
<span class="sd">            sdf_medains_for_mesh = np.array([np.median(cgal_sdf_data[k]) for k in split_meshes_idx])</span>

<span class="sd">            if return_ordered_by_size:</span>
<span class="sd">                sdf_medains_for_mesh = sdf_medains_for_mesh[split_meshes_sort_idx]</span>
<span class="sd">            </span>
<span class="sd">            if return_mesh_idx:</span>
<span class="sd">                return_value= split_meshes,sdf_medains_for_mesh,split_meshes_idx</span>
<span class="sd">            else:</span>
<span class="sd">                return_value= split_meshes,sdf_medains_for_mesh,</span>
<span class="sd">        else:</span>
<span class="sd">            if return_mesh_idx:</span>
<span class="sd">                return_value= split_meshes,split_meshes_idx</span>
<span class="sd">            else:</span>
<span class="sd">                return_value= split_meshes</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">return_ordered_by_size</span><span class="p">:</span>
            <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_sort_idx</span> <span class="o">=</span> <span class="n">sort_meshes_largest_to_smallest</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">split_meshes_idx</span> <span class="o">=</span> <span class="n">split_meshes_idx</span><span class="p">[</span><span class="n">split_meshes_sort_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="c1">#will return sdf data for all of the meshes</span>
            <span class="n">sdf_medains_for_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cgal_sdf_data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">split_meshes_idx</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">sdf_medains_for_mesh</span><span class="p">,</span><span class="n">split_meshes_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">sdf_medains_for_mesh</span><span class="p">,</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span>
            
            
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">=</span> <span class="n">cgal_data</span><span class="p">,</span><span class="n">cgal_sdf_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">=</span> <span class="n">cgal_data</span>

    <span class="k">if</span> <span class="n">delete_temp_files</span><span class="p">:</span>
        <span class="n">cgal_output_file</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="n">cgal_output_file_sdf</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mesh_temp_file</span><span class="p">:</span>
            <span class="n">filepath</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="mesh_segmentation"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_segmentation">[docs]</a><span class="k">def</span> <span class="nf">mesh_segmentation</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">smoothness</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="p">),</span>
    <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>


    <span class="n">delete_temp_files</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="c1">#will only be used if returning meshes</span>
    <span class="n">return_ordered_by_size</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># -- for the connected components</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
    <span class="n">min_n_faces_conn_comp</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="c1">#plot_conn_comp_segmentation = False,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">return_mesh_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function tha segments the mesh and then </span>
<span class="sd">    either returns:</span>
<span class="sd">    1) Face indexes of different mesh segments</span>
<span class="sd">    2) The cut up mesh into different mesh segments</span>
<span class="sd">    3) Can optionally return the sdf values of the different mesh</span>

<span class="sd">    Example: </span>
<span class="sd">    tu = reload(tu)</span>

<span class="sd">    meshes_split,meshes_split_sdf = tu.mesh_segmentation(</span>
<span class="sd">        mesh = real_soma</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="n">mesh_filtered</span><span class="p">,</span><span class="n">nondeg_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_degenerate_faces</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">return_face_idxs</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


    <span class="n">cgal_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
    <span class="n">cgal_sdf_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nondeg_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conn_mesh</span><span class="p">,</span><span class="n">conn_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">mesh_filtered</span><span class="p">,</span>
                                <span class="n">significance_threshold</span><span class="o">=</span><span class="n">min_n_faces_conn_comp</span><span class="p">,</span>
                               <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">mesh_to_segment</span><span class="p">,</span><span class="n">faces_kept</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">conn_mesh</span><span class="p">,</span><span class="n">conn_faces</span><span class="p">)):</span>
            <span class="n">curr_delete_temp_files</span> <span class="o">=</span> <span class="n">delete_temp_files</span>
            <span class="c1">#-------- 1/14 Addition: Will check for just a sheet of mesh with a 0 sdf ---------#</span>
    <span class="c1">#         if len(mesh_to_segment.faces) &lt; min_n_faces_conn_comp:</span>
    <span class="c1">#             if verbose:</span>
    <span class="c1">#                 print(f&quot;Skipping mesh {j} because n_faces ({len(mesh_to_segment.faces)}) less than min threshold ({min_n_faces_conn_comp})&quot;)</span>
    <span class="c1">#             continue</span>
            <span class="n">sdf_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh_to_segment</span><span class="p">)</span>
            <span class="n">perc_0_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sdf_faces</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">sdf_faces</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_0_faces = </span><span class="si">{</span><span class="n">perc_0_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">perc_0_faces</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cgal_data_pre_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_to_segment</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
                <span class="n">cgal_sdf_data_pre_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_to_segment</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

                <span class="n">curr_delete_temp_files</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cgal_folder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="n">cgal_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">mesh_temp_file</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Both mesh and filepath are None&quot;</span><span class="p">)</span>
                    <span class="n">file_dest</span> <span class="o">=</span> <span class="n">cgal_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">_mesh.off&quot;</span><span class="p">)</span>
                    <span class="n">mesh_filepath</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">write_neuron_off</span><span class="p">(</span><span class="n">mesh_to_segment</span><span class="p">,</span><span class="n">file_dest</span><span class="p">)</span>
                    <span class="n">mesh_temp_file</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">mesh_filepath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">mesh_filepath</span><span class="p">)</span>

                <span class="k">assert</span><span class="p">(</span><span class="n">mesh_filepath</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span>
                <span class="n">filepath_no_ext</span> <span class="o">=</span> <span class="n">mesh_filepath</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mesh_filepath</span><span class="o">.</span><span class="n">stem</span>


                <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Going to run cgal segmentation with:&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">File: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">clusters:</span><span class="si">{</span><span class="n">clusters</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">smoothness:</span><span class="si">{</span><span class="n">smoothness</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">csm</span><span class="o">.</span><span class="n">cgal_segmentation</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">),</span><span class="n">clusters</span><span class="p">,</span><span class="n">smoothness</span><span class="p">)</span>

                <span class="c1">#read in the csv file</span>
                <span class="n">cgal_output_file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-cgal_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothness</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span> <span class="p">)</span>
                <span class="n">cgal_output_file_sdf</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath_no_ext</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-cgal_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothness</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_sdf.csv&quot;</span> <span class="p">)</span>

                <span class="n">cgal_data_pre_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cgal_output_file</span><span class="o">.</span><span class="n">absolute</span><span class="p">()),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">cgal_sdf_data_pre_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cgal_output_file_sdf</span><span class="o">.</span><span class="n">absolute</span><span class="p">()),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot; 1/14: Need to adjust for the degenerate faces removed</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="n">cgal_data</span><span class="p">[</span><span class="n">nondeg_faces</span><span class="p">[</span><span class="n">faces_kept</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cgal_data_pre_filt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cgal_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">cgal_sdf_data</span><span class="p">[</span><span class="n">nondeg_faces</span><span class="p">[</span><span class="n">faces_kept</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cgal_sdf_data_pre_filt</span>


            <span class="k">if</span> <span class="n">curr_delete_temp_files</span><span class="p">:</span>
                <span class="n">cgal_output_file</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
                <span class="n">cgal_output_file_sdf</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">mesh_temp_file</span><span class="p">:</span>
                    <span class="n">mesh_filepath</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>



    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span><span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">cgal_data</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="n">check_connect_comp</span><span class="p">,</span>
                                                                  <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_segmentation</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial segmentation with clusters = </span><span class="si">{</span><span class="n">clusters</span><span class="si">}</span><span class="s2">, smoothness = </span><span class="si">{</span><span class="n">smoothness</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">split_meshes</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)),</span>
                         <span class="n">buffer</span> <span class="o">=</span> <span class="n">plot_buffer</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_ordered_by_size</span><span class="p">:</span>
            <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_sort_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">sort_meshes_largest_to_smallest</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">split_meshes_idx</span> <span class="o">=</span> <span class="n">split_meshes_idx</span><span class="p">[</span><span class="n">split_meshes_sort_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="c1">#will return sdf data for all of the meshes</span>
            <span class="n">sdf_medains_for_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cgal_sdf_data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">split_meshes_idx</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">sdf_medains_for_mesh</span><span class="p">,</span><span class="n">split_meshes_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">sdf_medains_for_mesh</span><span class="p">,</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">=</span> <span class="n">split_meshes</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">=</span> <span class="n">cgal_data</span><span class="p">,</span><span class="n">cgal_sdf_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">=</span> <span class="n">cgal_data</span>



    <span class="k">return</span> <span class="n">return_value</span></div>

<span class="sd">&quot;&quot;&quot;Purpose: crude check to see if mesh is manifold:</span>

<span class="sd">https://gamedev.stackexchange.com/questions/61878/how-check-if-an-arbitrary-given-mesh-is-a-single-closed-mesh</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="convert_trimesh_to_o3d"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.convert_trimesh_to_o3d">[docs]</a><span class="k">def</span> <span class="nf">convert_trimesh_to_o3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">TriangleMesh</span><span class="p">()):</span>
        <span class="n">new_o3d_mesh</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">TriangleMesh</span><span class="p">()</span>
        <span class="n">new_o3d_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">new_o3d_mesh</span><span class="o">.</span><span class="n">triangles</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3iVector</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_o3d_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">return</span> <span class="n">new_o3d_mesh</span></div>

<div class="viewcode-block" id="convert_o3d_to_trimesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.convert_o3d_to_trimesh">[docs]</a><span class="k">def</span> <span class="nf">convert_o3d_to_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span>
                                    <span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                                   <span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span>
                                <span class="n">vertex_normals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span><span class="p">)</span>
                                  <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">return</span> <span class="n">new_mesh</span></div>
    
<div class="viewcode-block" id="mesh_volume_o3d"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_volume_o3d">[docs]</a><span class="k">def</span> <span class="nf">mesh_volume_o3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">mesh_o3d</span> <span class="o">=</span> <span class="n">convert_trimesh_to_o3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh_o3d</span><span class="o">.</span><span class="n">get_volume</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="is_manifold"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.is_manifold">[docs]</a><span class="k">def</span> <span class="nf">is_manifold</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="c1">#su.compressed_pickle(mesh,&quot;manifold_debug_mesh&quot;)</span>
    <span class="n">mesh_o3d</span> <span class="o">=</span> <span class="n">convert_trimesh_to_o3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">mesh_o3d</span><span class="o">.</span><span class="n">is_vertex_manifold</span><span class="p">()</span></div>

<div class="viewcode-block" id="is_watertight"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.is_watertight">[docs]</a><span class="k">def</span> <span class="nf">is_watertight</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">allow_if_no_border_verts</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">wat_tight</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">is_watertight</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wat_tight</span> <span class="ow">and</span> <span class="n">allow_if_no_border_verts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mesh</span><span class="o">.</span><span class="n">volume</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wat_tight</span></div>

<div class="viewcode-block" id="get_non_manifold_edges"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.get_non_manifold_edges">[docs]</a><span class="k">def</span> <span class="nf">get_non_manifold_edges</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">mesh_o3d</span> <span class="o">=</span> <span class="n">convert_trimesh_to_o3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh_o3d</span><span class="o">.</span><span class="n">get_non_manifold_edges</span><span class="p">())</span></div>

<div class="viewcode-block" id="get_non_manifold_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.get_non_manifold_vertices">[docs]</a><span class="k">def</span> <span class="nf">get_non_manifold_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">mesh_o3d</span> <span class="o">=</span> <span class="n">convert_trimesh_to_o3d</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh_o3d</span><span class="o">.</span><span class="n">get_non_manifold_vertices</span><span class="p">())</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">From trimesh:</span>

<span class="sd">self.remove_infinite_values()</span>
<span class="sd">self.merge_vertices(**kwargs)</span>
<span class="sd"># if we&#39;re cleaning remove duplicate</span>
<span class="sd"># and degenerate faces</span>

<span class="sd">if validate:</span>
<span class="sd">    self.remove_duplicate_faces()</span>
<span class="sd">    self.remove_degenerate_faces()</span>
<span class="sd">    self.fix_normals()</span>


<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="connected_nondegenerate_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.connected_nondegenerate_mesh">[docs]</a><span class="k">def</span> <span class="nf">connected_nondegenerate_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">return_kept_faces_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_removed_faces_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert a mesh to a connected non-degenerate mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseuducode:</span>
<span class="sd">    1) Find all the non-degnerate faces indices</span>
<span class="sd">    2) Split the mesh with the connectivity and returns the largest mesh</span>
<span class="sd">    3) Return a submesh of all non degenerate faces and the split meshes</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh_filtered</span><span class="p">,</span><span class="n">nondeg_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_degenerate_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">return_face_idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nondeg_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No mesh after removing degenerate faces&quot;</span><span class="p">)</span>
    <span class="n">conn_mesh</span><span class="p">,</span><span class="n">conn_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">mesh_filtered</span><span class="p">,</span>
                                <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    
    <span class="n">kept_faces</span> <span class="o">=</span> <span class="n">nondeg_faces</span><span class="p">[</span><span class="n">conn_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">not_kept_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">kept_faces</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">plot</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of faces kept = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">kept_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">kept_faces</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">not_kept_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; --&gt; red = kept mesh&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">conn_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="p">)</span>
                                                
    <span class="k">if</span> <span class="n">return_kept_faces_idx</span> <span class="ow">and</span> <span class="n">return_removed_faces_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conn_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kept_faces</span><span class="p">,</span><span class="n">not_kept_faces</span>
    <span class="k">elif</span> <span class="n">return_kept_faces_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conn_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kept_faces</span>
    <span class="k">elif</span> <span class="n">return_removed_faces_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conn_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">not_kept_faces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conn_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="find_degenerate_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_degenerate_faces">[docs]</a><span class="k">def</span> <span class="nf">find_degenerate_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_nondegenerate_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">nondegenerate</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">triangles</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">(</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">triangles</span><span class="p">,</span>
                <span class="n">areas</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">area_faces</span><span class="p">,</span>

                <span class="n">height</span><span class="o">=</span><span class="n">trimesh</span><span class="o">.</span><span class="n">tol</span><span class="o">.</span><span class="n">merge</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_nondegenerate_faces</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nondegenerate</span><span class="o">==</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nondegenerate</span><span class="o">==</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="find_nondegenerate_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_nondegenerate_faces">[docs]</a><span class="k">def</span> <span class="nf">find_nondegenerate_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">find_degenerate_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_nondegenerate_faces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="remove_degenerate_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.remove_degenerate_faces">[docs]</a><span class="k">def</span> <span class="nf">remove_degenerate_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_face_idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">nondeg_faces</span> <span class="o">=</span> <span class="n">find_nondegenerate_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">nondeg_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_face_idxs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_mesh</span><span class="p">,</span><span class="n">nondeg_faces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_mesh</span></div>

<div class="viewcode-block" id="mesh_interior"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_interior">[docs]</a><span class="k">def</span> <span class="nf">mesh_interior</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                    <span class="n">return_interior</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">quality_max</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">max_hole_size</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                     <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    
                    <span class="o">**</span><span class="n">kwargs</span>
              <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">try_hole_close</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                  <span class="n">max_hole_size</span><span class="o">=</span><span class="n">max_hole_size</span><span class="p">,</span>
                  <span class="n">self_itersect_faces</span><span class="o">=</span><span class="n">self_itersect_faces</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The hole closing did not work so continuing without&quot;</span><span class="p">)</span>
            <span class="k">pass</span>
                
    <span class="k">with</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Interior</span><span class="p">(</span><span class="n">return_interior</span><span class="o">=</span><span class="n">return_interior</span><span class="p">,</span>
                                <span class="n">quality_max</span><span class="o">=</span><span class="n">quality_max</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">remove_obj</span><span class="p">:</span>

        <span class="n">mesh_remove_interior</span><span class="p">,</span><span class="n">remove_file_obj</span> <span class="o">=</span> <span class="n">remove_obj</span><span class="p">(</span>   
                                            <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                             <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                             <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh_remove_interior</span></div>

<div class="viewcode-block" id="remove_mesh_interior"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.remove_mesh_interior">[docs]</a><span class="k">def</span> <span class="nf">remove_mesh_interior</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">inside_pieces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span>
                         <span class="n">quality_max</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">return_removed_pieces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                         <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will remove interior faces of a mesh with a certain significant size</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">inside_pieces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_interior_mesh</span> <span class="o">=</span> <span class="n">mesh_interior</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_interior</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">quality_max</span><span class="o">=</span><span class="n">quality_max</span><span class="p">,</span>
                                       <span class="n">try_hole_close</span><span class="o">=</span><span class="n">try_hole_close</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inside remove_mesh_interior and using precomputed inside_pieces&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">inside_pieces</span><span class="p">):</span>
            <span class="n">curr_interior_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">inside_pieces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_interior_mesh</span> <span class="o">=</span> <span class="n">inside_pieces</span>
        
    
    <span class="n">sig_inside</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">curr_interior_mesh</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="n">size_threshold_to_remove</span><span class="p">,</span>
                                            <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig_inside</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sig_meshes_no_threshold</span> <span class="o">=</span> <span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">curr_interior_mesh</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">meshes_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig_meshes_no_threshold</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No significant (</span><span class="si">{</span><span class="n">size_threshold_to_remove</span><span class="si">}</span><span class="s2">) interior meshes present&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meshes_sizes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;largest is </span><span class="si">{</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">meshes_sizes</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
            <span class="n">return_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_mesh</span><span class="o">=</span> <span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing the following inside neurons: </span><span class="si">{</span><span class="n">sig_inside</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
            <span class="n">return_mesh</span><span class="o">=</span> <span class="n">subtract_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">sig_inside</span><span class="p">,</span>
                    <span class="n">return_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span>
                   <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_mesh</span><span class="o">=</span> <span class="n">subtract_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">sig_inside</span><span class="p">,</span>
                                      <span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">return_removed_pieces</span><span class="p">:</span>
        <span class="c1"># --- 11/15: Need to only return inside pieces that are mapped to the original face ---</span>
        <span class="n">sig_inside_remapped</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span>
                                                          <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">sig_inside</span><span class="p">]</span>
        <span class="n">sig_inside_remapped</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig_inside_remapped</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">]</span> 
        <span class="k">return</span> <span class="n">return_mesh</span><span class="p">,</span><span class="n">sig_inside_remapped</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_mesh</span></div>
    
    
<div class="viewcode-block" id="filter_vertices_by_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_vertices_by_mesh">[docs]</a><span class="k">def</span> <span class="nf">filter_vertices_by_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">vertices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To restrict the vertices to those</span>
<span class="sd">    that only lie on a mesh</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#1) Build a KDTree of the mesh</span>
    <span class="n">curr_mesh_tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    
    <span class="c1">#2) Query the vertices against the mesh</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">curr_mesh_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">match_verts</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">dist</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">match_verts</span></div>
    


<div class="viewcode-block" id="fill_holes_trimesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.fill_holes_trimesh">[docs]</a><span class="k">def</span> <span class="nf">fill_holes_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">mesh_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">trimesh</span><span class="o">.</span><span class="n">repair</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh_copy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh_copy</span></div>


<div class="viewcode-block" id="mesh_volume_convex_hull"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_volume_convex_hull">[docs]</a><span class="k">def</span> <span class="nf">mesh_volume_convex_hull</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">volume</span></div>

<div class="viewcode-block" id="mesh_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_volume">[docs]</a><span class="k">def</span> <span class="nf">mesh_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
    <span class="c1">#watertight_method=&quot;trimesh&quot;,</span>
    <span class="n">watertight_method</span><span class="o">=</span><span class="s2">&quot;fill_mesh_holes_with_fan&quot;</span><span class="p">,</span><span class="c1">#&quot;convex_hull&quot;,</span>
    <span class="n">return_closed_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">zero_out_not_closed_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">poisson_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_holes_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">convex_hole_backup</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">default_volume_for_too_small_meshes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">allow_if_no_border_verts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_volume_for_too_small_meshes</span>
    
    <span class="c1"># -------------- 1/10 Addition: just adds the quick convex hull calculation ------ #</span>
    <span class="k">if</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;fill_mesh_holes_with_fan&quot;</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">fill_mesh_holes_with_fan</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_watertight</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">allow_if_no_border_verts</span> <span class="o">=</span> <span class="n">allow_if_no_border_verts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using convex hull method as backup for fan&quot;</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">convex_hull</span>
        <span class="k">if</span> <span class="n">return_closed_mesh</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span><span class="n">mesh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">volume</span>
    
    
    <span class="k">if</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;convex_hull&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_closed_mesh</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">convex_hull</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">volume</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To try and compute the volume of spines </span>
<span class="sd">    with an optional argumet to try and close the mesh beforehand</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">watertight_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;trimesh&quot;</span><span class="p">:</span>
                <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">fill_holes_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">closed_mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Trimesh closing holes did not work so using meshlab fill holes&quot;</span><span class="p">)</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">mesh_volume</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                                                     <span class="n">watertight_method</span><span class="o">=</span><span class="s2">&quot;fill_holes&quot;</span><span class="p">,</span>
                                                     <span class="n">return_closed_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">poisson_obj</span><span class="o">=</span><span class="n">poisson_obj</span><span class="p">,</span>
                                                     <span class="n">fill_holes_obj</span><span class="o">=</span><span class="n">fill_holes_obj</span><span class="p">,</span>
                                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">poisson_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                        <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">poisson_surface_reconstruction</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using premade object for poisson&quot;</span><span class="p">)</span>
                        <span class="n">closed_mesh</span><span class="p">,</span><span class="n">output_subprocess_obj</span> <span class="o">=</span> <span class="n">poisson_obj</span><span class="p">(</span>   
                                <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                 <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                 <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
                    
            <span class="k">elif</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;fill_holes&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fill_holes_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                            <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using premade object for fill holes&quot;</span><span class="p">)</span>
                            <span class="n">closed_mesh</span><span class="p">,</span><span class="n">fillholes_file_obj</span> <span class="o">=</span> <span class="n">fill_holes_obj</span><span class="p">(</span>   
                                            <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                             <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                             <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Filling holes did not work so using poisson reconstruction&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">poisson_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                            <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">poisson_surface_reconstruction</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using premade object for poisson&quot;</span><span class="p">)</span>
                            <span class="n">closed_mesh</span><span class="p">,</span><span class="n">output_subprocess_obj</span> <span class="o">=</span> <span class="n">Poisson_obj</span><span class="p">(</span>   
                                    <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                     <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                     <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The watertight method (</span><span class="si">{</span><span class="n">watertight_method</span><span class="si">}</span><span class="s2">) is not one of implemented ones&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The watertight method </span><span class="si">{</span><span class="n">watertight_method</span><span class="si">}</span><span class="s2"> could not run so not closing mesh&quot;</span><span class="p">)</span>
            <span class="n">closed_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh closing = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">closed_mesh</span><span class="o">.</span><span class="n">is_watertight</span> <span class="ow">or</span> <span class="n">closed_mesh</span><span class="o">.</span><span class="n">volume</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zero_out_not_closed_meshes</span><span class="p">:</span>
            <span class="n">final_volume</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">convex_hole_backup</span><span class="p">:</span>
                <span class="n">final_volume</span> <span class="o">=</span> <span class="n">closed_mesh</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">volume</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh </span><span class="si">{</span><span class="n">mesh</span><span class="si">}</span><span class="s2"> was not watertight (</span><span class="si">{</span><span class="n">mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="si">}</span><span class="s2">) or volume is 0, vol = </span><span class="si">{</span><span class="n">closed_mesh</span><span class="o">.</span><span class="n">volume</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_volume</span> <span class="o">=</span> <span class="n">closed_mesh</span><span class="o">.</span><span class="n">volume</span>
    
    <span class="k">if</span> <span class="n">return_closed_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_volume</span><span class="p">,</span><span class="n">closed_mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_volume</span></div>
    

<div class="viewcode-block" id="vertex_components"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.vertex_components">[docs]</a><span class="k">def</span> <span class="nf">vertex_components</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_adjacency_graph</span><span class="p">)]</span></div>

<div class="viewcode-block" id="components_to_submeshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.components_to_submeshes">[docs]</a><span class="k">def</span> <span class="nf">components_to_submeshes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">components</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">only_watertight</span><span class="o">=</span><span class="n">only_watertight</span><span class="p">,</span> <span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    

        
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="c1">#print(f&quot;meshes = {sub_components}, with type = {type(sub_components)}&quot;)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">())</span> <span class="p">:</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;list was only one so surrounding them with list&quot;</span><span class="p">)</span>
            <span class="c1">#print(f&quot;meshes_before = {meshes}&quot;)</span>
            <span class="c1">#print(f&quot;components_before = {components}&quot;)</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshes</span><span class="p">]</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The sub_components were not an array, list or trimesh&quot;</span><span class="p">)</span>
            
    <span class="c1"># order according to number of faces in meshes (SO DOESN&#39;T ERROR ANYMORE)</span>
    <span class="n">current_array</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">]</span>
    <span class="n">ordered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">current_array</span><span class="p">))</span>
    
    
    
    <span class="n">ordered_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ordered_indices</span><span class="p">])</span>
    <span class="n">ordered_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ordered_indices</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_meshes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span> <span class="p">:</span>
            <span class="c1">#print(f&quot;ordered_meshes = {ordered_meshes}&quot;)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split is not passing back ordered faces:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; ordered_meshes = </span><span class="si">{</span><span class="n">ordered_meshes</span><span class="si">}</span><span class="s2">,  &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;components= </span><span class="si">{</span><span class="n">components</span><span class="si">}</span><span class="s2">,  &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;meshes = </span><span class="si">{</span><span class="n">meshes</span><span class="si">}</span><span class="s2">,  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;current_array=</span><span class="si">{</span><span class="n">current_array</span><span class="si">}</span><span class="s2">,  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;ordered_indices=</span><span class="si">{</span><span class="n">ordered_indices</span><span class="si">}</span><span class="s2">,  &quot;</span>
                           <span class="p">)</span>
    
    <span class="c1">#control if the meshes is iterable or not</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ordered_comp_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_components</span><span class="p">],)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="k">if</span> <span class="n">return_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered_meshes</span><span class="p">,</span><span class="n">ordered_comp_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered_meshes</span></div>


<div class="viewcode-block" id="split_by_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.split_by_vertices">[docs]</a><span class="k">def</span> <span class="nf">split_by_vertices</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">return_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_face_idx_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">conn_verts</span> <span class="o">=</span> <span class="n">vertex_components</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for vertex components = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">faces_per_component</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_faces</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_verts</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for faces_per_component = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">faces_per_component</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">faces_per_component</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtering faces_per_component = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="n">ordered_meshes</span><span class="p">,</span><span class="n">ordered_comp_indices</span> <span class="o">=</span> <span class="n">components_to_submeshes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">faces_per_component</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for components_to_submeshes = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">return_face_idx_map</span><span class="p">:</span>
        <span class="n">return_components</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ordered_comp_indices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">face_idx_map_from_face_idx_list</span><span class="p">(</span><span class="n">ordered_comp_indices</span><span class="p">,</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,)</span>
        
    <span class="c1">#print(f&quot;inside vertices split, ordered_comp_indices = {ordered_comp_indices[0].dtype}&quot;)</span>
    
    <span class="k">if</span> <span class="n">return_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered_meshes</span><span class="p">,</span><span class="n">ordered_comp_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ordered_meshes</span></div>
    
    
<div class="viewcode-block" id="mesh_face_graph_by_vertex"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_face_graph_by_vertex">[docs]</a><span class="k">def</span> <span class="nf">mesh_face_graph_by_vertex</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a connectivity graph based on the faces that touch the same vertex have a connection edge</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">faces_adj_by_vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_faces</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces_adj_by_vertex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces_adj_by_vertex</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">unique_edges</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="find_closest_coordinate_to_mesh_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_closest_coordinate_to_mesh_faces">[docs]</a><span class="k">def</span> <span class="nf">find_closest_coordinate_to_mesh_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinates</span><span class="p">,</span><span class="n">return_closest_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of coordinates will find the closest</span>
<span class="sd">    face on a mesh</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1">#2) get the closest point from the nodes to face centers of mesh</span>
    <span class="n">mesh_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_faces</span> <span class="o">=</span> <span class="n">mesh_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    
    <span class="c1">#3) Get the lowest distance</span>
    <span class="n">closest_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closest_distance = </span><span class="si">{</span><span class="n">min_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_closest_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_index</span><span class="p">,</span><span class="n">min_distance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_index</span></div>
    
<span class="n">closest_coordinate_to_mesh_faces</span> <span class="o">=</span> <span class="n">find_closest_coordinate_to_mesh_faces</span>

<div class="viewcode-block" id="find_closest_face_to_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_closest_face_to_coordinates">[docs]</a><span class="k">def</span> <span class="nf">find_closest_face_to_coordinates</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinates</span><span class="p">,</span><span class="n">return_closest_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of coordinates will find the closest</span>
<span class="sd">    face on a mesh</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1">#2) get the closest point from the nodes to face centers of mesh</span>
    <span class="n">mesh_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_faces</span> <span class="o">=</span> <span class="n">mesh_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    
    <span class="c1">#3) Get the lowest distance</span>
    <span class="n">closest_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>
    <span class="n">closest_index</span> <span class="o">=</span> <span class="n">closest_faces</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closest_distance = </span><span class="si">{</span><span class="n">min_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_closest_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_index</span><span class="p">,</span><span class="n">min_distance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_index</span></div>
    
<span class="n">closest_face_to_coordinates</span> <span class="o">=</span> <span class="n">find_closest_face_to_coordinates</span>

<div class="viewcode-block" id="closest_mesh_coordinate_to_other_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_coordinate_to_other_mesh">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_coordinate_to_other_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">other_mesh</span><span class="p">,</span>
    <span class="n">coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
    <span class="n">return_closest_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the mesh coordinate to coordinates</span>
<span class="sd">    from aother mehs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;face&quot;</span> <span class="ow">in</span> <span class="n">coordinate_type</span><span class="p">:</span>
        <span class="n">coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;triangles_center&quot;</span>
        
    <span class="n">mesh_coordinates</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate_type</span><span class="p">)</span>
    <span class="n">other_mesh_coordinates</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other_mesh</span><span class="p">,</span><span class="n">coordinate_type</span><span class="p">)</span>
    
    <span class="n">mesh_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">other_mesh_coordinates</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">mesh_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh_coordinates</span><span class="p">)</span>
    
    <span class="n">closest_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">closest_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>
    <span class="n">closest_coord</span> <span class="o">=</span> <span class="n">mesh_coordinates</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closesst coordinate was </span><span class="si">{</span><span class="n">closest_coord</span><span class="si">}</span><span class="s2"> (dist = </span><span class="si">{</span><span class="n">closest_dist</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="p">,</span><span class="n">other_mesh</span><span class="p">],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">],</span>
            <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">closest_coord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_closest_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_coord</span><span class="p">,</span><span class="n">closest_dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_coord</span></div>
    
<div class="viewcode-block" id="closest_mesh_vertex_to_other_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_vertex_to_other_mesh">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_vertex_to_other_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">other_mesh</span><span class="p">,</span>
    <span class="n">return_closest_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">closest_mesh_coordinate_to_other_mesh</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">other_mesh</span><span class="p">,</span>
        <span class="n">coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
        <span class="n">return_closest_distance</span> <span class="o">=</span> <span class="n">return_closest_distance</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,)</span></div>
    
    
<div class="viewcode-block" id="closest_face_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_face_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_face_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">,</span><span class="n">return_face_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To find the closest face midpoint to a coordiante</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">closest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span> <span class="o">-</span> <span class="n">coordinate</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_face_coordinate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_idx</span></div>
    
<div class="viewcode-block" id="farthest_face_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.farthest_face_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">farthest_face_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">,</span><span class="n">return_face_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To find the closest face midpoint to a coordiante</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">closest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span> <span class="o">-</span> <span class="n">coordinate</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_face_coordinate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_idx</span></div>
    
<div class="viewcode-block" id="closest_face_to_coordinate_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_face_to_coordinate_distance">[docs]</a><span class="k">def</span> <span class="nf">closest_face_to_coordinate_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
    <span class="n">tu</span><span class="o">.</span><span class="n">closest_face_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">,</span><span class="n">return_face_coordinate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-</span> 
        <span class="n">coordinate</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="farthest_face_to_coordinate_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.farthest_face_to_coordinate_distance">[docs]</a><span class="k">def</span> <span class="nf">farthest_face_to_coordinate_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
    <span class="n">tu</span><span class="o">.</span><span class="n">farthest_face_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">,</span><span class="n">return_face_coordinate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-</span> 
        <span class="n">coordinate</span>
    <span class="p">)</span></div>
    
    
<div class="viewcode-block" id="face_neighbors_by_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.face_neighbors_by_vertices">[docs]</a><span class="k">def</span> <span class="nf">face_neighbors_by_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">faces_list</span><span class="p">,</span>
                              <span class="n">concatenate_unique_list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the neighbors of face where neighbors are</span>
<span class="sd">    faces that touch the same vertices</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Change the faces to vertices</span>
<span class="sd">    2) Find all the faces associated with the vertices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">concatenate_unique_list</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vertices_to_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">faces_list</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">concatenate_unique_list</span><span class="o">=</span><span class="n">concatenate_unique_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">vertices_to_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">concatenate_unique_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">faces_list</span><span class="p">]</span></div>
    
    
<div class="viewcode-block" id="face_neighbors_by_vertices_seperate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.face_neighbors_by_vertices_seperate">[docs]</a><span class="k">def</span> <span class="nf">face_neighbors_by_vertices_seperate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">faces_list</span><span class="p">):</span>
    <span class="n">f_verts</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">faces_list</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_faces</span><span class="p">[</span><span class="n">f_verts</span><span class="p">]]</span></div>

<div class="viewcode-block" id="skeleton_to_mesh_correspondence"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.skeleton_to_mesh_correspondence">[docs]</a><span class="k">def</span> <span class="nf">skeleton_to_mesh_correspondence</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">skeletons</span><span class="p">,</span>
                                    <span class="n">remove_inside_pieces_threshold</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                    <span class="n">return_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the first pass mesh </span>
<span class="sd">    correspondence of a skeleton or list of skeletons</span>
<span class="sd">    in reference to a mesh</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) If requested, remove the interior of the mesh (if this is set then can&#39;t return indices)</span>
<span class="sd">    - if return indices is set then error if interior also set</span>
<span class="sd">    2) for each skeleton:</span>
<span class="sd">        a. Run the mesh correspondence adaptive function</span>
<span class="sd">        b. check to see if got any output (if did not then return empty list or empty mesh)</span>
<span class="sd">        c. If did add a submesh or indices to the return list</span>


<span class="sd">    Example:</span>
<span class="sd">    return_value = tu.skeleton_to_mesh_correspondence( mesh = debug_mesh,</span>
<span class="sd">                                                skeletons = viable_end_node_skeletons</span>
<span class="sd">                                   )</span>

<span class="sd">    ipvu.plot_objects(meshes=return_value,</span>
<span class="sd">                      meshes_colors=&quot;random&quot;,</span>
<span class="sd">                      skeletons=viable_end_node_skeletons,</span>
<span class="sd">                     skeletons_colors=&quot;random&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">skeletons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeletons</span><span class="p">]</span>

    <span class="n">return_indices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">remove_inside_pieces_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_limb_mesh_indices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                 <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="n">remove_inside_pieces_threshold</span><span class="p">,</span>
                                                 <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="p">)</span>
        <span class="n">curr_limb_mesh_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_limb_mesh_indices</span><span class="p">)</span>
        <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">curr_limb_mesh_indices</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_mesh_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">mesh</span>


    <span class="c1">#1) Run the first pass mesh correspondence</span>
    <span class="k">for</span> <span class="n">curr_sk</span> <span class="ow">in</span> <span class="n">skeletons</span><span class="p">:</span>
        <span class="n">returned_data</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">curr_sk</span><span class="p">,</span>
                                  <span class="n">curr_mesh</span><span class="p">,</span>
                                 <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                 <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                                                            <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">returned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">return_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">curr_branch_face_correspondence</span><span class="p">,</span> <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">returned_data</span>
            <span class="n">return_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_mesh_indices</span><span class="p">[</span><span class="n">curr_branch_face_correspondence</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">ind</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                                                   <span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">return_indices</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_meshes</span><span class="p">:</span>
            <span class="n">ret_val_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret_val_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_value</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returned value sizes = </span><span class="si">{</span><span class="n">ret_val_sizes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="mesh_segmentation_from_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_segmentation_from_skeleton">[docs]</a><span class="k">def</span> <span class="nf">mesh_segmentation_from_skeleton</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">initial_distance_threshold</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">skeletal_buffer</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">backup_distance_threshold</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="n">backup_skeletal_buffer</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
    <span class="n">plot_correspondence_first_pass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To turn a skeleton into a mesh</span>
<span class="sd">    correspondence dictionary</span>
<span class="sd">    </span>
<span class="sd">    1) Divide up skeleton</span>
<span class="sd">    2) Find mesh that corresponds to branches</span>
<span class="sd">    3) Refines the correspondence so only 1 skeletal</span>
<span class="sd">    branch matched to each face</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">preprocessing_vp2</span> <span class="k">as</span> <span class="n">pre</span>

    <span class="n">local_correspondence</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">mesh_correspondence_first_pass</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="n">skeleton_segment_width</span><span class="p">,</span>
        <span class="n">initial_distance_threshold</span> <span class="o">=</span> <span class="n">initial_distance_threshold</span><span class="p">,</span>
        <span class="n">skeletal_buffer</span> <span class="o">=</span> <span class="n">skeletal_buffer</span><span class="p">,</span>
        <span class="n">backup_distance_threshold</span> <span class="o">=</span> <span class="n">backup_distance_threshold</span><span class="p">,</span>
        <span class="n">backup_skeletal_buffer</span> <span class="o">=</span> <span class="n">backup_skeletal_buffer</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_correspondence_first_pass</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">refined_correspondence</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">correspondence_1_to_1</span><span class="p">(</span>
        <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondence</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">refined_correspondence</span></div>

<div class="viewcode-block" id="skeleton_and_mesh_segmentation"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.skeleton_and_mesh_segmentation">[docs]</a><span class="k">def</span> <span class="nf">skeleton_and_mesh_segmentation</span><span class="p">(</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">segmentation_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    tu.skeleton_and_mesh_segmentation(</span>
<span class="sd">        filepath = &quot;./elephant.off&quot;,</span>
<span class="sd">        plot_segmentation = True,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">skeleton_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">segmentation_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segmentation_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">skeleton_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_function</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_cgal_original_parameters</span>
    
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        
    
    <span class="n">skeleton</span> <span class="o">=</span> <span class="n">skeleton_function</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">remove_skeleton_temp_file</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_skeleton</span><span class="p">,</span>
        <span class="o">**</span><span class="n">skeleton_kwargs</span>
    <span class="p">)</span>
    
    <span class="n">correspond</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation_from_skeleton</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_segmentation</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_kwargs</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">correspond</span></div>
<span class="w">    </span>


<span class="sd">&#39;&#39;&#39;def find_large_dense_submesh(mesh,</span>
<span class="sd">                             glia_pieces=None, #the glia pieces we already want removed</span>
<span class="sd">                            verbose = True,</span>
<span class="sd">                            large_dense_size_threshold = 600000,</span>
<span class="sd">                            large_mesh_cancellation_distance = 3000,</span>
<span class="sd">                            filter_away_floating_pieces = True,</span>
<span class="sd">                            bbox_filter_away_ratio = 1.7,</span>
<span class="sd">                            connectivity=&quot;vertices&quot;,</span>
<span class="sd">                            floating_piece_size_threshold = 130000,</span>
<span class="sd">                            remove_large_dense_submesh=True):</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: Getting all of the points close to glia and removing them</span>

<span class="sd">    1) Get the inner glia mesh</span>
<span class="sd">    2) Build a KDTree fo the inner glia</span>
<span class="sd">    3) Query the faces of the remainingn mesh</span>
<span class="sd">    4) Get all the faces beyond a certain distance and get the submesh</span>
<span class="sd">    5) Filter away all floating pieces in a certain region of the bounding box</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    current_neuron_mesh = mesh</span>

<span class="sd">    #1) Get the inner glia mesh</span>

<span class="sd">    all_large_dense_pieces = []</span>

<span class="sd">    if glia_pieces is None:</span>
<span class="sd">        mesh_removed_glia,inside_pieces = tu.remove_mesh_interior(current_neuron_mesh,</span>
<span class="sd">                               size_threshold_to_remove=large_dense_size_threshold,</span>
<span class="sd">                                connectivity=connectivity,</span>
<span class="sd">                                try_hole_close=False,</span>
<span class="sd">                                return_removed_pieces =True,</span>
<span class="sd">                                 **kwargs</span>
<span class="sd">                               )</span>
<span class="sd">    else:</span>
<span class="sd">        print(&quot;using precomputed glia pieces&quot;)</span>
<span class="sd">        inside_pieces = list(glia_pieces)</span>
<span class="sd">        mesh_removed_glia = tu.subtract_mesh(mesh,inside_pieces,</span>
<span class="sd">                                            exact_match=False)</span>

<span class="sd">    all_large_dense_pieces+= inside_pieces</span>


<span class="sd">    for j,inside_glia in enumerate(inside_pieces):</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;\n ---- Working on inside piece {j} ------&quot;)</span>

<span class="sd">        #2) Build a KDTree fo the inner glia</span>
<span class="sd">        glia_kd = KDTree(inside_glia.triangles_center.reshape(-1,3))</span>


<span class="sd">        #3) Query the faces of the remainingn mesh</span>
<span class="sd">        dist, _ = glia_kd.query(mesh_removed_glia.triangles_center)</span>

<span class="sd">        #4) Get all the faces beyond a certain distance and get the submesh</span>
<span class="sd">        within_threshold_faces = np.where(dist&gt;= large_mesh_cancellation_distance)[0]</span>
<span class="sd">        removed_threshold_faces = np.where(dist&lt; large_mesh_cancellation_distance)[0]</span>


<span class="sd">        if len(within_threshold_faces)&gt;0:</span>
<span class="sd">            #gathering pieces to return that were removed</span>
<span class="sd">            close_pieces_removed = mesh_removed_glia.submesh([removed_threshold_faces],append=True,repair=False)</span>
<span class="sd">            all_large_dense_pieces.append(close_pieces_removed)</span>
<span class="sd">            </span>
<span class="sd">            mesh_removed_glia = mesh_removed_glia.submesh([within_threshold_faces],append=True,repair=False)</span>


<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;For glia mesh {j} there were {len(within_threshold_faces)} faces within {large_mesh_cancellation_distance} distane&quot;)</span>
<span class="sd">                print(f&quot;New mesh size is {mesh_removed_glia}&quot;)</span>


<span class="sd">            if filter_away_floating_pieces:</span>
<span class="sd">                floating_sig_pieces, floating_insig_pieces = tu.split_significant_pieces(mesh_removed_glia,</span>
<span class="sd">                                                                  significance_threshold = floating_piece_size_threshold,</span>
<span class="sd">                                                                  return_insignificant_pieces=True,</span>
<span class="sd">                                                                  connectivity=connectivity)</span>

<span class="sd">                if len(floating_insig_pieces)&gt;0:</span>
<span class="sd">                    #get the </span>
<span class="sd">                    floating_pieces_to_remove = tu.check_meshes_inside_mesh_bbox(inside_glia,floating_insig_pieces,bbox_multiply_ratio=bbox_filter_away_ratio)</span>

<span class="sd">                    if verbose:</span>
<span class="sd">                        print(f&quot;Found {len(floating_insig_pieces)} and going to remove {len(floating_pieces_to_remove)} that were inside bounding box&quot;)</span>

<span class="sd">                    if len(floating_pieces_to_remove)&gt;0:</span>

<span class="sd">                        mesh_removed_glia = tu.subtract_mesh(mesh_removed_glia,floating_pieces_to_remove,</span>
<span class="sd">                                                            exact_match=False)</span>

<span class="sd">                        all_large_dense_pieces += floating_pieces_to_remove</span>

<span class="sd">                        if verbose:</span>
<span class="sd">                            print(f&quot;After removal of floating pieces the mesh is {mesh_removed_glia}&quot;)</span>
<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            To help visualize the floating pieces that were removed</span>

<span class="sd">            ipvu.plot_objects(mesh_removed_glia,</span>
<span class="sd">                          meshes=floating_insig_pieces,</span>
<span class="sd">                         meshes_colors=&quot;red&quot;)</span>

<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            </span>
<span class="sd">    #compiling the large dense submesh</span>
<span class="sd">    if len(all_large_dense_pieces) &gt; 0:</span>
<span class="sd">        total_dense_submesh = tu.combine_meshes(all_large_dense_pieces)</span>
<span class="sd">    else:</span>
<span class="sd">        if verbose: </span>
<span class="sd">            print(&quot;There was no large dense submesh&quot;)</span>
<span class="sd">        total_dense_submesh = trimesh.Trimesh(vertices = np.array([]),</span>
<span class="sd">                                             faces=np.array([]))</span>

<span class="sd">    if remove_large_dense_submesh:</span>
<span class="sd">        return mesh_removed_glia,total_dense_submesh</span>
<span class="sd">    else:</span>
<span class="sd">        return total_dense_submesh</span>
<span class="sd">    &#39;&#39;&#39;</span>
    

<div class="viewcode-block" id="find_large_dense_submesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.find_large_dense_submesh">[docs]</a><span class="k">def</span> <span class="nf">find_large_dense_submesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">glia_pieces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#the glia pieces we already want removed</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">large_dense_size_threshold</span> <span class="o">=</span> <span class="mi">400000</span><span class="p">,</span>
                            <span class="n">large_mesh_cancellation_distance</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
                            <span class="n">filter_away_floating_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">bbox_filter_away_ratio</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">,</span>
                            <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                            <span class="n">floating_piece_size_threshold</span> <span class="o">=</span> <span class="mi">130000</span><span class="p">,</span>
                            <span class="n">remove_large_dense_submesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Getting all of the points close to glia and removing them</span>

<span class="sd">    1) Get the inner glia mesh</span>
<span class="sd">    2) Build a KDTree fo the inner glia</span>
<span class="sd">    3) Query the faces of the remainingn mesh</span>
<span class="sd">    4) Get all the faces beyond a certain distance and get the submesh</span>
<span class="sd">    5) Filter away all floating pieces in a certain region of the bounding box</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_neuron_mesh</span> <span class="o">=</span> <span class="n">mesh</span>

    <span class="c1">#1) Get the inner glia mesh</span>

    <span class="n">all_large_dense_pieces</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">glia_pieces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_removed_glia</span><span class="p">,</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">current_neuron_mesh</span><span class="p">,</span>
                               <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="n">large_dense_size_threshold</span><span class="p">,</span>
                                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                                <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">return_removed_pieces</span> <span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span>
                               <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;using precomputed glia pieces&quot;</span><span class="p">)</span>
        <span class="n">inside_pieces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span>
        <span class="n">mesh_removed_glia</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">inside_pieces</span><span class="p">,</span>
                                            <span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">all_large_dense_pieces</span><span class="o">+=</span> <span class="n">inside_pieces</span>

    
    
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">inside_glia</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inside_pieces</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> ---- Working on inside piece </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> ------&quot;</span><span class="p">)</span>

        <span class="c1">#2) Build a KDTree fo the inner glia</span>
        <span class="n">glia_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">inside_glia</span><span class="o">.</span><span class="n">triangles_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>


        <span class="c1">#3) Query the faces of the remainingn mesh</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">glia_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh_removed_glia</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>

        <span class="c1">#4) Get all the faces beyond a certain distance and get the submesh</span>
        <span class="n">within_threshold_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span><span class="o">&gt;=</span> <span class="n">large_mesh_cancellation_distance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">removed_threshold_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span><span class="o">&lt;</span> <span class="n">large_mesh_cancellation_distance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">within_threshold_faces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#gathering pieces to return that were removed</span>
            <span class="n">close_pieces_removed</span> <span class="o">=</span> <span class="n">mesh_removed_glia</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">removed_threshold_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">all_large_dense_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pieces_removed</span><span class="p">)</span>
            
            <span class="n">mesh_removed_glia</span> <span class="o">=</span> <span class="n">mesh_removed_glia</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">within_threshold_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For glia mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> there were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">within_threshold_faces</span><span class="p">)</span><span class="si">}</span><span class="s2"> faces within </span><span class="si">{</span><span class="n">large_mesh_cancellation_distance</span><span class="si">}</span><span class="s2"> distane&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New mesh size is </span><span class="si">{</span><span class="n">mesh_removed_glia</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                
                
                
                
    <span class="k">if</span> <span class="n">filter_away_floating_pieces</span><span class="p">:</span>
        
        <span class="n">floating_sig_pieces</span><span class="p">,</span> <span class="n">floating_insig_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">mesh_removed_glia</span><span class="p">,</span>
                                                              <span class="n">significance_threshold</span> <span class="o">=</span> <span class="n">floating_piece_size_threshold</span><span class="p">,</span>
                                                              <span class="n">return_insignificant_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">inside_glia</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inside_pieces</span><span class="p">):</span>
    
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">floating_insig_pieces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                
                <span class="n">floating_pieces_to_remove</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">check_meshes_inside_mesh_bbox</span><span class="p">(</span><span class="n">inside_glia</span><span class="p">,</span><span class="n">floating_insig_pieces</span><span class="p">,</span><span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="n">bbox_filter_away_ratio</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">floating_insig_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2"> and going to remove </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">floating_pieces_to_remove</span><span class="p">)</span><span class="si">}</span><span class="s2"> that were inside bounding box&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">floating_pieces_to_remove</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

                    <span class="n">mesh_removed_glia</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">mesh_removed_glia</span><span class="p">,</span><span class="n">floating_pieces_to_remove</span><span class="p">,</span>
                                                        <span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="n">all_large_dense_pieces</span> <span class="o">+=</span> <span class="n">floating_pieces_to_remove</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After removal of floating pieces the mesh is </span><span class="si">{</span><span class="n">mesh_removed_glia</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            To help visualize the floating pieces that were removed</span>

<span class="sd">            ipvu.plot_objects(mesh_removed_glia,</span>
<span class="sd">                          meshes=floating_insig_pieces,</span>
<span class="sd">                         meshes_colors=&quot;red&quot;)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
    <span class="c1">#compiling the large dense submesh</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_large_dense_pieces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_dense_submesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">all_large_dense_pieces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There was no large dense submesh&quot;</span><span class="p">)</span>
        <span class="n">total_dense_submesh</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">remove_large_dense_submesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_removed_glia</span><span class="p">,</span><span class="n">total_dense_submesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_dense_submesh</span></div>
    
    
    
<div class="viewcode-block" id="empty_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.empty_mesh">[docs]</a><span class="k">def</span> <span class="nf">empty_mesh</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                          <span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span></div>
    
    
        
<div class="viewcode-block" id="percentage_vertices_inside"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.percentage_vertices_inside">[docs]</a><span class="k">def</span> <span class="nf">percentage_vertices_inside</span><span class="p">(</span>
                                <span class="n">main_mesh</span><span class="p">,</span>
                                <span class="n">test_mesh</span><span class="p">,</span>
                                <span class="n">n_sample_points</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                <span class="n">use_convex_hull</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Function that will determine the percentage of vertices</span>
<span class="sd">    of one mesh being inside of another</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    tu.percentage_vertices_inside(</span>
<span class="sd">                    main_mesh = soma_meshes[3],</span>
<span class="sd">                    test_mesh = soma_meshes[1],</span>
<span class="sd">                    n_sample_points = 1000,</span>
<span class="sd">                    use_convex_hull = True,</span>
<span class="sd">                    verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">use_convex_hull</span><span class="p">:</span>
        <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">convex_hull</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">test_mesh</span>

    <span class="k">if</span> <span class="n">n_sample_points</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
        <span class="n">n_sample_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="c1">#gets the number of samples on the mesh to test (only the indexes)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span><span class="n">n_sample_points</span> <span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#gets the sample&#39;s vertices</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span>

    <span class="c1">#find the signed distance from the sampled vertices to the main mesh</span>
    <span class="c1"># Points outside the mesh will be negative</span>
    <span class="c1"># Points inside the mesh will be positive</span>
    <span class="n">signed_distance</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">proximity</span><span class="o">.</span><span class="n">signed_distance</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">points</span><span class="p">)</span>

    <span class="c1">#gets the </span>
    <span class="n">inside_percentage</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">signed_distance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">n_sample_points</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inside Percentage = </span><span class="si">{</span><span class="n">inside_percentage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">inside_percentage</span></div>


<div class="viewcode-block" id="test_inside_meshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.test_inside_meshes">[docs]</a><span class="k">def</span> <span class="nf">test_inside_meshes</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span>
                        <span class="n">test_meshes</span><span class="p">,</span>
                        <span class="n">n_sample_points</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                        <span class="n">use_convex_hull</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">inside_percentage_threshold</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
                        <span class="n">return_outside</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_meshes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To determine which of the test meshes</span>
<span class="sd">    are inside the main mesh</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    tu.test_inside_meshes(</span>
<span class="sd">                    main_mesh = soma_meshes[3],</span>
<span class="sd">                    test_meshes = soma_meshes[1],</span>
<span class="sd">                    n_sample_points = 1000,</span>
<span class="sd">                    use_convex_hull = True,</span>
<span class="sd">                    inside_percentage_threshold=0.9,</span>
<span class="sd">                    verbose = True)</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">):</span>
        <span class="n">test_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">test_meshes</span><span class="p">]</span>
    
    <span class="n">test_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">)</span>
    <span class="n">inside_indices</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">):</span>
        <span class="n">perc_inside</span> <span class="o">=</span> <span class="n">percentage_vertices_inside</span><span class="p">(</span>
                                <span class="n">main_mesh</span><span class="p">,</span>
                                <span class="n">t_mesh</span><span class="p">,</span>
                                <span class="n">n_sample_points</span> <span class="o">=</span> <span class="n">n_sample_points</span><span class="p">,</span>
                                <span class="n">use_convex_hull</span> <span class="o">=</span> <span class="n">use_convex_hull</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">perc_inside</span> <span class="o">&gt;</span> <span class="n">inside_percentage_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> was inside because inside percentage was </span><span class="si">{</span><span class="n">perc_inside</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">inside_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> was OUTSIDE because inside percentage was </span><span class="si">{</span><span class="n">perc_inside</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">inside_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inside_indices</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_outside</span><span class="p">:</span>
        <span class="n">return_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_meshes</span><span class="p">)),</span><span class="n">inside_indices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_indices</span> <span class="o">=</span> <span class="n">inside_indices</span>
    
    
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">test_meshes</span><span class="p">[</span><span class="n">return_indices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_indices</span></div>
        
        
<div class="viewcode-block" id="meshes_distance_matrix"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.meshes_distance_matrix">[docs]</a><span class="k">def</span> <span class="nf">meshes_distance_matrix</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                                <span class="n">distance_type</span><span class="o">=</span><span class="s2">&quot;shortest_vertex_distance&quot;</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the pairwise distance between meshes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using distance_type = </span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s2">&quot;shortest_vertex_distance&quot;</span><span class="p">:</span>
       
        <span class="n">dist_matrix_adj</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">m1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
            
            <span class="n">local_distance</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">m1_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">m2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
                
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">local_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                    <span class="k">continue</span>
                    
                <span class="n">dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">m1_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">m2</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">local_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
                
            <span class="n">dist_matrix_adj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_distance</span><span class="p">)</span>
            
        <span class="n">dist_matrix_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_matrix_adj</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s2">&quot;mesh_center&quot;</span><span class="p">:</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">get_coordinate_distance_matrix</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_list</span><span class="p">])</span>
        <span class="n">dist_matrix_adj</span> <span class="o">=</span> <span class="n">dist_matrix</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">))</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unimplemented distance_type&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dist_matrix_adj</span></div>
    
<div class="viewcode-block" id="meshes_within_close_proximity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.meshes_within_close_proximity">[docs]</a><span class="k">def</span> <span class="nf">meshes_within_close_proximity</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                                <span class="n">distance_type</span><span class="o">=</span><span class="s2">&quot;shortest_vertex_distance&quot;</span><span class="p">,</span>
                                  <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span>
                                  <span class="n">return_distances</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Get the meshes that are within close proximity of each other</span>
<span class="sd">    as defined by mesh centers or the absolute shortest vertex distance</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],[]</span>
    
    <span class="n">dist_matrix_adj</span> <span class="o">=</span> <span class="n">meshes_distance_matrix</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                                <span class="n">distance_type</span><span class="o">=</span><span class="n">distance_type</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dist_matrix_adj = </span><span class="si">{</span><span class="n">dist_matrix_adj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">soma_pairings_to_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">unique_non_self_pairings</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist_matrix_adj</span><span class="o">&lt;=</span><span class="n">distance_threshold</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_pairings_to_check</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">soma_pairings_to_check</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">distances_per_pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist_matrix_adj</span><span class="p">[</span><span class="n">k1</span><span class="p">][</span><span class="n">k2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span><span class="n">k2</span> <span class="ow">in</span> <span class="n">soma_pairings_to_check</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances_per_pair</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">return_distances</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">soma_pairings_to_check</span><span class="p">,</span><span class="n">distances_per_pair</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">soma_pairings_to_check</span></div>
    
    
    
<div class="viewcode-block" id="filter_away_inside_meshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_away_inside_meshes">[docs]</a><span class="k">def</span> <span class="nf">filter_away_inside_meshes</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                                <span class="n">distance_type</span><span class="o">=</span><span class="s2">&quot;shortest_vertex_distance&quot;</span><span class="p">,</span>
                                <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                                <span class="n">inside_percentage_threshold</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">max_mesh_sized_filtered_away</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter out any meshes</span>
<span class="sd">    that are inside of another mesh in the list</span>

<span class="sd">    1) Get all the pairings of meshes to check and the distances between</span>
<span class="sd">    2) Find the order of pairs to check 1st by distance</span>
<span class="sd">    3) Create a viable meshes index list with initially all indexes present</span>

<span class="sd">    For each pair (in the order pre-determined in 2)</span>
<span class="sd">    a) If both indexes are not in the viable meshes list --&gt; continue</span>
<span class="sd">    b) check the percentage that each is inside of the other</span>
<span class="sd">    c) Get the ones that are above a threshold</span>
<span class="sd">    d1) If none are above threshold then continue</span>
<span class="sd">    d2) If one is above threshold then that is the losing index</span>
<span class="sd">    d3) If both are above the threshold then pick the smallest one as the losing index</span>
<span class="sd">    e) remove the losing index from the viable meshes index list</span>

<span class="sd">    4) Return either the viables meshes indexes or the meshes themselves</span>


<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh list was less than 2 object so returning&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">))</span>
    
    <span class="c1"># May want to put a size threshold on what we filter away</span>
    <span class="n">mesh_list_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_list</span><span class="p">])</span>
    <span class="n">must_keep_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mesh_list_len</span><span class="o">&gt;</span><span class="n">max_mesh_sized_filtered_away</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;must_keep_indexes = </span><span class="si">{</span><span class="n">must_keep_indexes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">must_keep_indexes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All meshes were above the max_mesh_sized_filtered_away threshold: </span><span class="si">{</span><span class="n">max_mesh_sized_filtered_away</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">))</span>   
            

    <span class="n">mesh_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span>

    <span class="c1">#1) Get all the pairings of meshes to check and the distances between</span>
    <span class="n">return_pairings</span><span class="p">,</span><span class="n">pair_distances</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">meshes_within_close_proximity</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                                    <span class="n">distance_type</span><span class="o">=</span><span class="n">distance_type</span><span class="p">,</span>
                                    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">distance_threshold</span><span class="p">,</span>
                                                      <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_pairings = </span><span class="si">{</span><span class="n">return_pairings</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pair_distances = </span><span class="si">{</span><span class="n">pair_distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#2) Find the order of pairs to check 1st by distance</span>
    <span class="n">pair_to_check_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)</span>


    <span class="c1">#3) Create a viable meshes index list with initially all indexes present</span>
    <span class="n">viable_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">))</span>

    <span class="c1">#For each pair (in the order pre-determined in 2)</span>
    <span class="k">for</span> <span class="n">pair_idx</span> <span class="ow">in</span> <span class="n">pair_to_check_order</span><span class="p">:</span>

        <span class="n">curr_pair</span> <span class="o">=</span> <span class="n">return_pairings</span><span class="p">[</span><span class="n">pair_idx</span><span class="p">]</span>
        <span class="n">mesh_1_idx</span><span class="p">,</span><span class="n">mesh_2_idx</span> <span class="o">=</span> <span class="n">curr_pair</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- working on pair: </span><span class="si">{</span><span class="n">curr_pair</span><span class="si">}</span><span class="s2"> --&quot;</span><span class="p">)</span>

        <span class="c1">#a) If both indexes are not in the viable meshes list --&gt; continue</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh_1_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">viable_meshes</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mesh_2_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">viable_meshes</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Continuing because both meshes not in viable mesh list&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1">#b) check the percentage that each is inside of the other</span>
        
        
        <span class="n">inside_percentages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">percentage_vertices_inside</span><span class="p">(</span>
                                    <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">mesh_list</span><span class="p">[</span><span class="n">curr_pair</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]],</span>
                                    <span class="n">test_mesh</span> <span class="o">=</span> <span class="n">mesh_list</span><span class="p">[</span><span class="n">curr_pair</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside_percentages = </span><span class="si">{</span><span class="n">inside_percentages</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#c) Get the ones that are above a threshold</span>
        <span class="n">above_inside_threshold_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside_percentages</span> <span class="o">&gt;</span> <span class="n">inside_percentage_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#d1) If none are above threshold then continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">above_inside_threshold_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;None above the threshold </span><span class="si">{</span><span class="n">inside_percentage_threshold</span><span class="si">}</span><span class="s2"> so continuing&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">above_inside_threshold_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">losing_index</span> <span class="o">=</span> <span class="n">curr_pair</span><span class="p">[</span><span class="n">above_inside_threshold_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only 1 above the threshold: mesh </span><span class="si">{</span><span class="n">losing_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">above_inside_threshold_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_pair</span><span class="p">])</span>
            <span class="n">losing_index</span> <span class="o">=</span> <span class="n">curr_pair</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sizes</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2 above the threshold so picking the smallest of the size </span><span class="si">{</span><span class="n">sizes</span><span class="si">}</span><span class="s2">: mesh </span><span class="si">{</span><span class="n">losing_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;More than 2 above threshold&quot;</span><span class="p">)</span>

        <span class="c1">#e) remove the losing index from the viable meshes index list</span>
        <span class="n">viable_meshes</span> <span class="o">=</span> <span class="n">viable_meshes</span><span class="p">[</span><span class="n">viable_meshes</span><span class="o">!=</span><span class="n">losing_index</span><span class="p">]</span>

    <span class="c1"># making sure to add back in the meshes that shouldn&#39;t be filtered away</span>
    <span class="n">viable_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">viable_meshes</span><span class="p">,</span><span class="n">must_keep_indexes</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">viable_meshes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">viable_meshes</span></div>

    
<div class="viewcode-block" id="is_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.is_mesh">[docs]</a><span class="k">def</span> <span class="nf">is_mesh</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="turn_off_logging"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.turn_off_logging">[docs]</a><span class="k">def</span> <span class="nf">turn_off_logging</span><span class="p">():</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;trimesh&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span></div>

<span class="n">turn_off_logging</span><span class="p">()</span>


<span class="c1"># -------------- 1/21 ------------- #</span>
<div class="viewcode-block" id="bounding_box_oriented_side_lengths"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box_oriented_side_lengths">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_oriented_side_lengths</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_largest_side</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">x_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">y_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">z_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">x_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">y_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">z_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_largest_side</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">x_length</span><span class="p">,</span><span class="n">y_length</span><span class="p">,</span><span class="n">z_length</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_length</span><span class="p">,</span><span class="n">y_length</span><span class="p">,</span><span class="n">z_length</span></div>
    
<div class="viewcode-block" id="bounding_box_longest_side"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bounding_box_longest_side">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_longest_side</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bounding_box_oriented_side_lengths</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_largest_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_meshes_by_bounding_box_longest_side"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_meshes_by_bounding_box_longest_side">[docs]</a><span class="k">def</span> <span class="nf">filter_meshes_by_bounding_box_longest_side</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span>
                                              <span class="n">side_length_threshold</span><span class="p">):</span>
    <span class="n">longest_side_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_longest_side</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">])</span>
    <span class="n">keep_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">longest_side_lengths</span><span class="o">&lt;=</span><span class="n">side_length_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indexes</span><span class="p">]</span></div>

<div class="viewcode-block" id="box_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.box_mesh">[docs]</a><span class="k">def</span> <span class="nf">box_mesh</span><span class="p">(</span><span class="n">center</span><span class="p">,</span>
             <span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">box_obj</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">creation</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">extents</span><span class="o">=</span><span class="p">[</span><span class="n">radius</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">radius</span><span class="p">])</span>
    <span class="n">box_obj</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">box_obj</span><span class="o">.</span><span class="n">vertices</span> <span class="o">+</span> <span class="n">center</span>
    <span class="k">return</span> <span class="n">box_obj</span></div>

<div class="viewcode-block" id="center_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.center_mesh">[docs]</a><span class="k">def</span> <span class="nf">center_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">new_center</span><span class="p">):</span>
    <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">added_offset</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span> <span class="o">-</span> <span class="n">new_mesh</span><span class="o">.</span><span class="n">center_mass</span>
    <span class="n">new_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">new_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">+</span> <span class="n">added_offset</span>
    <span class="k">return</span> <span class="n">new_mesh</span></div>

<div class="viewcode-block" id="center_mesh_at_point"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.center_mesh_at_point">[docs]</a><span class="k">def</span> <span class="nf">center_mesh_at_point</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">new_center</span><span class="p">):</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">new_center</span>
    <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="sphere_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.sphere_mesh">[docs]</a><span class="k">def</span> <span class="nf">sphere_mesh</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">sph</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">creation</span><span class="o">.</span><span class="n">icosphere</span><span class="p">(</span><span class="n">subdivisions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">center_mesh</span><span class="p">(</span><span class="n">sph</span><span class="p">,</span><span class="n">center</span><span class="p">)</span></div>


<div class="viewcode-block" id="kdtree_length"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.kdtree_length">[docs]</a><span class="k">def</span> <span class="nf">kdtree_length</span><span class="p">(</span><span class="n">kdtree_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdtree_obj</span><span class="o">.</span><span class="n">data_pts</span><span class="p">)</span></div>

<div class="viewcode-block" id="largest_border_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.largest_border_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">largest_border_to_coordinate</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">plot_border_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">error_on_no_border</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_winning_border</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the biggest border within a certain radius</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all of the vertex border groups</span>
<span class="sd">    2) Find the average vertex of these groups</span>
<span class="sd">    3) Find the distance of these groups from the coordinate</span>
<span class="sd">    4) Filter for those within a certain radius</span>
<span class="sd">    5) Return the border group that is the largest</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) Find all of the vertex border groups</span>
    <span class="n">border_vertex_groups</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertex_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                       <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_vertex_groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">error_on_no_border</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No borders detected&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No borders detected&quot;</span><span class="p">)</span>
        <span class="n">winning_border</span> <span class="o">=</span>  <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of border_vertex_groups = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">border_vertex_groups</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_border_vertices</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_vertex_groups</span><span class="p">],</span>
                             <span class="n">scatters_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

        <span class="c1">#2) Find the average vertex of these groups</span>
        <span class="n">border_vertex_averages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">border_vertex_groups</span><span class="p">])</span>


        <span class="c1">#3) Find the distance of these groups from the coordinate</span>
        <span class="n">border_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">border_vertex_averages</span> <span class="o">-</span> <span class="n">coordinate</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#4) Filter for those within a certain radius</span>
        <span class="n">viable_borders_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">border_distances</span><span class="o">&lt;</span><span class="n">distance_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_borders_idx</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">viable_borders</span> <span class="o">=</span> <span class="p">[</span><span class="n">border_vertex_groups</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">viable_borders_idx</span><span class="p">]</span>
            <span class="n">viable_borders_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">viable_borders</span><span class="p">])</span>
            <span class="n">winning_border_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">viable_borders_len</span><span class="p">)</span>
            <span class="n">winning_border</span> <span class="o">=</span> <span class="n">viable_borders</span><span class="p">[</span><span class="n">winning_border_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No borders within the threshold of distance_threshold so returning just the closest border&quot;</span><span class="p">)</span>
            <span class="n">winning_border</span> <span class="o">=</span> <span class="n">border_vertex_groups</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">border_distances</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">plot_winning_border</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">winning_border</span><span class="p">,</span><span class="n">coordinate</span><span class="p">],</span>
                             <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">],</span>
                             <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">winning_border</span></div>

<div class="viewcode-block" id="closest_mesh_to_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_to_coordinates">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_to_coordinates</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span><span class="n">coordinates</span><span class="p">,</span>
                               <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">distance_method</span> <span class="o">=</span> <span class="s2">&quot;min_distance&quot;</span><span class="p">,</span> 
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,):</span>
    <span class="k">return</span> <span class="n">closest_mesh_to_coordinate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span><span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">return_mesh</span><span class="o">=</span><span class="n">return_mesh</span><span class="p">,</span>
                                  <span class="n">return_distance</span><span class="o">=</span><span class="n">return_distance</span><span class="p">,</span>
                                      <span class="n">distance_method</span><span class="o">=</span><span class="n">distance_method</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,)</span></div>

<div class="viewcode-block" id="closest_mesh_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_to_coordinate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span><span class="n">coordinate</span><span class="p">,</span>
                                  <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">distance_method</span> <span class="o">=</span> <span class="s2">&quot;min_distance&quot;</span><span class="p">,</span> 
                               <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will pick the closest mesh from a list of meshes</span>
<span class="sd">    to a certain coordinate point</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through all of the meshes</span>
<span class="sd">    1) Build KDTree of mesh</span>
<span class="sd">    2) query the coordinate against mesh</span>
<span class="sd">    3) Save the distance in array</span>

<span class="sd">    4) Find the index with the smallest distance</span>
<span class="sd">    5) Return the mesh or the index</span>
<span class="sd">    </span>
<span class="sd">    ** distance methods are:</span>
<span class="sd">    1) min_distance: will measure the distance between the closest mesh face and coordinate</span>
<span class="sd">    2) bbox_center: measure the bounding box center of the mesh to the coordinate</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    closest_mesh_to_coordinate(mesh_list = new_meshes,</span>
<span class="sd">    coordinate = current_endpoints[1],</span>
<span class="sd">    verbose=False,</span>
<span class="sd">    return_mesh=False,</span>
<span class="sd">    return_distance=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
    

    <span class="n">mesh_to_dist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">distance_method</span> <span class="o">==</span> <span class="s2">&quot;min_distance&quot;</span><span class="p">:</span>
            <span class="n">curr_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
            <span class="n">dist</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">curr_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
            <span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">distance_method</span> <span class="o">==</span> <span class="s2">&quot;bbox_center&quot;</span><span class="p">:</span>
            <span class="n">bbox_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_center</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinate</span> <span class="o">-</span> <span class="n">bbox_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">distance_method</span> <span class="o">==</span> <span class="s2">&quot;mesh_center&quot;</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinate</span> <span class="o">-</span> <span class="n">center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">distance_method</span> <span class="o">==</span> <span class="s2">&quot;min_distance_and_bbox_center&quot;</span><span class="p">:</span>
            <span class="n">curr_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
            <span class="n">dist_min</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">curr_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
            
            <span class="n">bbox_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_center</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">dist_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinate</span> <span class="o">-</span> <span class="n">bbox_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_bbox</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented Type distance_method (</span><span class="si">{</span><span class="n">distance_method</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">total_dist</span><span class="si">}</span><span class="s2"> nm away&quot;</span><span class="p">)</span>
        <span class="n">mesh_to_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_dist</span><span class="p">)</span>

    <span class="n">closest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">mesh_to_dist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Closest mesh: </span><span class="si">{</span><span class="n">closest_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">mesh_list</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">closest_idx</span>
        
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">closest_idx</span>

    <span class="k">if</span> <span class="n">return_distance</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">return_value</span><span class="p">,</span><span class="n">mesh_to_dist</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]]</span>
        
<span class="c1">#     if return_idx:</span>
<span class="c1">#         return_value = closest_idx</span>

    <span class="k">return</span> <span class="n">return_value</span></div>




    

<div class="viewcode-block" id="bbox_volume_oriented"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_volume_oriented">[docs]</a><span class="k">def</span> <span class="nf">bbox_volume_oriented</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">volume</span></div>
<div class="viewcode-block" id="bbox_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_volume">[docs]</a><span class="k">def</span> <span class="nf">bbox_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">volume</span></div>

<div class="viewcode-block" id="mesh_size"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_size">[docs]</a><span class="k">def</span> <span class="nf">mesh_size</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">size_type</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
             <span class="n">percentile</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
             <span class="n">replace_zero_values_with_center_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the size of a mesh based on the </span>
<span class="sd">    size type (vertices or faces)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;faces&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;vertices&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;ray_trace_mean&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                            <span class="n">replace_zero_values_with_center_distance</span><span class="o">=</span><span class="n">replace_zero_values_with_center_distance</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;ray_trace_median&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                              <span class="n">replace_zero_values_with_center_distance</span><span class="o">=</span><span class="n">replace_zero_values_with_center_distance</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                  <span class="n">replace_zero_values_with_center_distance</span><span class="o">=</span><span class="n">replace_zero_values_with_center_distance</span><span class="p">),</span><span class="n">percentile</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">surface_skeleton</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;volume&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;bbox_volume&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bbox_volume_oriented</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">size_type</span> <span class="o">==</span> <span class="s2">&quot;bbox_volume_oriented&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bbox_volume_oriented</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented type </span><span class="si">{</span><span class="n">size_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
    
    
<div class="viewcode-block" id="filter_meshes_by_size"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_meshes_by_size">[docs]</a><span class="k">def</span> <span class="nf">filter_meshes_by_size</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                          <span class="n">size_threshold</span><span class="p">,</span>
                         <span class="n">size_type</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                          <span class="n">above_threshold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the meshes</span>
<span class="sd">    or indices of the meshes that are above (or below if abvoe threshold</span>
<span class="sd">    set to False) the vertices or faces threshold</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Calculate the sizes of the meshes based on the threshold set</span>
<span class="sd">    2) Find the indices of the meshes that are above or below the threshold</span>
<span class="sd">    3) Return either the meshes or indices</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    tu.filter_meshes_by_size(mesh_list=new_meshes,</span>
<span class="sd">                          faces_threshold = None,</span>
<span class="sd">                         vertices_threshold=100,</span>
<span class="sd">                          above_threshold=True,</span>
<span class="sd">                          return_indices = True,</span>
<span class="sd">                         verbose=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<span class="c1">#     if faces_threshold is not None:</span>
<span class="c1">#         size_threshold = faces_threshold</span>
<span class="c1">#         size_type = &quot;faces&quot;</span>
<span class="c1">#     elif vertices_threshold is not None:</span>
<span class="c1">#         size_threshold = vertices_threshold</span>
<span class="c1">#         size_type = &quot;vertices&quot;</span>
<span class="c1">#     else:</span>
<span class="c1">#         raise Exception(&quot;Neither faces nor vertices threshold set&quot;)</span>
    
    <span class="k">if</span> <span class="n">size_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh_list</span>
    
    <span class="n">mesh_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">size_type</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_list</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_sizes with type (</span><span class="si">{</span><span class="n">size_type</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">mesh_sizes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#2) Find the indices of the meshes that are above or below the threshold</span>
    <span class="k">if</span> <span class="n">above_threshold</span><span class="p">:</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mesh_sizes</span><span class="o">&gt;</span><span class="n">size_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mesh_sizes</span><span class="o">&lt;=</span><span class="n">size_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;keep_indices = </span><span class="si">{</span><span class="n">keep_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">keep_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keep_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)[</span><span class="n">keep_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">keep_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keep_meshes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keep_meshes</span></div>
    
<div class="viewcode-block" id="filter_meshes_by_size_min_max"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_meshes_by_size_min_max">[docs]</a><span class="k">def</span> <span class="nf">filter_meshes_by_size_min_max</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                          <span class="n">min_size_threshold</span><span class="p">,</span>
                          <span class="n">max_size_threshold</span><span class="p">,</span>
                         <span class="n">size_type</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                          <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="n">min_indices</span> <span class="o">=</span> <span class="n">filter_meshes_by_size</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                          <span class="n">size_threshold</span><span class="o">=</span><span class="n">min_size_threshold</span><span class="p">,</span>
                         <span class="n">size_type</span><span class="o">=</span><span class="n">size_type</span><span class="p">,</span>
                          <span class="n">above_threshold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    
    <span class="n">max_indices</span> <span class="o">=</span> <span class="n">filter_meshes_by_size</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                          <span class="n">size_threshold</span><span class="o">=</span><span class="n">max_size_threshold</span><span class="p">,</span>
                         <span class="n">size_type</span><span class="o">=</span><span class="n">size_type</span><span class="p">,</span>
                          <span class="n">above_threshold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="n">min_max_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">min_indices</span><span class="p">,</span><span class="n">max_indices</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_indices = </span><span class="si">{</span><span class="n">min_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_indices = </span><span class="si">{</span><span class="n">max_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_max_indices = </span><span class="si">{</span><span class="n">min_max_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">min_max_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keep_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)[</span><span class="n">min_max_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">keep_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keep_meshes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keep_meshes</span></div>
    
<div class="viewcode-block" id="bbox_side_length_ratios"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_side_length_ratios">[docs]</a><span class="k">def</span> <span class="nf">bbox_side_length_ratios</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will compute the ratios of the bounding box sides</span>
<span class="sd">    To be later used to see if there is skewness</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># bbox = current_mesh.bounding_box_oriented.vertices</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">x_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">y_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">z_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">x_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">y_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">z_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="c1">#print(x_length,y_length,z_length)</span>
    <span class="c1">#compute the ratios:</span>
    <span class="n">xy_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_length</span><span class="o">/</span><span class="n">y_length</span><span class="p">)</span>
    <span class="n">xz_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_length</span><span class="o">/</span><span class="n">z_length</span><span class="p">)</span>
    <span class="n">yz_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y_length</span><span class="o">/</span><span class="n">z_length</span><span class="p">)</span>
    <span class="n">side_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">xy_ratio</span><span class="p">,</span><span class="n">xz_ratio</span><span class="p">,</span><span class="n">yz_ratio</span><span class="p">]</span>
    <span class="n">flipped_side_ratios</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">side_ratios</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">flipped_side_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flipped_side_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flipped_side_ratios</span></div>
    
    

<div class="viewcode-block" id="mesh_volume_ratio"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_volume_ratio">[docs]</a><span class="k">def</span> <span class="nf">mesh_volume_ratio</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                     <span class="n">bbox_type</span><span class="o">=</span><span class="s2">&quot;bounding_box_oriented&quot;</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute the ratio of the bounding box to the </span>
<span class="sd">    volume of the mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">bbox_type</span> <span class="o">==</span> <span class="s2">&quot;bounding_box_oriented&quot;</span><span class="p">:</span>
        <span class="n">bbox_volume</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">volume</span>
    <span class="k">elif</span> <span class="n">bbox_type</span> <span class="o">==</span> <span class="s2">&quot;bounding_box&quot;</span><span class="p">:</span>
        <span class="n">bbox_volume</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">volume</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplementing bbox_type: </span><span class="si">{</span><span class="n">bounding_box</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">curr_mesh_volume</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> 
    
    
    <span class="n">ratio_val</span> <span class="o">=</span> <span class="n">bbox_volume</span><span class="o">/</span><span class="n">curr_mesh_volume</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bbox_volume (using type </span><span class="si">{</span><span class="n">bounding_box</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">bbox_volume</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_mesh_volume = </span><span class="si">{</span><span class="n">curr_mesh_volume</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;volume ratio = </span><span class="si">{</span><span class="n">bounding_box</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ratio_val</span></div>

<div class="viewcode-block" id="plot_segmentation"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.plot_segmentation">[docs]</a><span class="k">def</span> <span class="nf">plot_segmentation</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span><span class="n">cgal_info</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segmentation Info:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span><span class="n">cgal_info</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="closest_split_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_split_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_split_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                               <span class="n">coordinate</span><span class="p">,</span>
                               <span class="n">plot_split</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">plot_closest_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                               <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To run the mesh splitting and then to </span>
<span class="sd">    choose the closest split mesh to a coordinate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                            <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                            <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                           <span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_split</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh Split with significance_threshold = </span><span class="si">{</span><span class="n">significance_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">sig_pieces</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                         <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">closest_mesh_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_to_coordinate</span><span class="p">(</span><span class="n">sig_pieces</span><span class="p">,</span>
                             <span class="n">coordinate</span><span class="o">=</span><span class="n">coordinate</span><span class="p">,</span>
                             <span class="n">return_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">potential_webbing_mesh</span> <span class="o">=</span> <span class="n">sig_pieces</span><span class="p">[</span><span class="n">closest_mesh_idx</span><span class="p">]</span>
    <span class="n">non_webbing_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig_pieces</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig_pieces</span><span class="p">))</span> <span class="o">!=</span> <span class="n">closest_mesh_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning Mesh idx = </span><span class="si">{</span><span class="n">closest_mesh_idx</span><span class="si">}</span><span class="s2">, mesh = </span><span class="si">{</span><span class="n">potential_webbing_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_closest_mesh</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">potential_webbing_mesh</span><span class="p">,</span>
                      <span class="n">main_mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">meshes</span><span class="o">=</span><span class="n">non_webbing_meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">potential_webbing_mesh</span></div>
    
<div class="viewcode-block" id="closest_segmentation_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_segmentation_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_segmentation_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                       <span class="n">coordinate</span><span class="p">,</span>
                                       <span class="n">clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                       <span class="n">smoothness</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                                       <span class="n">plot_segmentation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">plot_closest_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">return_cgal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">mesh_segmentation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">mesh_segmentation_cdfs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To run a mesh segmentation and then </span>
<span class="sd">    choose the segment that is closest to a coordinate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Run segmentation algorithm to find the webbing</span>
    <span class="k">if</span> <span class="n">mesh_segmentation</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mesh_segmentation_cdfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_segs</span><span class="p">,</span> <span class="n">cgal_info</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                            <span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span>
                            <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_segs</span> <span class="o">=</span> <span class="n">mesh_segmentation</span>
        <span class="n">cgal_info</span> <span class="o">=</span> <span class="n">mesh_segmentation_cdfs</span>
        
        
    <span class="k">if</span> <span class="n">plot_segmentation</span><span class="p">:</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">plot_segmentation</span><span class="p">(</span><span class="n">mesh_segs</span><span class="p">,</span><span class="n">cgal_info</span><span class="p">)</span>

    <span class="n">closest_web_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_to_coordinate</span><span class="p">(</span><span class="n">mesh_segs</span><span class="p">,</span>
                                 <span class="n">coordinate</span><span class="o">=</span><span class="n">coordinate</span><span class="p">,</span>
                                <span class="n">distance_method</span> <span class="o">=</span> <span class="s2">&quot;min_distance_and_bbox_center&quot;</span><span class="p">,</span>
                                 <span class="n">return_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">web_mesh</span> <span class="o">=</span> <span class="n">mesh_segs</span><span class="p">[</span><span class="n">closest_web_idx</span><span class="p">]</span>
    <span class="n">web_mesh_cdf</span> <span class="o">=</span> <span class="n">cgal_info</span><span class="p">[</span><span class="n">closest_web_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning mesh idx = </span><span class="si">{</span><span class="n">closest_web_idx</span><span class="si">}</span><span class="s2">, mesh = </span><span class="si">{</span><span class="n">web_mesh</span><span class="si">}</span><span class="s2">, cdf = </span><span class="si">{</span><span class="n">web_mesh_cdf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">webless_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_segs</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_segs</span><span class="p">))</span> <span class="o">!=</span> <span class="n">closest_web_idx</span><span class="p">]</span>

    <span class="c1">#find the mesh that is closest to the connecting point</span>

    <span class="k">if</span> <span class="n">plot_closest_mesh</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">web_mesh</span><span class="p">,</span>
                          <span class="n">main_mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">meshes</span><span class="o">=</span><span class="n">webless_meshes</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_cgal</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">web_mesh</span><span class="p">,</span><span class="n">web_mesh_cdf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">web_mesh</span></div>
    
<div class="viewcode-block" id="mesh_overlap_with_restriction_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_overlap_with_restriction_mesh">[docs]</a><span class="k">def</span> <span class="nf">mesh_overlap_with_restriction_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                               <span class="n">restriction_mesh</span><span class="p">,</span>
                               <span class="n">size_measure</span> <span class="o">=</span> <span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                            <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">restriction_mesh_kd</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find what percentage of a mesh matches a mesh</span>
<span class="sd">    that is restriction mesh</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="o">=</span> <span class="n">mesh</span>

    <span class="n">original_size</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">size_measure</span><span class="p">)</span>

    <span class="n">m_with_restrict</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">restriction_mesh</span><span class="p">,</span>
                                                 <span class="n">m</span><span class="p">,</span>
                               <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">restriction_mesh_kd</span><span class="p">,</span>
                               <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_threshold</span><span class="p">,</span>
                               <span class="n">exact_match</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span>
                              <span class="p">)</span>

    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">m_with_restrict</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">: No Overlap with restriction&quot;</span><span class="p">)</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">restricted_size</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">m_with_restrict</span><span class="p">,</span><span class="n">size_measure</span><span class="p">)</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">restricted_size</span><span class="o">/</span><span class="n">original_size</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">: original_size = </span><span class="si">{</span><span class="n">original_size</span><span class="si">}</span><span class="s2">, restricted_size = </span><span class="si">{</span><span class="n">restricted_size</span><span class="si">}</span><span class="s2">, ratio = </span><span class="si">{</span><span class="n">ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ratio</span></div>

<div class="viewcode-block" id="restrict_mesh_list_by_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.restrict_mesh_list_by_mesh">[docs]</a><span class="k">def</span> <span class="nf">restrict_mesh_list_by_mesh</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                              <span class="n">restriction_mesh</span><span class="p">,</span>
                               <span class="n">percentage_threshold</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                               <span class="n">size_measure</span> <span class="o">=</span> <span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                            <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">return_meshes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">return_under_threshold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purplse: To restrict a mesh list by the </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">restr_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">restriction_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>

    <span class="n">mesh_match_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mesh_list_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_overlap_with_restriction_mesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                                      <span class="n">restriction_mesh</span><span class="p">,</span>
                                    <span class="n">size_measure</span><span class="o">=</span><span class="n">size_measure</span><span class="p">,</span>
                                    <span class="n">match_threshold</span><span class="o">=</span><span class="n">match_threshold</span><span class="p">,</span>
                                    <span class="n">restriction_mesh_kd</span> <span class="o">=</span> <span class="n">restr_kd</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mesh_list</span><span class="p">])</span>
    <span class="n">mesh_match_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mesh_list_ratios</span><span class="o">&gt;</span><span class="n">percentage_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_under_threshold</span><span class="p">:</span>
        <span class="n">mesh_match_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)),</span><span class="n">mesh_match_idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">)[</span><span class="n">mesh_match_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_match_idx</span></div>
    
    
    
<div class="viewcode-block" id="min_cut_to_partition_mesh_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.min_cut_to_partition_mesh_vertices">[docs]</a><span class="k">def</span> <span class="nf">min_cut_to_partition_mesh_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                      <span class="n">source_coordinates</span><span class="p">,</span>
                                      <span class="n">sink_coordinates</span><span class="p">,</span>
                                       <span class="n">plot_source_sink_vertices</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">plot_cut_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                      <span class="n">return_edge_midpoint</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the vertex points would need to cut to </span>
<span class="sd">    seperate groups of points on a mesh (or close to a mesh)</span>
<span class="sd">    so that the groups are on seperate component meshes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Create a kdtree of the mesh vertices</span>
<span class="sd">    and map the source/sink coordinate to vertex indices on the mesh</span>
<span class="sd">    2) Get the mesh adjacency graph</span>
<span class="sd">    3) Find the min_cut edges on the adajacency graph, if None return None</span>
<span class="sd">    4) Return either vertex coordinates of all nodes in edges,</span>
<span class="sd">    or the coordinate of the middle point in the edges</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    source_coordinates = [skeleton_offset_points[0],skeleton_offset_points[1]]</span>
<span class="sd">    sink_coordinates = [skeleton_offset_points[2],skeleton_offset_points[3]]</span>
<span class="sd">    curr_output = tu.min_cut_to_partition_mesh_vertices(mesh_inter,</span>
<span class="sd">                                          source_coordinates,</span>
<span class="sd">                                          sink_coordinates,</span>
<span class="sd">                                           plot_source_sink_vertices= True,</span>
<span class="sd">                                          verbose = True,</span>
<span class="sd">                                          return_edge_midpoint = True,</span>
<span class="sd">                                                    plot_cut_vertices = True)</span>
<span class="sd">    curr_output</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span>
    <span class="n">source_coordinates</span>
    <span class="n">sink_coordinates</span> 

    
    
    <span class="n">mesh_inter_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">source_vert_idx</span> <span class="o">=</span> <span class="n">mesh_inter_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">sink_vert_idx</span> <span class="o">=</span> <span class="n">mesh_inter_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sink_coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">source_vert_idx</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sink_vert_idx</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find a cut edge because not different nodes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">plot_source_sink_vertices</span><span class="p">:</span>
        <span class="n">sink_vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sink_vert_idx</span><span class="p">)]</span>
        <span class="n">source_vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_vert_idx</span><span class="p">)]</span>
        
        <span class="n">sink_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">source_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source = </span><span class="si">{</span><span class="n">source_color</span><span class="si">}</span><span class="s2">, Sink = </span><span class="si">{</span><span class="n">sink_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">sink_color</span><span class="p">,</span><span class="n">source_color</span><span class="p">]</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">sink_vertices</span><span class="p">,</span><span class="n">source_vertices</span><span class="p">],</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_adjacency_graph</span>

    <span class="n">G_cut_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">min_cut_to_partition_node_groups</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source_nodes</span><span class="o">=</span><span class="n">source_vert_idx</span><span class="p">,</span>
                                                      <span class="n">sink_nodes</span> <span class="o">=</span> <span class="n">sink_vert_idx</span><span class="p">,</span>
                                                      <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;G_cut_edges = {G_cut_edges}&quot;)</span>
    <span class="k">if</span> <span class="n">G_cut_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find a cut edge for the source and sink coordinates: returning None&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="n">G_cut_edges_vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">G_cut_edges</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_edge_midpoint</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">G_cut_edges_vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">G_cut_edges_vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# 0f cut points = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_cut_vertices</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">return_value</span><span class="p">],</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="coordinates_to_enclosing_sphere_center_radius"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.coordinates_to_enclosing_sphere_center_radius">[docs]</a><span class="k">def</span> <span class="nf">coordinates_to_enclosing_sphere_center_radius</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the volume that would be needed to </span>
<span class="sd">    encapsulate a set of points</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get the mean of the points</span>
<span class="sd">    2) Return the max distance from the mean</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinates</span><span class="o">-</span><span class="n">center</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;center = </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s2">, radius = </span><span class="si">{</span><span class="n">radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="n">radius</span><span class="p">)</span></div>

<div class="viewcode-block" id="coordinates_to_enclosing_sphere"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.coordinates_to_enclosing_sphere">[docs]</a><span class="k">def</span> <span class="nf">coordinates_to_enclosing_sphere</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">sphere_mesh</span><span class="p">(</span><span class="o">*</span><span class="n">coordinates_to_enclosing_sphere_center_radius</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span></div>

<div class="viewcode-block" id="coordinates_to_enclosing_sphere_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.coordinates_to_enclosing_sphere_volume">[docs]</a><span class="k">def</span> <span class="nf">coordinates_to_enclosing_sphere_volume</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the volume that would be needed to </span>
<span class="sd">    encapsulate a set of points</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get the mean of the points</span>
<span class="sd">    2) Return the max distance from the mean</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center</span><span class="p">,</span><span class="n">radius</span> <span class="o">=</span> <span class="n">coordinates_to_enclosing_sphere_center_radius</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span></div>

<div class="viewcode-block" id="coordinates_to_bounding_box"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.coordinates_to_bounding_box">[docs]</a><span class="k">def</span> <span class="nf">coordinates_to_bounding_box</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">coordinates</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">oriented</span><span class="o">=</span><span class="n">oriented</span><span class="p">)</span></div>

<span class="c1"># -------- 6/7: Used for the synapse filtering ----------#</span>

<div class="viewcode-block" id="mesh_to_kdtree"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_to_kdtree">[docs]</a><span class="k">def</span> <span class="nf">mesh_to_kdtree</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span></div>

<div class="viewcode-block" id="valid_coordiantes_mapped_to_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.valid_coordiantes_mapped_to_mesh">[docs]</a><span class="k">def</span> <span class="nf">valid_coordiantes_mapped_to_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                     <span class="n">coordinates</span><span class="p">,</span>
                                     <span class="n">mesh_kd</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">mapping_threshold</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                                    <span class="n">original_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">original_mesh_faces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="n">return_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine if coordinates are within</span>
<span class="sd">    a certain mapping distance to a mesh (to determine if they are valid or not)</span>

<span class="sd">    If an original mesh is specified then if a coordinate maps</span>
<span class="sd">    to the original mesh but not the main mesh specified then it is not valid</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mesh_errored_syn_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">original_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not using original mesh for invalidaiton of coordinates&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">mesh_kd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mesh_kd</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_to_kdtree</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">mesh_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="n">mesh_errored_syn_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span><span class="o">&gt;</span><span class="n">mapping_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using original mesh for invalidaiton of coordinates&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">original_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;calculating original_mesh_kd because None&quot;</span><span class="p">)</span>
            <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_to_kdtree</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">original_mesh_faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;calculating original_mesh_faces because None&quot;</span><span class="p">)</span>
            <span class="n">original_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                                <span class="n">mesh</span><span class="p">,</span>
                                                                <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>
            
        <span class="n">neuron_mesh_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">))</span>
        <span class="n">neuron_mesh_labels</span><span class="p">[</span><span class="n">original_mesh_faces</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="n">closest_face_labels</span> <span class="o">=</span> <span class="n">neuron_mesh_labels</span><span class="p">[</span><span class="n">closest_face</span><span class="p">]</span>

        <span class="n">mesh_errored_syn_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">dist</span><span class="o">&gt;</span><span class="n">mapping_threshold</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">closest_face_labels</span><span class="o">==</span><span class="mi">0</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_errors</span><span class="p">:</span>
        <span class="n">mesh_errored_syn_idx</span>
        <span class="n">mesh_errored_syn_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)),</span><span class="n">mesh_errored_syn_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="n">mesh_errored_syn_idx</span> <span class="o">=</span> <span class="n">coordinaes</span><span class="p">[</span><span class="n">mesh_errored_syn_idx</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">mesh_errored_syn_idx</span></div>

<div class="viewcode-block" id="mesh_kdtree_face"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_kdtree_face">[docs]</a><span class="k">def</span> <span class="nf">mesh_kdtree_face</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span>
    <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">original_mesh_kdtree</span></div>

<div class="viewcode-block" id="mesh_kdtree_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_kdtree_vertices">[docs]</a><span class="k">def</span> <span class="nf">mesh_kdtree_vertices</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">original_mesh_kdtree</span></div>


<span class="c1"># -------- trying to help differentiating soma mergers from non soma mergers ------</span>
<span class="n">default_percentile</span> <span class="o">=</span> <span class="mi">70</span>
<span class="n">default_percentage</span> <span class="o">=</span> <span class="mi">70</span>

<div class="viewcode-block" id="surface_area"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.surface_area">[docs]</a><span class="k">def</span> <span class="nf">surface_area</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">area</span></div>

<div class="viewcode-block" id="default_mesh_stats_to_run"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.default_mesh_stats_to_run">[docs]</a><span class="k">def</span> <span class="nf">default_mesh_stats_to_run</span><span class="p">(</span><span class="n">ray_trace_perc_options</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">95</span><span class="p">),</span>
                             <span class="n">interpercentile_options</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">95</span><span class="p">),</span>
                             <span class="n">center_to_width_ratio_options</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">95</span><span class="p">)):</span>
    <span class="n">basic_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;surface_area&quot;</span><span class="p">,</span>
        <span class="n">function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">surface_area</span><span class="p">,</span>
                        <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="p">,</span>
                       <span class="p">),</span>
     <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;volume&quot;</span><span class="p">,</span>
         <span class="n">function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">,</span>
          <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>
         <span class="p">),</span>
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;sa_to_volume&quot;</span><span class="p">,</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">surface_area_to_volume</span><span class="p">),</span>
     <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;n_faces&quot;</span><span class="p">,</span>
         <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">,</span>
         <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">size_type</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">),</span>
        <span class="p">),]</span>

    <span class="n">ray_trace_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ray_trace_percentile_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                           <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">,</span>
                           <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">size_type</span> <span class="o">=</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">,</span>
                                        <span class="n">percentile</span> <span class="o">=</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ray_trace_perc_options</span><span class="p">]</span>
    
    <span class="n">interpercentile_funcs</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">combine_list_of_lists</span><span class="p">([[</span>
                                <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ipr_x_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                   <span class="n">function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">interpercentile_range_face_midpoints_x</span><span class="p">,</span>
                                   <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentage</span> <span class="o">=</span> <span class="n">k</span><span class="p">)),</span>
                                <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ipr_y_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                   <span class="n">function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">interpercentile_range_face_midpoints_y</span><span class="p">,</span>
                                   <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentage</span> <span class="o">=</span> <span class="n">k</span><span class="p">)),</span>
                            <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ipr_z_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                               <span class="n">function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">interpercentile_range_face_midpoints_z</span><span class="p">,</span>
                                               <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentage</span> <span class="o">=</span> <span class="n">k</span><span class="p">)),</span>
                            <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ipr_volume_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                   <span class="n">function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">interpercentile_range_face_midpoints_volume</span><span class="p">,</span>
                                   <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentage</span> <span class="o">=</span> <span class="n">k</span><span class="p">))]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">interpercentile_options</span> <span class="p">])</span>
    <span class="n">eigenvector_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ipr_eig_xz_max_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ipr_largest_eigenvector_xz</span><span class="p">,</span>
                             <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentage</span> <span class="o">=</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">interpercentile_options</span><span class="p">]</span>
    <span class="n">mesh_center_funcs</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">combine_list_of_lists</span><span class="p">([[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;center_to_width_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ratio_closest_face_to_mesh_center_distance_to_width</span><span class="p">,</span>
                             <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentile</span> <span class="o">=</span> <span class="n">k</span><span class="p">)),</span>
                            
                                                   <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;center_to_width_farthest_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                             <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ratio_farthest_face_to_mesh_center_distance_to_width</span><span class="p">,</span>
                             <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">percentile</span> <span class="o">=</span> <span class="n">k</span><span class="p">)),</span>
                                                   
                             <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ipr_eig_xz_to_width_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">function</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ratio_ipr_eigenvector_xz_diff_to_width</span><span class="p">,</span>
                                 <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">percentage</span><span class="o">=</span><span class="n">k</span><span class="p">))]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">center_to_width_ratio_options</span><span class="p">])</span>

    
    <span class="k">return</span> <span class="n">gu</span><span class="o">.</span><span class="n">combine_list_of_lists</span><span class="p">([</span><span class="n">basic_funcs</span><span class="p">,</span> <span class="n">ray_trace_funcs</span><span class="p">,</span><span class="n">interpercentile_funcs</span><span class="p">,</span><span class="n">mesh_center_funcs</span><span class="p">,</span><span class="n">eigenvector_sizes</span><span class="p">])</span></div>
<div class="viewcode-block" id="mesh_stats"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_stats">[docs]</a><span class="k">def</span> <span class="nf">mesh_stats</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">stats_dicts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stats_dicts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stats_dicts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">default_mesh_stats_to_run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">st_dict</span> <span class="ow">in</span> <span class="n">stats_dicts</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">st_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="n">st_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;divisor&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">st_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">st_dict</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">](</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">/</span><span class="n">divisor</span>
    <span class="k">return</span> <span class="n">output_dict</span></div>

<span class="n">default_percentage</span> <span class="o">=</span> <span class="mi">70</span>
<div class="viewcode-block" id="interpercentile_range_face_midpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.interpercentile_range_face_midpoints">[docs]</a><span class="k">def</span> <span class="nf">interpercentile_range_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                         <span class="n">percentage</span><span class="o">=</span><span class="n">default_percentage</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    purpose: To find the </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">interpercentile_range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">,</span>
                             <span class="n">percentage</span><span class="p">,</span>
                             <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="interpercentile_range_face_midpoints_x"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.interpercentile_range_face_midpoints_x">[docs]</a><span class="k">def</span> <span class="nf">interpercentile_range_face_midpoints_x</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                           <span class="n">percentage</span><span class="o">=</span><span class="n">default_percentage</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">interpercentile_range_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="interpercentile_range_face_midpoints_y"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.interpercentile_range_face_midpoints_y">[docs]</a><span class="k">def</span> <span class="nf">interpercentile_range_face_midpoints_y</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                           <span class="n">percentage</span><span class="o">=</span><span class="n">default_percentage</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">interpercentile_range_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="interpercentile_range_face_midpoints_z"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.interpercentile_range_face_midpoints_z">[docs]</a><span class="k">def</span> <span class="nf">interpercentile_range_face_midpoints_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                           <span class="n">percentage</span><span class="o">=</span><span class="n">default_percentage</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">interpercentile_range_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="interpercentile_range_face_midpoints_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.interpercentile_range_face_midpoints_volume">[docs]</a><span class="k">def</span> <span class="nf">interpercentile_range_face_midpoints_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                           <span class="n">percentage</span><span class="o">=</span><span class="n">default_percentage</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">interpercentile_range_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">))</span></div>

<div class="viewcode-block" id="closest_face_to_mesh_center_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_face_to_mesh_center_distance">[docs]</a><span class="k">def</span> <span class="nf">closest_face_to_mesh_center_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">curr_mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_face_to_coordinate_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                      <span class="n">curr_mesh_center</span><span class="p">)</span></div>

<div class="viewcode-block" id="farthest_face_to_mesh_center_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.farthest_face_to_mesh_center_distance">[docs]</a><span class="k">def</span> <span class="nf">farthest_face_to_mesh_center_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">curr_mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">farthest_face_to_coordinate_distance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                      <span class="n">curr_mesh_center</span><span class="p">)</span></div>

<div class="viewcode-block" id="ratio_mesh_stat_to_width"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ratio_mesh_stat_to_width">[docs]</a><span class="k">def</span> <span class="nf">ratio_mesh_stat_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">mesh_stat_function</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">default_percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">closest_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To measure the ratio between the distance between the closest</span>
<span class="sd">    mesh face and the overall width of the mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">closest_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">closest_distance</span> <span class="o">=</span> <span class="n">mesh_stat_function</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="n">curr_ray_trace</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
             <span class="n">size_type</span><span class="o">=</span><span class="n">width_func_name</span><span class="p">,</span>
            <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">)</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">closest_distance</span><span class="o">/</span><span class="n">curr_ray_trace</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mesh_stat_function</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">closest_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_ray_trace = </span><span class="si">{</span><span class="n">curr_ray_trace</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio = </span><span class="si">{</span><span class="n">ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ratio</span></div>


<div class="viewcode-block" id="ratio_closest_face_to_mesh_center_distance_to_width"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ratio_closest_face_to_mesh_center_distance_to_width">[docs]</a><span class="k">def</span> <span class="nf">ratio_closest_face_to_mesh_center_distance_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">default_percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">ratio_mesh_stat_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">mesh_stat_function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">closest_face_to_mesh_center_distance</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="n">width_func_name</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="ratio_farthest_face_to_mesh_center_distance_to_width"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ratio_farthest_face_to_mesh_center_distance_to_width">[docs]</a><span class="k">def</span> <span class="nf">ratio_farthest_face_to_mesh_center_distance_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">default_percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">ratio_mesh_stat_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">mesh_stat_function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">farthest_face_to_mesh_center_distance</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="n">width_func_name</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>


    
    
<div class="viewcode-block" id="face_midpoints_x_z"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.face_midpoints_x_z">[docs]</a><span class="k">def</span> <span class="nf">face_midpoints_x_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Application: Can just analyze the data that is not going top to bottom in microns volume</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span></div>


<div class="viewcode-block" id="ipr_largest_eigenvector_xy"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ipr_largest_eigenvector_xy">[docs]</a><span class="k">def</span> <span class="nf">ipr_largest_eigenvector_xy</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">percentage</span> <span class="o">=</span> <span class="n">default_percentage</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">dru</span><span class="o">.</span><span class="n">largest_eigenvector_proj</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">face_midpoints_x_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">interpercentile_range</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="ipr_largest_eigenvector_xz"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ipr_largest_eigenvector_xz">[docs]</a><span class="k">def</span> <span class="nf">ipr_largest_eigenvector_xz</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">percentage</span> <span class="o">=</span> <span class="n">default_percentage</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">dru</span><span class="o">.</span><span class="n">largest_eigenvector_proj</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">face_midpoints_x_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">interpercentile_range</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="ipr_second_largest_eigenvector_xz"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ipr_second_largest_eigenvector_xz">[docs]</a><span class="k">def</span> <span class="nf">ipr_second_largest_eigenvector_xz</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">percentage</span> <span class="o">=</span> <span class="n">default_percentage</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">dru</span><span class="o">.</span><span class="n">second_largest_eigenvector_proj</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">face_midpoints_x_z</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">interpercentile_range</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span><span class="n">percentage</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ipr_first_second_largest_eigenvector_xz_diff"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ipr_first_second_largest_eigenvector_xz_diff">[docs]</a><span class="k">def</span> <span class="nf">ipr_first_second_largest_eigenvector_xz_diff</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">percentage</span> <span class="o">=</span> <span class="n">default_percentage</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">ipr_largest_eigenvector_xz</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">percentage</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span> <span class="o">-</span> 
            <span class="n">tu</span><span class="o">.</span><span class="n">ipr_second_largest_eigenvector_xz</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">percentage</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">))</span></div>

<div class="viewcode-block" id="ratio_ipr_eigenvector_xz_diff_to_width"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.ratio_ipr_eigenvector_xz_diff_to_width">[docs]</a><span class="k">def</span> <span class="nf">ratio_ipr_eigenvector_xz_diff_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">default_percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">ratio_mesh_stat_to_width</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">mesh_stat_function</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">ipr_first_second_largest_eigenvector_xz_diff</span><span class="p">,</span>
                            <span class="n">width_func_name</span> <span class="o">=</span> <span class="n">width_func_name</span><span class="p">,</span>
                            <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="surface_area_to_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.surface_area_to_volume">[docs]</a><span class="k">def</span> <span class="nf">surface_area_to_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">surface_area_divisor</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="p">,</span>
                          <span class="n">volume_divisor</span> <span class="o">=</span> <span class="mi">1_000_000_000</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="p">):</span>
    <span class="n">curr_area</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">surface_area</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">/</span><span class="n">surface_area_divisor</span>
    <span class="n">curr_vol</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="o">/</span><span class="n">volume_divisor</span>
    <span class="k">if</span> <span class="n">curr_vol</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Volume 0&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">surface_area_to_vol_ratio</span> <span class="o">=</span> <span class="n">curr_area</span><span class="o">/</span> <span class="n">curr_vol</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;surface area = </span><span class="si">{</span><span class="n">curr_area</span><span class="si">}</span><span class="s2">, voluem = </span><span class="si">{</span><span class="n">curr_vol</span><span class="si">}</span><span class="s2">, surface_area_to_vol_ratio = </span><span class="si">{</span><span class="n">surface_area_to_vol_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">surface_area_to_vol_ratio</span></div>


<div class="viewcode-block" id="mesh_centered_at_origin"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_centered_at_origin">[docs]</a><span class="k">def</span> <span class="nf">mesh_centered_at_origin</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To move a mesh to where the mesh </span>
<span class="sd">    center is at the origina</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh</span></div>

<span class="n">centered_at_origin</span> <span class="o">=</span> <span class="n">mesh_centered_at_origin</span>
<span class="n">center_at_origin</span> <span class="o">=</span> <span class="n">mesh_centered_at_origin</span>

<div class="viewcode-block" id="rotate_mesh_from_matrix"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.rotate_mesh_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">rotate_mesh_from_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">new_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">@</span> <span class="n">matrix</span>
    <span class="k">return</span> <span class="n">new_mesh</span></div>


<div class="viewcode-block" id="faces_closer_than_distance_of_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.faces_closer_than_distance_of_coordinates">[docs]</a><span class="k">def</span> <span class="nf">faces_closer_than_distance_of_coordinates</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">closer_than</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the faces of a </span>
<span class="sd">    mesh that are within a certain distance</span>
<span class="sd">    of a coordinate/coordinates</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Build KDTree from coordinates</span>
<span class="sd">    2) Query the mesh triangles against KDTree</span>
<span class="sd">    3) Find the meshes that are closer/farther than threshold</span>
<span class="sd">    4) Return face ids (or submesh)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    rest_mesh = tu.faces_closer_than_distance_of_coordinates(</span>
<span class="sd">    mesh = branch.mesh,</span>
<span class="sd">    coordinate = curr_point,</span>
<span class="sd">    distance_threshold = 5_000,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    return_mesh=True</span>
<span class="sd">    )</span>

<span class="sd">    ipvu.plot_objects(rest_mesh)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>

    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">closer_than</span><span class="p">:</span>
        <span class="n">face_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">face_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">distance_threshold</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of faces within </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">face_id</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_id</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">submesh</span><span class="p">],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
            <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinate</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_id</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">face_id</span></div>

<div class="viewcode-block" id="faces_farther_than_distance_of_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.faces_farther_than_distance_of_coordinates">[docs]</a><span class="k">def</span> <span class="nf">faces_farther_than_distance_of_coordinates</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">faces_closer_than_distance_of_coordinates</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">closer_than</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="n">return_mesh</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="n_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.n_faces">[docs]</a><span class="k">def</span> <span class="nf">n_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span> 
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="overlapping_attribute"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.overlapping_attribute">[docs]</a><span class="k">def</span> <span class="nf">overlapping_attribute</span><span class="p">(</span>
    <span class="n">mesh1</span><span class="p">,</span>
    <span class="n">mesh2</span><span class="p">,</span>
    <span class="n">attribute_name</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return the attributes</span>
<span class="sd">    that are overlapping for 2  meshes</span>
<span class="sd">    </span>
<span class="sd">    if return idx will return idx of first</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">global_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">original_mesh_midpoints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh1</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
    <span class="n">submesh_midpoints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh2</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
    
    <span class="c1">#1) Put the submesh face midpoints into a KDTree</span>
    <span class="n">submesh_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">submesh_midpoints</span><span class="p">)</span>
    <span class="c1">#2) Query the fae midpoints of submesh against KDTree</span>
    <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">submesh_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">original_mesh_midpoints</span><span class="p">)</span>
    
    <span class="n">match_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">match_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">original_mesh_midpoints</span><span class="p">[</span><span class="n">match_idx</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="overlapping_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.overlapping_vertices">[docs]</a><span class="k">def</span> <span class="nf">overlapping_vertices</span><span class="p">(</span>
    <span class="n">mesh1</span><span class="p">,</span>
    <span class="n">mesh2</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">overlapping_attribute</span><span class="p">(</span>
    <span class="n">mesh1</span><span class="p">,</span>
    <span class="n">mesh2</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="n">return_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="overlapping_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.overlapping_faces">[docs]</a><span class="k">def</span> <span class="nf">overlapping_faces</span><span class="p">(</span>
    <span class="n">mesh1</span><span class="p">,</span>
    <span class="n">mesh2</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">overlapping_attribute</span><span class="p">(</span>
    <span class="n">mesh1</span><span class="p">,</span>
    <span class="n">mesh2</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="s2">&quot;triangles_center&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="n">return_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="radius_sphere_from_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.radius_sphere_from_volume">[docs]</a><span class="k">def</span> <span class="nf">radius_sphere_from_volume</span><span class="p">(</span><span class="n">volume</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the radius</span>
<span class="sd">    from the volume assuming spherical</span>
<span class="sd">    </span>
<span class="sd">    V = (4/3)*np.pi*(r**3)</span>
<span class="sd">    (V*(3/(4*np.pi)))**(1/3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">volume</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span></div>


<div class="viewcode-block" id="mesh_list_distance_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_list_distance_connectivity">[docs]</a><span class="k">def</span> <span class="nf">mesh_list_distance_connectivity</span><span class="p">(</span>
    <span class="n">meshes</span><span class="p">,</span>
    <span class="n">pairs_to_test</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">return_G</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the distances</span>
<span class="sd">    between all meshes in a list and represent</span>
<span class="sd">    them as edges (can passback as a graph if need be)</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For all possile combinations of meshes (or those prescribed)</span>
<span class="sd">    1) Find the distance between the meshes</span>
<span class="sd">    2) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pairs_to_test</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pairs_to_test</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">all_unique_choose_2_combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">)))</span>
        
    <span class="n">total_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">pairs_to_test</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_distance_between_meshes</span><span class="p">(</span>
            <span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">meshes</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> dist = </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_distance</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(above threshold: </span><span class="si">{</span><span class="n">dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_distance</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">total_edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">dist</span><span class="p">])</span>
            
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_edges</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_G</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">total_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">total_edges</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="closest_mesh_to_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_to_mesh">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_to_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">meshes</span><span class="p">,</span>
    <span class="n">return_closest_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_closest_vertex_on_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the index of the closest mesh </span>
<span class="sd">    out of a list of meshes and the closest</span>
<span class="sd">    distance and vertex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">piece</span> <span class="o">=</span> <span class="n">mesh</span>

    <span class="n">piece_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="n">nst_closest_dists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nst_closest_vertex</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">:</span>
        <span class="n">dists</span><span class="p">,</span><span class="n">closest_vert</span> <span class="o">=</span> <span class="n">piece_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="n">nst_closest_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">min_idx</span><span class="p">])</span>
        <span class="n">nst_closest_vertex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">closest_vert</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]])</span>

    <span class="n">closest_soma_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">nst_closest_dists</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_dists = </span><span class="si">{</span><span class="n">nst_closest_dists</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_vertex = </span><span class="si">{</span><span class="n">nst_closest_vertex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_soma_idx = </span><span class="si">{</span><span class="n">closest_soma_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_closest_vertex_on_mesh</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_closest_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_soma_idx</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">closest_soma_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_closest_distance</span><span class="p">:</span>
        <span class="n">closest_dist</span> <span class="o">=</span> <span class="n">nst_closest_dists</span><span class="p">[</span><span class="n">closest_soma_idx</span><span class="p">]</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_dist</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_closest_vertex_on_mesh</span><span class="p">:</span>
        <span class="n">closest_vertex</span> <span class="o">=</span> <span class="n">nst_closest_vertex</span><span class="p">[</span><span class="n">closest_soma_idx</span><span class="p">]</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_vertex</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<span class="n">width_ray_trace_default</span> <span class="o">=</span> <span class="mi">0</span>
<div class="viewcode-block" id="width_ray_trace_perc"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.width_ray_trace_perc">[docs]</a><span class="k">def</span> <span class="nf">width_ray_trace_perc</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">default_value_if_empty</span> <span class="o">=</span> <span class="n">width_ray_trace_default</span><span class="p">,</span>
    <span class="n">ray_inter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">width_ray_trace_perc_of_submesh</span><span class="p">(</span>
          <span class="n">mesh</span><span class="p">,</span>
        <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">default_value_if_empty</span> <span class="o">=</span> <span class="n">default_value_if_empty</span><span class="p">,</span>
        <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">ray_inter</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="n">width_ray_trace_median</span> <span class="o">=</span> <span class="n">width_ray_trace_perc</span>

<div class="viewcode-block" id="width_ray_trace_perc_of_submesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.width_ray_trace_perc_of_submesh">[docs]</a><span class="k">def</span> <span class="nf">width_ray_trace_perc_of_submesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">submesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">submesh_face_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">default_value_if_empty</span> <span class="o">=</span> <span class="n">width_ray_trace_default</span><span class="p">,</span>
    <span class="n">ray_inter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">ray_inter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">submesh_face_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">submesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">submesh_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">submesh_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">subemsh</span><span class="p">)</span>
        
    <span class="n">curr_width_distances</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span>
        <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">face_inds</span><span class="o">=</span><span class="n">submesh_face_idx</span><span class="p">,</span>
        <span class="n">ray_inter</span><span class="o">=</span><span class="n">ray_inter</span>
    <span class="p">)</span>
    
    <span class="n">filtered_widths</span> <span class="o">=</span> <span class="n">curr_width_distances</span><span class="p">[</span><span class="n">curr_width_distances</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_widths</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">final_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">filtered_widths</span><span class="p">,</span><span class="n">percentile</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_width</span> <span class="o">=</span> <span class="n">default_value_if_empty</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final width (# of submesh faces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">submesh_face_idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> ) = </span><span class="si">{</span><span class="n">final_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_width</span></div>

<span class="n">width_of_submesh</span> <span class="o">=</span> <span class="n">width_ray_trace_perc_of_submesh</span>
    
<div class="viewcode-block" id="widths_of_submeshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.widths_of_submeshes">[docs]</a><span class="k">def</span> <span class="nf">widths_of_submeshes</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">submeshes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value_if_empty</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span>
    <span class="n">ray_inter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">submeshes_face_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the widths of submeshes in relation </span>
<span class="sd">    to a larger mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">ray_inter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

    <span class="n">submeshes_widths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">submeshes</span><span class="p">:</span>
        <span class="n">face_indices_leftover_0</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">lm</span><span class="p">)</span>
        <span class="n">curr_width_distances</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                                  <span class="n">face_inds</span><span class="o">=</span><span class="n">face_indices_leftover_0</span><span class="p">,</span>
                                                         <span class="n">ray_inter</span><span class="o">=</span><span class="n">ray_inter</span>
                                <span class="p">)</span>
        <span class="n">filtered_widths</span> <span class="o">=</span> <span class="n">curr_width_distances</span><span class="p">[</span><span class="n">curr_width_distances</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_widths</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">submeshes_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">filtered_widths</span><span class="p">,</span><span class="n">percentile</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">submeshes_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_value_if_empty</span><span class="p">)</span>

    <span class="n">submeshes_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">submeshes_widths</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;submeshes_widths = </span><span class="si">{</span><span class="n">submeshes_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">submeshes_widths</span></div>
    
<div class="viewcode-block" id="mesh_bbox_contains_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.mesh_bbox_contains_skeleton">[docs]</a><span class="k">def</span> <span class="nf">mesh_bbox_contains_skeleton</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                <span class="n">skeleton</span><span class="p">,</span>
                               <span class="n">perc_contained_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine if a mesh bounding box contains all</span>
<span class="sd">    the points of a skeleton</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">contains_map</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">sk_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

    <span class="n">n_contained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contains_map</span><span class="p">)</span>
    <span class="n">total_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">contains_map</span><span class="p">)</span>
    <span class="n">perc_contained</span> <span class="o">=</span> <span class="n">n_contained</span><span class="o">/</span><span class="n">total_points</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_contained</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">total_points</span><span class="si">}</span><span class="s2"> total (perc = </span><span class="si">{</span><span class="n">perc_contained</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">perc_contained</span> <span class="o">&gt;=</span> <span class="n">perc_contained_threshold</span></div>
    
    
<div class="viewcode-block" id="submesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.submesh">[docs]</a><span class="k">def</span> <span class="nf">submesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">face_idx</span><span class="p">,</span><span class="n">always_return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">face_idx</span><span class="p">)],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">)</span> <span class="ow">and</span> <span class="n">always_return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_submesh</span></div>
    
<div class="viewcode-block" id="bbox_intersect_test"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.bbox_intersect_test">[docs]</a><span class="k">def</span> <span class="nf">bbox_intersect_test</span><span class="p">(</span>
    <span class="n">mesh_1</span><span class="p">,</span>
    <span class="n">mesh_2</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">mesh_1_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
    <span class="n">mesh_2_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">mesh_1_bbox_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">mesh_2_bbox_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
    <span class="n">bbox_alpha</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine if a mesh bounding box intersects</span>
<span class="sd">    another bounding box</span>

<span class="sd">    Pseducode: </span>
<span class="sd">    1) Plot the bounding boxes of the corner and the mesh</span>
<span class="sd">    2) Determine whether the two bounding boxes intersect</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    bbox_intersect_test(</span>
<span class="sd">    mesh_1=segment_mesh,</span>
<span class="sd">    mesh_2=ease_bounding_box,</span>
<span class="sd">    plot = True,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">meshes_to_plot</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_to_plot_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_alpha</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">m</span><span class="p">,</span><span class="n">m_color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">mesh_1</span><span class="p">,</span><span class="n">mesh_2</span><span class="p">],[</span><span class="n">mesh_1_color</span><span class="p">,</span><span class="n">mesh_2_color</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">meshes_to_plot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">meshes_to_plot_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_color</span><span class="p">)</span>
            <span class="n">meshes_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_alpha</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_</span><span class="si">{</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> is not mesh&quot;</span><span class="p">)</span>

    <span class="n">mesh1_bbox</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">(</span><span class="n">mesh_1</span><span class="p">)</span>
    <span class="n">mesh2_bbox</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">(</span><span class="n">mesh_2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span><span class="o">=</span><span class="n">meshes_to_plot</span> <span class="o">+</span> <span class="p">[</span><span class="n">mesh1_bbox</span><span class="p">,</span><span class="n">mesh2_bbox</span><span class="p">],</span>
            <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_to_plot_colors</span> <span class="o">+</span> <span class="p">[</span><span class="n">mesh_1_bbox_color</span><span class="p">,</span><span class="n">mesh_2_bbox_color</span><span class="p">],</span>
            <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">meshes_alpha</span> <span class="o">+</span> <span class="p">[</span><span class="n">bbox_alpha</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">axis_box_off</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="n">intersect_result</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">bbox_intersect_test_from_corners</span><span class="p">(</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh1_bbox</span><span class="p">),</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">mesh2_bbox</span><span class="p">),</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;intersect_result = </span><span class="si">{</span><span class="n">intersect_result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">intersect_result</span></div>


<span class="c1"># --------------- 2/9 -----------------</span>
<div class="viewcode-block" id="farthest_coordinate_to_faces"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.farthest_coordinate_to_faces">[docs]</a><span class="k">def</span> <span class="nf">farthest_coordinate_to_faces</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To find the coordinate who has the </span>
<span class="sd">    farthest closest distance to a mesh</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    import neurd</span>
<span class="sd">    </span>
<span class="sd">    branch_obj = neuron_obj[0][0]</span>
<span class="sd">    neurd.plot_branch_spines(branch_obj)</span>
<span class="sd">    farthest_coord = farthest_coordinate_to_faces(</span>
<span class="sd">        branch_obj.mesh,</span>
<span class="sd">        branch_obj.skeleton,</span>
<span class="sd">        return_distance = False,</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>

<span class="sd">    ipvu.plot_objects(</span>
<span class="sd">    branch_obj.mesh,</span>
<span class="sd">        branch_obj.skeleton,</span>
<span class="sd">        scatters=[farthest_coord],</span>
<span class="sd">        scatter_size=2</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">m_tree</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_kdtree_face</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">m_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="n">farthest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">farthest_coordinate</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">farthest_idx</span><span class="p">]</span>
    <span class="n">farthest_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">farthest_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Farthest coordinate = </span><span class="si">{</span><span class="n">farthest_coordinate</span><span class="si">}</span><span class="s2">,&quot;</span>
              <span class="sa">f</span><span class="s2">&quot; closest face to farthest coordinate = </span><span class="si">{</span><span class="n">farthest_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Farthest distance = </span><span class="si">{</span><span class="n">farthest_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">farthest_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closest coordinate color = </span><span class="si">{</span><span class="n">farthest_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">coordinates</span><span class="p">,</span><span class="n">farthest_coordinate</span><span class="p">],</span>
            <span class="n">scatter_size</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">farthest_dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">farthest_coordinate</span></div>

<div class="viewcode-block" id="largest_conn_comp"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.largest_conn_comp">[docs]</a><span class="k">def</span> <span class="nf">largest_conn_comp</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">connectivity</span><span class="o">=</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span>
    <span class="n">return_face_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the largest connected </span>
<span class="sd">    component of the mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_meshes</span><span class="p">,</span><span class="n">return_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">significance_threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
    <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_face_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">return_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="closest_n_attributes_to_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_n_attributes_to_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_n_attributes_to_coordinate</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    tu.closest_n_attributes_to_coordinate(</span>
<span class="sd">        branch_obj.mesh,</span>
<span class="sd">        coordinate = branch_obj.mesh_center,</span>
<span class="sd">        attribute = &quot;vertices&quot;,</span>
<span class="sd">        n = 5,</span>
<span class="sd">        plot = True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
    
    <span class="n">kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">coordinate</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">curr_attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">attribute</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">curr_attrs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">closest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)[:</span><span class="n">n</span><span class="p">]</span>
    <span class="n">closest_attrs</span> <span class="o">=</span> <span class="n">curr_attrs</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
        <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinate</span><span class="p">,</span><span class="n">closest_attrs</span><span class="p">],</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span>
        <span class="n">scatter_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_attrs</span></div>
    
<div class="viewcode-block" id="translate_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.translate_mesh">[docs]</a><span class="k">def</span> <span class="nf">translate_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">new_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">new_center</span> <span class="o">-</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        
    <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">+=</span> <span class="n">translation</span>
    <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="scatter_mesh_with_radius"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.scatter_mesh_with_radius">[docs]</a><span class="k">def</span> <span class="nf">scatter_mesh_with_radius</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to generate a mesh of spheres at certain coordinates with certain size</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">radius</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    
    <span class="n">total_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">sphere_mesh</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">radius</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">total_mesh</span></div>

<div class="viewcode-block" id="connected_components_from_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.connected_components_from_mesh">[docs]</a><span class="k">def</span> <span class="nf">connected_components_from_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">return_face_idx_map</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="n">return_value</span><span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">return_components</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_face_idx_map</span><span class="o">=</span><span class="n">return_face_idx_map</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_face_idx_map</span><span class="p">:</span>
        <span class="n">meshes</span><span class="p">,</span><span class="n">face_idx</span> <span class="o">=</span> <span class="n">return_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">return_value</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="area"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.area">[docs]</a><span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">area</span></div>

<div class="viewcode-block" id="skeleton_non_branching_from_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.skeleton_non_branching_from_mesh">[docs]</a><span class="k">def</span> <span class="nf">skeleton_non_branching_from_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate surface skeletons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meshes_conn_comp</span> <span class="o">=</span> <span class="n">connected_components_from_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">surface_skeleton</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes_conn_comp</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">skeleton</span></div>

<div class="viewcode-block" id="skeletal_length_from_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.skeletal_length_from_mesh">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_from_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeletal_length</span><span class="p">(</span><span class="n">skeleton_non_branching_from_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">))</span></div>

<div class="viewcode-block" id="width_ray"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.width_ray">[docs]</a><span class="k">def</span> <span class="nf">width_ray</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">width_ray_trace_perc</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">)</span></div>

<div class="viewcode-block" id="overlapping_vertices_from_face_lists"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.overlapping_vertices_from_face_lists">[docs]</a><span class="k">def</span> <span class="nf">overlapping_vertices_from_face_lists</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">face_lists</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the vertices shared</span>
<span class="sd">    between two arrays of face_idxs</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the intersection of the vertices (after indexing faces into vertices array)</span>
<span class="sd">    2) Index the vertices intersection into verteices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vertices_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">face_lists</span><span class="p">]</span>
    <span class="n">intersect_verts</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersect1d_multi_list</span><span class="p">(</span><span class="n">vertices_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">intersect_verts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">intersect_verts</span><span class="p">]</span></div>

<div class="viewcode-block" id="coordinate_on_mesh_mesh_border"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.coordinate_on_mesh_mesh_border">[docs]</a><span class="k">def</span> <span class="nf">coordinate_on_mesh_mesh_border</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">mesh_border</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">overlapping_vertices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh_border_minus_meshes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">meshes_to_minus</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coordinate_method</span> <span class="o">=</span> <span class="s1">&#39;first_coordinate&#39;</span><span class="p">,</span><span class="c1">#&quot;mean&quot;,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_winning_coordinate_group</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find a coordinate on the border between 2 meshes</span>
<span class="sd">    </span>
<span class="sd">    New method: </span>
<span class="sd">    1) Finds the overlapping vertices, if none then find the closest one</span>
<span class="sd">    2) Find the border vertices groups</span>
<span class="sd">    3a) If no border vertices then just picks overlapping vertices as winning group</span>
<span class="sd">    3b) Picks the border vertices groups which has a closest overall distance to any of border vertices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">mesh_border_minus_meshes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">overlapping_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">meshes_to_minus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meshes_to_minus</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">meshes_to_minus</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">meshes_to_minus</span><span class="p">)</span>
        <span class="n">meshes_to_minus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        
        <span class="n">mesh_border_minus_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span>
            <span class="n">mesh_border</span><span class="p">,</span>
            <span class="n">meshes_to_minus</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for subtract_mesh = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#1) Finds the overlapping vertices, if none then find the closest one</span>
<span class="c1">#     overlap_verts = nu.intersect2d(</span>
<span class="c1">#         mesh.vertices,</span>
<span class="c1">#         mesh_border_minus_meshes.vertices,</span>
<span class="c1">#     )</span>
    
<span class="c1">#     if verbose_time:</span>
<span class="c1">#         print(f&quot;Time for overlap_verts option 1 = {time.time() - st}&quot;)</span>
<span class="c1">#         st = time.time()</span>
    
    <span class="k">if</span> <span class="n">overlapping_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlap_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">overlapping_vertices</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">mesh_border_minus_meshes</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for overlap_verts option 2 = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap_verts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using closest mesh vertex for overlap verts&quot;</span><span class="p">)</span>
            <span class="n">overlap_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_vertex_to_other_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">mesh_border_minus_meshes</span><span class="p">,</span>
                <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for closest_mesh_vertex_to_other_mesh = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">overlap_verts</span> <span class="o">=</span> <span class="n">overlapping_vertices</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of overlap verts = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">overlap_verts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#2) Find the border vertices groups</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">vertex_groups</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertex_groups</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for find_border_vertex_groups = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">vertex_groups</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">coordinate_group</span> <span class="o">=</span> <span class="n">overlap_verts</span>
        <span class="n">winning_coordinate_group</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dist_to_overlap_group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v_g</span> <span class="ow">in</span> <span class="n">vertex_groups</span><span class="p">:</span>
            <span class="n">dist_to_overlap_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">overlap_verts</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">v_g</span><span class="p">])</span>
            <span class="p">)</span>
            
        <span class="n">winning_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_to_overlap_group</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dist_to_overlap_group = </span><span class="si">{</span><span class="n">dist_to_overlap_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Vertex group </span><span class="si">{</span><span class="n">winning_idx</span><span class="si">}</span><span class="s2"> was closest at </span><span class="si">{</span><span class="n">dist_to_overlap_group</span><span class="p">[</span><span class="n">winning_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">coordinate_group</span> <span class="o">=</span>  <span class="n">vertex_groups</span><span class="p">[</span><span class="n">winning_idx</span><span class="p">]</span>
        <span class="n">winning_coordinate_group</span> <span class="o">=</span> <span class="n">coordinate_group</span>
        
        <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for winning coordinate = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="c1">#3) Find average vertices that make up the coordinate    </span>
    <span class="k">if</span> <span class="n">coordinate_method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coordinate_group</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">coordinate_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate = </span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh_border_minus_meshes</span><span class="p">,</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="p">],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">coordinate</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">overlap_verts</span><span class="p">],</span>
            <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_winning_coordinate_group</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coordinate</span><span class="p">,</span><span class="n">winning_coordinate_group</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coordinate</span></div>
    
<div class="viewcode-block" id="connected_components_from_face_idx"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.connected_components_from_face_idx">[docs]</a><span class="k">def</span> <span class="nf">connected_components_from_face_idx</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">face_idx</span><span class="p">,</span>
    <span class="n">return_meshes</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the face_idxs</span>
<span class="sd">    of the connected components for mesh defined</span>
<span class="sd">    by face idx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">ret_meshes</span><span class="p">,</span><span class="n">return_idxs</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">submesh</span><span class="p">,</span>
        <span class="n">return_components</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span>
    
    <span class="n">return_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">face_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_idxs</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of components = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_idxs</span><span class="p">,</span><span class="n">ret_meshes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_idxs</span></div>
    
<div class="viewcode-block" id="filter_away_connected_comp_in_face_idx_with_minimum_vertex_distance_to_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.filter_away_connected_comp_in_face_idx_with_minimum_vertex_distance_to_coordinates">[docs]</a><span class="k">def</span> <span class="nf">filter_away_connected_comp_in_face_idx_with_minimum_vertex_distance_to_coordinates</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">face_idx</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">min_distance_threshold</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away any connected components</span>
<span class="sd">    that have a vertices touching at least one coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">conn_comp_idx</span><span class="p">,</span><span class="n">conn_comp_meshes</span> <span class="o">=</span> <span class="n">connected_components_from_face_idx</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">face_idx</span> <span class="o">=</span> <span class="n">face_idx</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">final_comp_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">final_comp_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">filtered_away_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">c_idx</span><span class="p">,</span><span class="n">c_mesh</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">conn_comp_idx</span><span class="p">,</span><span class="n">conn_comp_meshes</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">coord</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">min_dist</span> <span class="o">&gt;</span> <span class="n">min_distance_threshold</span><span class="p">:</span>
                <span class="n">final_comp_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_idx</span><span class="p">)</span>
                <span class="n">final_comp_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_mesh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering away connected comonent </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> because too close to coordinate </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (min_dist = </span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">filtered_away_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_mesh</span><span class="p">)</span>
                    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="n">final_comp_meshes</span> <span class="o">+</span> <span class="n">filtered_away_meshes</span><span class="p">,</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">final_comp_meshes</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_away_meshes</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_comp_idx</span><span class="p">,</span><span class="n">final_comp_meshes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_comp_idx</span></div>

<div class="viewcode-block" id="closest_mesh_attribute_to_coordinates_fast"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_attribute_to_coordinates_fast">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_attribute_to_coordinates_fast</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
    <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_attribute</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stop_after_0_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">coordinates</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;vertic&quot;</span> <span class="ow">in</span> <span class="n">attribute</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
    <span class="k">if</span> <span class="s2">&quot;face&quot;</span> <span class="ow">in</span> <span class="n">attribute</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">attribute</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stop_after_0_dist</span><span class="p">:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinates</span><span class="o">-</span><span class="n">c</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
            <span class="n">curr_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinates</span><span class="o">-</span><span class="n">c</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">curr_dist</span> <span class="o">&lt;</span> <span class="mf">0.000001</span><span class="p">:</span>
                <span class="n">curr_dist</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dist</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dist</span><span class="p">)</span>
                
    <span class="n">win_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">win_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">win_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_idx = </span><span class="si">{</span><span class="n">win_idx</span><span class="si">}</span><span class="s2"> with closest distance = </span><span class="si">{</span><span class="n">win_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_attribute</span><span class="p">:</span>
        <span class="n">win_idx</span> <span class="o">=</span> <span class="n">attr</span><span class="p">[</span><span class="n">win_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">win_idx</span><span class="p">,</span><span class="n">win_dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">win_idx</span></div>

<div class="viewcode-block" id="closest_mesh_distance_to_coordinates_fast"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_mesh_distance_to_coordinates_fast">[docs]</a><span class="k">def</span> <span class="nf">closest_mesh_distance_to_coordinates_fast</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
    <span class="n">return_attribute</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stop_after_0_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
    
    <span class="n">_</span><span class="p">,</span><span class="n">dist</span>  <span class="o">=</span> <span class="n">closest_mesh_attribute_to_coordinates_fast</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span><span class="p">,</span>
    <span class="n">return_attribute</span> <span class="o">=</span> <span class="n">return_attribute</span><span class="p">,</span>
    <span class="n">stop_after_0_dist</span> <span class="o">=</span> <span class="n">stop_after_0_dist</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="n">verbose_time</span><span class="p">,</span>
    <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="connected_component_meshes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.connected_component_meshes">[docs]</a><span class="k">def</span> <span class="nf">connected_component_meshes</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    <span class="n">return_meshes</span> <span class="o">=</span>  <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">plot</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of conn comp meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">return_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="n">return_meshes</span><span class="p">,</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_meshes</span></div>

<div class="viewcode-block" id="closest_connected_component_mesh_to_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.closest_connected_component_mesh_to_coordinates">[docs]</a><span class="k">def</span> <span class="nf">closest_connected_component_mesh_to_coordinates</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="n">closest_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_to_coordinates</span><span class="p">(</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">connected_component_meshes</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">),</span>
        <span class="n">coordinates</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">closest_mesh</span><span class="p">,</span><span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">coordinates</span><span class="p">])</span></div>
        
<div class="viewcode-block" id="faces_defined_by_vertices_idx_list_to_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.faces_defined_by_vertices_idx_list_to_mesh">[docs]</a><span class="k">def</span> <span class="nf">faces_defined_by_vertices_idx_list_to_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">faces</span><span class="p">,</span><span class="c1">#(n,3) array of vertices idx</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a mesh from </span>
<span class="sd">    an (n,3) array representing new faces</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">vertices</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">unique_verts</span><span class="p">,</span><span class="n">inv_faces</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span>
        <span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">[</span><span class="n">unique_verts</span><span class="p">],</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">inv_faces</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_mesh = </span><span class="si">{</span><span class="n">new_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">new_mesh</span></div>


<div class="viewcode-block" id="stitch"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.stitch">[docs]</a><span class="k">def</span> <span class="nf">stitch</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">insert_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">calculate_normals</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">vertices_to_stitch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_mesh_with_holes_stitched</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a fan stitch over the boundary of the specified</span>
<span class="sd">    faces. If the boundary is non-convex a triangle fan</span>
<span class="sd">    is going to be extremely wonky.</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    vertices : (n, 3) float</span>
<span class="sd">      Vertices in space.</span>
<span class="sd">    faces : (n,) int</span>
<span class="sd">      Face indexes to stitch with triangle fans.</span>
<span class="sd">    insert_vertices : bool</span>
<span class="sd">      Allow stitching to insert new vertices?</span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    fan : (m, 3) int</span>
<span class="sd">      New triangles referencing mesh.vertices.</span>
<span class="sd">    vertices : (p, 3) float</span>
<span class="sd">      Inserted vertices (only returned `if insert_vertices`)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

    <span class="c1"># get a sequence of vertex indices representing the</span>
    <span class="c1"># boundary of the specified faces</span>
    <span class="c1"># will be referencing the same indexes of `mesh.vertices`</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span>
              <span class="n">faces_to_path</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">faces</span><span class="p">)[</span><span class="s1">&#39;entities&#39;</span><span class="p">]</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span>
              <span class="n">e</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">points_unfiltered</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span>
              <span class="n">faces_to_path</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">faces</span><span class="p">)[</span><span class="s1">&#39;entities&#39;</span><span class="p">]</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;points_unfiltered = </span><span class="si">{</span><span class="n">points_unfiltered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;points = </span><span class="si">{</span><span class="n">points</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertices_to_stitch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span> <span class="k">if</span>
                 <span class="n">nu</span><span class="o">.</span><span class="n">closest_dist_between_coordinates</span><span class="p">(</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">p</span><span class="p">],</span>
                        <span class="n">vertices_to_stitch</span>
                 <span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.000001</span><span class="p">]</span>

    
    <span class="c1"># get properties to avoid querying in loop</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_normals</span>

    <span class="c1"># find which faces are associated with an edge</span>
    <span class="n">edges_face</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_face</span>
    <span class="n">tree_edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_sorted_tree</span>

    <span class="k">if</span> <span class="n">insert_vertices</span><span class="p">:</span>
        <span class="c1"># create one new vertex per curve at the centroid</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vertices</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
        <span class="c1"># save the original length of the vertices</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="c1"># for the normal check stack our local vertices</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">vertices</span><span class="p">,</span> <span class="n">centroids</span><span class="p">))</span>
        <span class="c1"># create a triangle between our new centroid vertex</span>
        <span class="c1"># and each one of the boundary curves</span>
        <span class="n">fan</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
            <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># since we&#39;re not allowed to insert new vertices</span>
        <span class="c1"># create a triangle fan for each boundary curve</span>
        <span class="n">fan</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fan = </span><span class="si">{</span><span class="n">fan</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">calculate_normals</span><span class="p">:</span>
        <span class="c1"># now we do a normal check against an adjacent face</span>
        <span class="c1"># to see if each region needs to be flipped</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fan</span><span class="p">)),</span> <span class="n">points</span><span class="p">,</span> <span class="n">fan</span><span class="p">):</span>
            <span class="c1"># get the edges from the original mesh</span>
            <span class="c1"># for the first `n` new triangles</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">t</span><span class="p">[:</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">e</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># find which indexes of `mesh.edges` these</span>
            <span class="c1"># new edges correspond with by finding edges</span>
            <span class="c1"># that exactly correspond with the tree</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">tree_edge</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># stack all the indices that exist</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

            <span class="c1"># get the normals from the original mesh</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="n">edges_face</span><span class="p">[</span><span class="n">edge_index</span><span class="p">]]</span>

            <span class="c1"># calculate the normals for a few new faces</span>
            <span class="c1">#print(f&quot;vertices = {vertices}&quot;)</span>
            <span class="c1">#print(f&quot;vertices[t[:3]] = {vertices[t[:3]]}&quot;)</span>
            <span class="n">check</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">triangles</span><span class="o">.</span><span class="n">normals</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">t</span><span class="p">[:</span><span class="mi">3</span><span class="p">]])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="c1"># take the first valid normal from our new faces</span>
            <span class="c1">#print(f&quot;check = {check}&quot;)</span>
            <span class="c1">#print(f&quot;valid = {valid}&quot;)</span>
            <span class="c1">#check = check[valid][0]</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">check</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if our new faces are reversed from the original</span>
            <span class="c1"># Adjacent face flip them along their axis</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">check</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sign</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fan</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">fan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mesh</span> <span class="ow">or</span> <span class="n">plot</span> <span class="ow">or</span> <span class="n">return_mesh_with_holes_stitched</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fan</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">faces_defined_by_vertices_idx_list_to_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">fan</span><span class="p">,</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="n">centroids</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">empty_mesh</span><span class="p">()</span>
            
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_mesh</span><span class="p">],</span><span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_mesh_with_holes_stitched</span><span class="p">:</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">mesh</span><span class="p">,</span><span class="n">new_mesh</span><span class="p">])</span>
        <span class="n">new_mesh</span><span class="o">.</span><span class="n">fix_normals</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_mesh</span>
        
    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="n">fan</span> <span class="o">=</span> <span class="n">new_mesh</span> 
    
    <span class="k">if</span> <span class="n">insert_vertices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fan</span><span class="p">,</span> <span class="n">centroids</span>
    <span class="k">return</span> <span class="n">fan</span></div>

<span class="n">close_mesh_holes</span> <span class="o">=</span> <span class="n">stitch</span>

<div class="viewcode-block" id="stitch_mesh_at_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.stitch_mesh_at_vertices">[docs]</a><span class="k">def</span> <span class="nf">stitch_mesh_at_vertices</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">vertices</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the mesh that would</span>
<span class="sd">    stitch up a certain boundary defined</span>
<span class="sd">    by vertices</span>
<span class="sd">    </span>
<span class="sd">    Process: </span>
<span class="sd">    1) Run stitching with certain vertices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span>  <span class="n">tu</span><span class="o">.</span><span class="n">stitch</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">vertices_to_stitch</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">,</span>
        <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new mesh = </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">vertices</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">m</span></div>

<span class="n">close_mesh_holes_at_vertices</span> <span class="o">=</span> <span class="n">stitch_mesh_at_vertices</span>
<span class="n">divide_mesh_into_connected_components</span> <span class="o">=</span> <span class="n">connected_components_from_mesh</span>

<div class="viewcode-block" id="area_of_vertex_boundary"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.area_of_vertex_boundary">[docs]</a><span class="k">def</span> <span class="nf">area_of_vertex_boundary</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">vertices</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the area of a</span>
<span class="sd">    vertex boundary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stitch_m</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">close_mesh_holes_at_vertices</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">stitch_m</span><span class="o">.</span><span class="n">area</span></div>

<div class="viewcode-block" id="fill_single_triangle_holes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.fill_single_triangle_holes">[docs]</a><span class="k">def</span> <span class="nf">fill_single_triangle_holes</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">trimesh</span><span class="o">.</span><span class="n">repair</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="fill_mesh_holes_with_fan"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.fill_mesh_holes_with_fan">[docs]</a><span class="k">def</span> <span class="nf">fill_mesh_holes_with_fan</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">try_with_fill_single_hole_fill_for_backup</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="n">stitch</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">return_mesh_with_holes_stitched</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">(</span><span class="n">return_mesh</span><span class="p">)</span> <span class="ow">and</span> <span class="n">try_with_fill_single_hole_fill_for_backup</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">trimesh</span><span class="o">.</span><span class="n">repair</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">return_mesh</span> <span class="o">=</span> <span class="n">stitch</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_mesh_with_holes_stitched</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original mesh = </span><span class="si">{</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled Holes mesh = </span><span class="si">{</span><span class="n">return_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_mesh</span></div>

<span class="n">fill_mesh_holes</span> <span class="o">=</span> <span class="n">fill_mesh_holes_with_fan</span>
<span class="n">stitch_mesh_holes</span> <span class="o">=</span> <span class="n">fill_mesh_holes_with_fan</span>

<div class="viewcode-block" id="close_hole_areas"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.close_hole_areas">[docs]</a><span class="k">def</span> <span class="nf">close_hole_areas</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sort_type</span> <span class="o">=</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the aresa of all</span>
<span class="sd">    conn components needed for closing holes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh_to_stitch</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">close_mesh_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_to_stitch</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mesh_to_stitch_conn_comp</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">connected_components_from_mesh</span><span class="p">(</span><span class="n">mesh_to_stitch</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_to_stitch_conn_comp</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_to_stitch_conn_comp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stitch_meshes_area</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No meshes needed for closing hole&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stitch_meshes_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_to_stitch_conn_comp</span><span class="p">])</span>

        <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">stitch_meshes_area</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort_type</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">sort_idx</span><span class="p">)</span>
            
        <span class="n">stitch_meshes_area</span> <span class="o">=</span> <span class="n">stitch_meshes_area</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>
        <span class="n">mesh_to_stitch_conn_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_to_stitch_conn_comp</span><span class="p">)[</span><span class="n">sort_idx</span><span class="p">]</span>
    
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stitch_meshes_area= </span><span class="si">{</span><span class="n">stitch_meshes_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stitch_meshes_area</span><span class="p">,</span><span class="n">mesh_to_stitch_conn_comp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stitch_meshes_area</span></div>

<div class="viewcode-block" id="close_hole_area_top_k_extrema"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.close_hole_area_top_k_extrema">[docs]</a><span class="k">def</span> <span class="nf">close_hole_area_top_k_extrema</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">extrema</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span>
    <span class="n">aggr_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">fill_to_meet_length</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">def</span> <span class="nf">dummy_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aggr_func</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">aggr_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">aggr_func</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">aggr_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aggr_func</span> <span class="o">=</span> <span class="n">dummy_func</span>
    
    <span class="n">stitch_meshes_area</span><span class="p">,</span><span class="n">mesh_to_stitch_conn_comp</span> <span class="o">=</span> <span class="n">close_hole_areas</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">return_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">sort_type</span><span class="o">=</span><span class="n">extrema</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stitch_meshes_area</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stitch_extrema_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()]</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
        <span class="n">stitch_extrema</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">default_value</span><span class="p">]</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="n">stitch_extrema</span> <span class="o">=</span> <span class="n">stitch_meshes_area</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
        <span class="n">stitch_extrema_meshes</span> <span class="o">=</span> <span class="n">mesh_to_stitch_conn_comp</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extrema</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">stitch_extrema</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stitch_extrema_meshes</span><span class="p">),</span>
                <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stitch_extrema</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">fill_to_meet_length</span><span class="p">:</span>
        <span class="n">stitch_extrema</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">stitch_meshes_area</span><span class="p">,[</span><span class="n">default_value</span><span class="p">]</span><span class="o">*</span><span class="n">k</span><span class="p">])[:</span><span class="n">k</span><span class="p">]</span>
        <span class="n">stitch_extrema_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">stitch_extrema_meshes</span><span class="p">,[</span><span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()]</span><span class="o">*</span><span class="n">k</span><span class="p">])[:</span><span class="n">k</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stitch_extrema </span><span class="si">{</span><span class="n">extrema</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">stitch_extrema</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_to_stitch_conn_comp </span><span class="si">{</span><span class="n">extrema</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">stitch_extrema_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">stitch_extrema</span> <span class="o">=</span> <span class="n">aggr_func</span><span class="p">(</span><span class="n">stitch_extrema</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stitch_extrema</span><span class="p">,</span><span class="n">stitch_extrema_meshes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stitch_extrema</span></div>
    
<div class="viewcode-block" id="close_hole_area_max"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.close_hole_area_max">[docs]</a><span class="k">def</span> <span class="nf">close_hole_area_max</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="n">val</span><span class="p">,</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">close_hole_area_top_k_extrema</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">extrema</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="close_hole_area_top_2_mean"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.close_hole_area_top_2_mean">[docs]</a><span class="k">def</span> <span class="nf">close_hole_area_top_2_mean</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="n">val</span><span class="p">,</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">close_hole_area_top_k_extrema</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">extrema</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="n">aggr_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">aggr_func</span><span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">aggr_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>

<div class="viewcode-block" id="stats_df"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.stats_df">[docs]</a><span class="k">def</span> <span class="nf">stats_df</span><span class="p">(</span>
    <span class="n">meshes</span><span class="p">,</span>
    <span class="n">functions</span><span class="p">,</span>
    <span class="n">suppress_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Given a list of meshes</span>
<span class="sd">    and a list of functions that can be applied</span>
<span class="sd">    to mesh, want to compute a dataframe</span>
<span class="sd">    that stores the output of all the functions for</span>
<span class="sd">    each mesh in rows of a dataframe</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each mesh:</span>
<span class="sd">        For each function:</span>
<span class="sd">            Compute the value</span>
<span class="sd">            Store in a dictionary</span>

<span class="sd">    Create pandas dataframe</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">functions_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">functions_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tu</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">functions_dict</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">empty_df</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">df</span>
    
    <span class="n">total_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">:</span>
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">f_func</span> <span class="ow">in</span> <span class="n">functions_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">f_func</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">suppress_errors</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">default_value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">total_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">)</span>
        
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">total_dicts</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>
            
        <span class="n">df_cp</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_cp</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">mu</span><span class="o">.</span><span class="n">histograms_overlayed</span><span class="p">(</span><span class="n">df_cp</span><span class="p">,</span><span class="n">column</span><span class="o">=</span><span class="n">c</span><span class="p">,</span><span class="n">hue</span> <span class="o">=</span> <span class="s2">&quot;label&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="query_meshes_from_restrictions"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.trimesh_utils.query_meshes_from_restrictions">[docs]</a><span class="k">def</span> <span class="nf">query_meshes_from_restrictions</span><span class="p">(</span>
    <span class="n">meshes</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">stats_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">print_stats_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">functions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purposse: To query a list of meshes using </span>
<span class="sd">    a query string or list of conditions and</span>
<span class="sd">    functions computed on the meshes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">stats_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stats_df</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">stats_df</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span><span class="n">functions</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_stats_df</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">display</span><span class="p">(</span><span class="n">stats_df</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">stats_df</span><span class="p">)</span>
    
    <span class="n">query</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query_str</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="n">table_type</span><span class="o">=</span><span class="s2">&quot;pandas&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;query = </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">restr_df</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of entries after query = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">restr_df</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">stats_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">restr_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">return_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">meshes</span><span class="p">),</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="n">return_meshes</span><span class="p">,</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_meshes</span></div>
    
    
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">mesh_utils</span> <span class="k">as</span> <span class="n">meshu</span>
<span class="n">clear_mesh_cache</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">clear_mesh_cache</span>
<span class="n">clear_all_mesh_cache_in_nested_data_struct</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">clear_all_mesh_cache_in_nested_data_struct</span>
        
        
<span class="n">query_meshes_from_stats</span> <span class="o">=</span> <span class="n">query_meshes_from_restrictions</span>
<span class="n">restrict_meshes_from_stats</span> <span class="o">=</span> <span class="n">query_meshes_from_restrictions</span>


<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">compartment_utils</span> <span class="k">as</span> <span class="n">cu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>

<span class="c1">#--- from machine_learning_tools ---</span>
<span class="kn">from</span> <span class="nn">machine_learning_tools</span> <span class="kn">import</span> <span class="n">dimensionality_reduction_utils</span> <span class="k">as</span> <span class="n">dru</span>

<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>