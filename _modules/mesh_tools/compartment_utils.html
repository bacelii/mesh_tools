<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mesh_tools.compartment_utils &mdash; mesh_tools  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            mesh_tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">mesh_tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mesh_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mesh_tools.compartment_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mesh_tools.compartment_utils</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>


<div class="viewcode-block" id="get_skeletal_distance_no_skipping"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.get_skeletal_distance_no_skipping">[docs]</a><span class="k">def</span> <span class="nf">get_skeletal_distance_no_skipping</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span>
                                 <span class="n">buffer</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                <span class="n">bbox_ratio</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                               <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                                      <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">edge_loop_print</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">stitch_patches</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="c1">#30,</span>
                                      <span class="n">significant_sub_components</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                                     <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                                     <span class="n">fast_mesh_split</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the histogram of distances along a mesh subtraction process</span>
<span class="sd">    so that we could evenutally find an adaptive distance threshold</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(f&quot;distance_by_mesh_center = {distance_by_mesh_center}&quot;)</span>
    <span class="n">main_mesh_bbox_restricted</span> <span class="o">=</span> <span class="n">main_mesh</span>
    <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">face_subtract_indices</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="n">total_distances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_distances_std</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#for i,ex_edge in tqdm(enumerate(edges)):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ex_edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
        <span class="c1">#print(&quot;\n------ New loop ------&quot;)</span>
        <span class="c1">#print(ex_edge)</span>
        
        <span class="c1"># ----------- creating edge and checking distance ----- #</span>
        <span class="n">loop_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">edge_line</span> <span class="o">=</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sum_threshold</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">edge_line</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">sum_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge number </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ex_edge</span><span class="si">}</span><span class="s2">: has sum less than </span><span class="si">{</span><span class="n">sum_threshold</span><span class="si">}</span><span class="s2"> so skipping&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
        <span class="n">cob_edge</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">change_basis_matrix</span><span class="p">(</span><span class="n">edge_line</span><span class="p">)</span>
        
        <span class="c1">#get the limits of the example edge itself that should be cutoff</span>
        <span class="n">edge_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">cob_edge</span><span class="nd">@ex_edge</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1">#slice_range = np.sort((cob_edge@ex_edge.T)[2,:])</span>
        <span class="n">slice_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span>

        <span class="c1"># adding the buffer to the slice range</span>
        <span class="n">slice_range_buffer</span> <span class="o">=</span> <span class="n">slice_range</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">buffer</span><span class="p">,</span><span class="n">buffer</span><span class="p">])</span>

        <span class="c1"># generate face midpoints from the triangles</span>
        <span class="c1">#face_midpoints = np.mean(main_mesh_bbox_restricted.vertices[main_mesh_bbox_restricted.faces],axis=1) # Old way</span>
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">triangles_center</span>
        
        
        <span class="c1">#get the face midpoints that fall within the slice (by lookig at the z component)</span>
        <span class="n">fac_midpoints_trans</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@face_midpoints</span><span class="o">.</span><span class="n">T</span>
        
        <span class="n">slice_mask_pre_distance</span> <span class="o">=</span> <span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&gt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                      <span class="p">(</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&lt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edge_trans</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">distance_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">edge_midpoint</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span>
        
        <span class="n">slice_mask</span> <span class="o">=</span> <span class="n">slice_mask_pre_distance</span> <span class="o">&amp;</span> <span class="n">distance_check</span>
        
        <span class="n">face_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">faces</span><span class="p">))[</span><span class="n">slice_mask</span><span class="p">]</span>

        <span class="c1">#get the submesh of valid faces within the slice</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_list</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="c1">#print(f&quot;total_distances = {total_distances}&quot;)</span>
            <span class="n">total_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">total_distances_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;THERE WERE NO FACES THAT FIT THE DISTANCE (</span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2">) and Z transform requirements&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;So just skipping this edge&quot;</span><span class="p">)</span>
            <span class="k">continue</span>


        <span class="c1">#get all disconnected mesh pieces of the submesh and the face indices for lookup later</span>
        <span class="n">sub_components</span><span class="p">,</span><span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
       
        
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1">#print(f&quot;meshes = {sub_components}, with type = {type(sub_components)}&quot;)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">())</span> <span class="p">:</span>
                <span class="n">sub_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_components</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The sub_components were not an array, list or trimesh&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">significant_sub_components</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sub_components_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub_components_face_indexes</span><span class="p">])</span>
            <span class="n">sub_components_sig_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sub_components_len</span><span class="o">&gt;=</span><span class="n">significant_sub_components</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_components_sig_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sub_components</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">sub_components_sig_idx</span><span class="p">]</span>
                <span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">sub_components_sig_idx</span><span class="p">]</span>
<span class="c1">#                 sub_components_sig = [sub_components[k] for k in sub_components_sig_idx]</span>
<span class="c1">#                 sub_components_face_indexes_sig = [sub_components_face_indexes[k] for k in sub_components_sig_idx]</span>
                
<span class="c1">#                 sub_components = sub_components_sig</span>
<span class="c1">#                 sub_components_face_indexes = sub_components_face_indexes_sig</span>

        <span class="c1">#getting the indices of the submeshes whose bounding box contain the edge </span>
        <span class="c1">#su.compressed_pickle(sub_components,&quot;sub_components_debug&quot;)</span>
        <span class="c1">#su.compressed_pickle(ex_edge,&quot;ex_edge&quot;)</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        %/9 Edit that hopes to reduce the times runs into segmentation fault by doing the contains method</span>
<span class="sd">        in trimesh function</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#contains_points_results = np.array([s_comp.bounding_box.contains(ex_edge.reshape(-1,3)) for s_comp in sub_components])</span>
        <span class="n">contains_points_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">check_coordinates_inside_bounding_box</span><span class="p">(</span><span class="n">s_comp</span><span class="p">,</span>
                                                                                     <span class="n">ex_edge</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                                                                                    <span class="n">return_inside_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">s_comp</span> <span class="ow">in</span> <span class="n">sub_components</span><span class="p">])</span>
        
        <span class="n">containing_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)))[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contains_points_results</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Not exactly one containing mesh: </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sub_components_inner</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">]</span>
                    <span class="n">sub_components_face_indexes_inner</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sub_components_inner</span> <span class="o">=</span> <span class="n">sub_components</span>
                    <span class="n">sub_components_face_indexes_inner</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span>

                <span class="c1">#get the center of the edge</span>
                <span class="n">edge_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#print(f&quot;edge_center = {edge_center}&quot;)</span>

                <span class="c1">#find the distance between eacch bbox center and the edge center</span>
                <span class="n">bbox_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub_components_inner</span><span class="p">]</span>
                <span class="c1">#print(f&quot;bbox_centers = {bbox_centers}&quot;)</span>
                <span class="n">closest_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">edge_center</span><span class="o">-</span><span class="n">b_center</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_center</span> <span class="ow">in</span> <span class="n">bbox_centers</span><span class="p">])</span>
                <span class="c1">#print(f&quot;bbox_distance = {closest_bbox}&quot;)</span>
                <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes_inner</span><span class="p">[</span><span class="n">closest_bbox</span><span class="p">]]]</span>


            <span class="k">else</span><span class="p">:</span><span class="c1"># when only one viable submesh piece and just using that sole index</span>
                <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components = </span><span class="si">{</span><span class="n">sub_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;containing_indices = </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components_face_indexes (from the split) = </span><span class="si">{</span><span class="n">sub_components_face_indexes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error occured&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;****** Warning the edge index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: had no faces in the edge_skeleton_faces*******&quot;</span><span class="p">)</span>
        <span class="n">face_subtract_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span>
        
        
        <span class="c1">#---- calculating the relevant distances ---- #</span>
        
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)[</span><span class="n">edge_skeleton_faces</span><span class="p">]</span>
        <span class="c1">#print(f&quot;edge_skeleton_faces.shape = {edge_skeleton_faces.shape}&quot;)</span>
<span class="c1">#         print(f&quot;cob_edge = {cob_edge}&quot;)</span>
<span class="c1">#         print(f&quot;face_midpoints = {face_midpoints.shape}&quot;)</span>
<span class="c1">#         print(f&quot;sub_components = {sub_components}&quot;)</span>
<span class="c1">#         print(f&quot;containing_indices = {containing_indices}&quot;)</span>
<span class="c1">#         print(f&quot;sub_components_face_indexes (from the split) = {sub_components_face_indexes}&quot;)</span>
        <span class="c1">#Exception(&quot;failed on fac_midpoints_trans&quot;)</span>
        
        <span class="n">fac_midpoints_trans</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@face_midpoints</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c1"># Will use the mesh center when calculating the distance</span>
        <span class="k">if</span> <span class="n">distance_by_mesh_center</span><span class="p">:</span> 
            <span class="n">faces_submesh</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">edge_skeleton_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">faces_submesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">faces_submesh</span><span class="p">)</span>
            <span class="n">faces_submesh_center</span> <span class="o">=</span> <span class="n">faces_submesh_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(f&quot;cob_edge.shape = {cob_edge.shape}, faces_submesh_center.shape={faces_submesh_center.shape}&quot;)</span>
            <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@faces_submesh_center</span>
            <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">edge_midpoint</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1">#print(f&quot;fac_midpoints_trans.shape = {fac_midpoints_trans.shape}&quot;)</span>
        <span class="n">mesh_slice_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">edge_midpoint</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#print(f&quot;mesh_slice_distances.shape = {mesh_slice_distances.shape}&quot;)</span>
        
        <span class="n">total_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mesh_slice_distances</span><span class="p">))</span>
        <span class="n">total_distances_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mesh_slice_distances</span><span class="p">))</span>
    
    
    <span class="c1">#end of the edge loops</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">all_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span>

        <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_removed_faces</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;face_subtract_indices = </span><span class="si">{</span><span class="n">face_subtract_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance of skeleton = </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">stitch_patches</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; ---- 9/28 Addition: Want to fill in the holes that will be filled in later</span>
<span class="sd">            with waterfilling algorithm </span>

<span class="sd">            Pseudocode: </span>
<span class="sd">            -1) Cheuck that there were actually eliminated faces</span>
<span class="sd">            0) Get the border vertices for all of the kept_mesh and </span>
<span class="sd">            map them to the main mesh</span>

<span class="sd">            1) Find Part of mesh that is not in the faces that could </span>
<span class="sd">            possibly be included in the mesh correspondence (eliminated_mesh)</span>

<span class="sd">            2) Divide the eliminated_mesh into split pieces</span>


<span class="sd">            3) For each split pieces of the eliminated_mesh</span>
<span class="sd">            a. Get the border vertices</span>
<span class="sd">            b. Map to the main mesh</span>
<span class="sd">            c. Take these border vertices and take boolean difference with kept_mesh border vertices</span>
<span class="sd">            d. If list is empty then add the split face indexes to the kept_mesh faces</span>

<span class="sd">            4) Continue with rest of processing</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1">#-1) Cheuck that there were actually eliminated faces</span>
            <span class="n">eliminated_mesh_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">unique_removed_faces</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eliminated_mesh_faces_idx</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            

                <span class="c1">#0) Get the border vertices for all of the kept_mesh and </span>
                <span class="c1">#map them to the main mesh</span>
                <span class="n">kept_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">unique_removed_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">kept_mesh_splits</span><span class="p">,</span><span class="n">kept_mesh_splits_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">kept_mesh</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
                <span class="n">kept_border_verts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">km</span> <span class="ow">in</span> <span class="n">kept_mesh_splits</span><span class="p">:</span>
                    <span class="n">curr_border_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertices</span><span class="p">(</span><span class="n">km</span><span class="p">)</span>
                    <span class="n">kept_border_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_vertices_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">vertices_coordinates</span><span class="o">=</span><span class="n">km</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">curr_border_verts</span><span class="p">]))</span>

                <span class="n">total_kept_border_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">kept_border_verts</span><span class="p">)</span>


                <span class="c1">#1) Find Part of mesh that is not in the faces that could </span>
                <span class="c1">#possibly be included in the mesh correspondence (eliminated_mesh)</span>

                <span class="n">eliminated_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">eliminated_mesh_faces_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span> <span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1">#2) Divide the eliminated_mesh into split pieces</span>
                <span class="n">elim_mesh_splits</span><span class="p">,</span><span class="n">elim_mesh_splits_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">eliminated_mesh</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

                <span class="c1"># 3) For each split pieces of the eliminated_mesh</span>
                <span class="c1"># a. Get the border vertices</span>
                <span class="c1"># b. Map to the main mesh</span>
                <span class="c1"># c. Take these border vertices and take boolean difference with kept_mesh border vertices</span>
                <span class="c1"># d. If list is empty then add the split face indexes to the kept_mesh faces</span>
                <span class="n">final_faces_with_stitching</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_removed_faces</span><span class="p">]</span>
                <span class="n">meshes_to_stitch</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">e_mesh</span><span class="p">,</span><span class="n">e_mesh_face_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">elim_mesh_splits</span><span class="p">,</span><span class="n">elim_mesh_splits_idx</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">stitch_patches</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> not stitched because face size (</span><span class="si">{</span><span class="n">e_mesh</span><span class="si">}</span><span class="s2">) &gt; </span><span class="si">{</span><span class="n">stitch_patches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="c1"># a. Get the border vertices</span>
                    <span class="n">curr_border_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertices</span><span class="p">(</span><span class="n">e_mesh</span><span class="p">)</span>
                    <span class="n">original_bord_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_vertices_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">vertices_coordinates</span><span class="o">=</span><span class="n">e_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">curr_border_verts</span><span class="p">])</span>
                    <span class="n">not_cancelled_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">original_bord_verts</span><span class="p">,</span><span class="n">total_kept_border_verts</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_cancelled_verts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">final_faces_with_stitching</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eliminated_mesh_faces_idx</span><span class="p">[</span><span class="n">e_mesh_face_idx</span><span class="p">])</span>
                        <span class="n">meshes_to_stitch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_mesh</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> Not stitched because not_cancelled_verts = </span><span class="si">{</span><span class="n">not_cancelled_verts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">unique_removed_faces_revised</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">final_faces_with_stitching</span><span class="p">))</span>
                <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces_revised</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot; ------------------ END OF 9/28 ADDITION -------------------&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fast_mesh_split</span><span class="p">:</span>
            <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">unique_removed_faces</span><span class="p">],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------- Starting new trial --------------------&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh.faces.shape = </span><span class="si">{</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh.faces.shape = </span><span class="si">{</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces.shape = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(unique_removed_faces) = </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">split_meshes</span><span class="p">,</span><span class="n">components_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">current_random_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After the split has been called&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_meshes = </span><span class="si">{</span><span class="n">split_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;components_faces = </span><span class="si">{</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">components_faces</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">main_mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">.off&quot;</span><span class="p">)</span>
                <span class="n">new_submesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">.off&quot;</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces_</span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.npz&quot;</span><span class="p">,</span><span class="n">unique_removed_faces</span><span class="o">=</span><span class="n">unique_removed_faces</span><span class="p">)</span>


             <span class="c1">#don&#39;t just want to take the biggest mesh: but want to take the one that has the most of the skeleton</span>
            <span class="c1">#piece corresponding to it</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) turn all of the mesh edge_skeleton_faces into meshes, have the main mesh be the whole mesh and </span>
<span class="sd">            have each of the mesh pieces be a central piece</span>
<span class="sd">            2) Call the mesh_pieces_connectivity function and see how many of the periphery pieces are touching each of the submehses</span>
<span class="sd">            3) Pick the mesh that has the most </span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 


                <span class="n">branch_touching_number</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1">#getting the mesh correspondence for each skeleton segment</span>
                <span class="n">branch_correspondence_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">face_subtract_indices</span><span class="p">]</span>
                <span class="c1">#Out of all the submesh splits, see how many of the segment mesh correspondence it is touching</span>
                <span class="k">for</span> <span class="n">curr_central_piece</span> <span class="ow">in</span> <span class="n">split_meshes</span><span class="p">:</span>
                    <span class="n">touching_periphery_pieces</span> <span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span>
                                                <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">new_submesh</span><span class="p">,</span>
                                                <span class="n">central_piece</span> <span class="o">=</span> <span class="n">curr_central_piece</span><span class="p">,</span>
                                                <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">branch_correspondence_meshes</span><span class="p">,</span>
                                                <span class="n">return_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="p">)</span>
                    <span class="n">branch_touching_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">touching_periphery_pieces</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_touching_number = </span><span class="si">{</span><span class="n">branch_touching_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#CONCLUSION: find the submesh split piece that is touching the most skeleton segment mesh correspondences (winning mesh)</span>
                <span class="n">most_branch_containing_piece</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">branch_touching_number</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;most_branch_containing_piece = </span><span class="si">{</span><span class="n">most_branch_containing_piece</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#Make this the </span>


                <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="n">most_branch_containing_piece</span><span class="p">]</span>
                <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces</span><span class="p">[</span><span class="n">components_faces</span><span class="p">[</span><span class="n">most_branch_containing_piece</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh.faces.shape = </span><span class="si">{</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reassigning new_submesh to one of many sub pieces&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh.faces.shape = </span><span class="si">{</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces.shape = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(unique_removed_faces) = </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces</span><span class="p">[</span><span class="n">components_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh.faces.shape = </span><span class="si">{</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assigning submesh to the only submesh&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh.faces.shape = </span><span class="si">{</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces.shape = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(unique_removed_faces) = </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The split meshes in the mesh correspondence was 0 length&quot;</span><span class="p">)</span>
        
        <span class="c1">#need to further restric the unique_removed_faces to those of most significant piece</span>
        <span class="k">else</span><span class="p">:</span> 
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            12/17 Addition that does a faster spliting of the mesh</span>
<span class="sd">            </span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            1) Find the largest connected component of the face_subtract_indices groups</span>
<span class="sd">            2) Get the face indices for all those in the group</span>
<span class="sd">            3) Get a submesh of that</span>
<span class="sd">            4) Split the submesh into largest conneted component</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1">#1) Find the largest connected component of the face_subtract_indices groups</span>
            
            <span class="n">conn_face_components</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersecting_array_components</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">,</span><span class="n">sort_components</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">conn_comps_lenghts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_face_components</span><span class="p">])</span>
            <span class="n">max_len_components_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conn_comps_lenghts</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">conn_comps_lenghts</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1">#2) Get the face indices for all those in the group</span>
            <span class="n">max_len_components_unique_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">face_subtract_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> 
                                                                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_face_components</span><span class="p">[</span><span class="n">cmp_idx</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">cmp_idx</span> <span class="ow">in</span>  <span class="n">max_len_components_idx</span><span class="p">]</span>
            <span class="n">unique_removed_faces_pre</span> <span class="o">=</span> <span class="n">max_len_components_unique_faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">max_len_components_unique_faces</span><span class="p">])]</span>
            
            <span class="c1">#3) Get a submesh of that</span>
            <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">unique_removed_faces_pre</span><span class="p">],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">split_meshes</span><span class="p">,</span><span class="n">components_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            
            <span class="c1">#4) Split the submesh into largest conneted component</span>
            <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces_pre</span><span class="p">[</span><span class="n">components_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()</span>
 
    
    
    <span class="k">return</span> <span class="n">total_distances</span><span class="p">,</span><span class="n">total_distances_std</span><span class="p">,</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_skeletal_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.get_skeletal_distance">[docs]</a><span class="k">def</span> <span class="nf">get_skeletal_distance</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span>
                                 <span class="n">buffer</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                <span class="n">bbox_ratio</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                               <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                               <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">edge_loop_print</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">stitch_patches</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="c1">#50,</span>
                         <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                         <span class="n">fast_mesh_split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">significant_sub_components</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the histogram of distances along a mesh subtraction process</span>
<span class="sd">    so that we could evenutally find an adaptive distance threshold</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#print(f&quot;INSIDE GET SKELETAL DISTANCE distance_by_mesh_center = {distance_by_mesh_center}&quot;)</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>

    
    <span class="n">main_mesh_bbox_restricted</span> <span class="o">=</span> <span class="n">main_mesh</span>
    <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">face_subtract_indices</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="n">total_distances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_distances_std</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#for i,ex_edge in tqdm(enumerate(edges)):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ex_edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
        <span class="c1">#print(&quot;\n------ New loop ------&quot;)</span>
        <span class="c1">#print(ex_edge)</span>
        
        <span class="c1"># ----------- creating edge and checking distance ----- #</span>
        <span class="n">loop_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">edge_line</span> <span class="o">=</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sum_threshold</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">edge_line</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">sum_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge number </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ex_edge</span><span class="si">}</span><span class="s2">: has sum less than </span><span class="si">{</span><span class="n">sum_threshold</span><span class="si">}</span><span class="s2"> so skipping&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        
        <span class="n">cob_edge</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">change_basis_matrix</span><span class="p">(</span><span class="n">edge_line</span><span class="p">)</span>
        
        <span class="c1">#get the limits of the example edge itself that should be cutoff</span>
        <span class="n">edge_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">cob_edge</span><span class="nd">@ex_edge</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1">#slice_range = np.sort((cob_edge@ex_edge.T)[2,:])</span>
        <span class="n">slice_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span>

        <span class="c1"># adding the buffer to the slice range</span>
        <span class="n">slice_range_buffer</span> <span class="o">=</span> <span class="n">slice_range</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">buffer</span><span class="p">,</span><span class="n">buffer</span><span class="p">])</span>

        <span class="c1"># generate face midpoints from the triangles</span>
        <span class="c1">#face_midpoints = np.mean(main_mesh_bbox_restricted.vertices[main_mesh_bbox_restricted.faces],axis=1) # Old way</span>
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">triangles_center</span>
        
        
        <span class="c1">#get the face midpoints that fall within the slice (by lookig at the z component)</span>
        <span class="n">fac_midpoints_trans</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@face_midpoints</span><span class="o">.</span><span class="n">T</span>
        
        <span class="n">slice_mask_pre_distance</span> <span class="o">=</span> <span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&gt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                      <span class="p">(</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&lt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edge_trans</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">distance_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">edge_midpoint</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span>
        
        <span class="n">slice_mask</span> <span class="o">=</span> <span class="n">slice_mask_pre_distance</span> <span class="o">&amp;</span> <span class="n">distance_check</span>
        
        <span class="n">face_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">faces</span><span class="p">))[</span><span class="n">slice_mask</span><span class="p">]</span>

        <span class="c1">#get the submesh of valid faces within the slice</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_list</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;THERE WERE NO FACES THAT FIT THE DISTANCE (</span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2">) and Z transform requirements&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;So just skipping this edge&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;face_list = </span><span class="si">{</span><span class="n">face_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>    
            
        <span class="c1">#get all disconnected mesh pieces of the submesh and the face indices for lookup later</span>
        <span class="n">sub_components</span><span class="p">,</span><span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">significant_sub_components</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sub_components_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub_components_face_indexes</span><span class="p">])</span>
            <span class="n">sub_components_sig_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sub_components_len</span><span class="o">&gt;=</span><span class="n">significant_sub_components</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_components_sig_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sub_components</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">sub_components_sig_idx</span><span class="p">]</span>
                <span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">sub_components_sig_idx</span><span class="p">]</span>
<span class="c1">#                 sub_components_sig = [sub_components[k] for k in sub_components_sig_idx]</span>
<span class="c1">#                 sub_components_face_indexes_sig = [sub_components_face_indexes[k] for k in sub_components_sig_idx]</span>
                
<span class="c1">#                 sub_components = sub_components_sig</span>
<span class="c1">#                 sub_components_face_indexes = sub_components_face_indexes_sig</span>
            
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components = </span><span class="si">{</span><span class="n">sub_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1">#print(f&quot;meshes = {sub_components}, with type = {type(sub_components)}&quot;)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">())</span> <span class="p">:</span>
                <span class="n">sub_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_components</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The sub_components were not an array, list or trimesh&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components = </span><span class="si">{</span><span class="n">sub_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components_face_indexes = </span><span class="si">{</span><span class="n">sub_components_face_indexes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">        </span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        5/9 Change</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#getting the indices of the submeshes whose bounding box contain the edge </span>
        <span class="c1">#contains_points_results = np.array([s_comp.bounding_box.contains(ex_edge.reshape(-1,3)) for s_comp in sub_components])</span>
        <span class="n">contains_points_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">check_coordinates_inside_bounding_box</span><span class="p">(</span><span class="n">s_comp</span><span class="p">,</span>
                                                                                     <span class="n">ex_edge</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                                                                                    <span class="n">return_inside_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">s_comp</span> <span class="ow">in</span> <span class="n">sub_components</span><span class="p">])</span>
        
        <span class="n">containing_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)))[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contains_points_results</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;containing_indices = </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Not exactly one containing mesh: </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sub_components_inner</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">]</span>
                    <span class="n">sub_components_face_indexes_inner</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sub_components_inner</span> <span class="o">=</span> <span class="n">sub_components</span>
                    <span class="n">sub_components_face_indexes_inner</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span>

                <span class="c1">#get the center of the edge</span>
                <span class="n">edge_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#print(f&quot;edge_center = {edge_center}&quot;)</span>

                <span class="c1">#find the distance between eacch bbox center and the edge center</span>
                <span class="n">bbox_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub_components_inner</span><span class="p">]</span>
                <span class="c1">#print(f&quot;bbox_centers = {bbox_centers}&quot;)</span>
                <span class="n">closest_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">edge_center</span><span class="o">-</span><span class="n">b_center</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_center</span> <span class="ow">in</span> <span class="n">bbox_centers</span><span class="p">])</span>
                <span class="c1">#print(f&quot;bbox_distance = {closest_bbox}&quot;)</span>
                <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes_inner</span><span class="p">[</span><span class="n">closest_bbox</span><span class="p">]]]</span>


            <span class="k">else</span><span class="p">:</span><span class="c1"># when only one viable submesh piece and just using that sole index</span>
                <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]]</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge_skeleton_faces = </span><span class="si">{</span><span class="n">edge_skeleton_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components = </span><span class="si">{</span><span class="n">sub_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;containing_indices = </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components_face_indexes (from the split) = </span><span class="si">{</span><span class="n">sub_components_face_indexes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error occured&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;****** Warning the edge index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: had no faces in the edge_skeleton_faces*******&quot;</span><span class="p">)</span>
        <span class="n">face_subtract_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span>
        
        
        <span class="c1">#---- calculating the relevant distances ---- #</span>
        
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)[</span><span class="n">edge_skeleton_faces</span><span class="p">]</span>
        <span class="c1">#print(f&quot;edge_skeleton_faces.shape = {edge_skeleton_faces.shape}&quot;)</span>
<span class="c1">#         print(f&quot;cob_edge = {cob_edge}&quot;)</span>
<span class="c1">#         print(f&quot;face_midpoints = {face_midpoints.shape}&quot;)</span>
<span class="c1">#         print(f&quot;sub_components = {sub_components}&quot;)</span>
<span class="c1">#         print(f&quot;containing_indices = {containing_indices}&quot;)</span>
<span class="c1">#         print(f&quot;sub_components_face_indexes (from the split) = {sub_components_face_indexes}&quot;)</span>
        <span class="c1">#Exception(&quot;failed on fac_midpoints_trans&quot;)</span>
        
        <span class="n">fac_midpoints_trans</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@face_midpoints</span><span class="o">.</span><span class="n">T</span>
        
        <span class="k">if</span> <span class="n">distance_by_mesh_center</span><span class="p">:</span> 
            <span class="n">faces_submesh</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">edge_skeleton_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">faces_submesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_weighted_face_midpoints</span><span class="p">(</span><span class="n">faces_submesh</span><span class="p">)</span>
            <span class="n">faces_submesh_center</span> <span class="o">=</span> <span class="n">faces_submesh_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(f&quot;cob_edge.shape = {cob_edge.shape}, faces_submesh_center.shape={faces_submesh_center.shape}&quot;)</span>
            <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@faces_submesh_center</span>
            <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">edge_midpoint</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
            
        <span class="c1">#print(f&quot;fac_midpoints_trans.shape = {fac_midpoints_trans.shape}&quot;)</span>
        <span class="n">mesh_slice_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">edge_midpoint</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#print(f&quot;mesh_slice_distances.shape = {mesh_slice_distances.shape}&quot;)</span>
        
        <span class="n">total_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mesh_slice_distances</span><span class="p">))</span>
        <span class="n">total_distances_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mesh_slice_distances</span><span class="p">))</span>
    
   
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;face_subtract_indices = </span><span class="si">{</span><span class="n">face_subtract_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        
        <span class="n">all_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span>
        <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_removed_faces</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance of skeleton = </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  

        <span class="c1">#print(f&quot;BEFORE STITCHES unique_removed_faces.shape = {unique_removed_faces.shape}&quot;)</span>
        <span class="k">if</span> <span class="n">stitch_patches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; ---- 9/28 Addition: Want to fill in the holes that will be filled in later</span>
<span class="sd">            with waterfilling algorithm </span>

<span class="sd">            Pseudocode: </span>
<span class="sd">            -1) Cheuck that there were actually eliminated faces</span>
<span class="sd">            0) Get the border vertices for all of the kept_mesh and </span>
<span class="sd">            map them to the main mesh</span>

<span class="sd">            1) Find Part of mesh that is not in the faces that could </span>
<span class="sd">            possibly be included in the mesh correspondence (eliminated_mesh)</span>

<span class="sd">            2) Divide the eliminated_mesh into split pieces</span>


<span class="sd">            3) For each split pieces of the eliminated_mesh</span>
<span class="sd">            a. Get the border vertices</span>
<span class="sd">            b. Map to the main mesh</span>
<span class="sd">            c. Take these border vertices and take boolean difference with kept_mesh border vertices</span>
<span class="sd">            d. If list is empty then add the split face indexes to the kept_mesh faces</span>

<span class="sd">            4) Continue with rest of processing</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside stitch pathes: </span><span class="si">{</span><span class="n">stitch_patches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#-1) Cheuck that there were actually eliminated faces</span>
            <span class="n">eliminated_mesh_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">unique_removed_faces</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eliminated_mesh_faces_idx</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(&quot;Working in the skeletal_distance patches&quot;)</span>

                <span class="c1">#0) Get the border vertices for all of the kept_mesh and </span>
                <span class="c1">#map them to the main mesh</span>
                <span class="n">kept_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">unique_removed_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">kept_mesh_splits</span><span class="p">,</span><span class="n">kept_mesh_splits_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">kept_mesh</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
                <span class="n">kept_border_verts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">km</span> <span class="ow">in</span> <span class="n">kept_mesh_splits</span><span class="p">:</span>
                    <span class="n">curr_border_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertices</span><span class="p">(</span><span class="n">km</span><span class="p">)</span>
                    <span class="n">kept_border_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_vertices_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">vertices_coordinates</span><span class="o">=</span><span class="n">km</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">curr_border_verts</span><span class="p">]))</span>

                <span class="n">total_kept_border_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">kept_border_verts</span><span class="p">)</span>


                <span class="c1">#1) Find Part of mesh that is not in the faces that could </span>
                <span class="c1">#possibly be included in the mesh correspondence (eliminated_mesh)</span>

                <span class="n">eliminated_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">eliminated_mesh_faces_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span> <span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1">#2) Divide the eliminated_mesh into split pieces</span>
                <span class="n">elim_mesh_splits</span><span class="p">,</span><span class="n">elim_mesh_splits_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">eliminated_mesh</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
                
                
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">eliminated_mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s2">&quot;eliminated_mesh.off&quot;</span><span class="p">)</span>

                <span class="c1"># 3) For each split pieces of the eliminated_mesh</span>
                <span class="c1"># a. Get the border vertices</span>
                <span class="c1"># b. Map to the main mesh</span>
                <span class="c1"># c. Take these border vertices and take boolean difference with kept_mesh border vertices</span>
                <span class="c1"># d. If list is empty then add the split face indexes to the kept_mesh faces</span>
                <span class="n">final_faces_with_stitching</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_removed_faces</span><span class="p">]</span>
                <span class="n">meshes_to_stitch</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">e_mesh</span><span class="p">,</span><span class="n">e_mesh_face_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">elim_mesh_splits</span><span class="p">,</span><span class="n">elim_mesh_splits_idx</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">stitch_patches</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> not stitched because faces size (</span><span class="si">{</span><span class="n">e_mesh</span><span class="si">}</span><span class="s2">) &gt; </span><span class="si">{</span><span class="n">stitch_patches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># a. Get the border vertices</span>
                    <span class="n">curr_border_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertices</span><span class="p">(</span><span class="n">e_mesh</span><span class="p">)</span>
                    <span class="n">original_bord_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_vertices_map</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">vertices_coordinates</span><span class="o">=</span><span class="n">e_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">curr_border_verts</span><span class="p">])</span>
                    <span class="n">not_cancelled_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">original_bord_verts</span><span class="p">,</span><span class="n">total_kept_border_verts</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_cancelled_verts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">final_faces_with_stitching</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eliminated_mesh_faces_idx</span><span class="p">[</span><span class="n">e_mesh_face_idx</span><span class="p">])</span>
                        <span class="n">meshes_to_stitch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_mesh</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> WAS YES stitched because not_cancelled_verts = </span><span class="si">{</span><span class="n">not_cancelled_verts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> Not stitched because not_cancelled_verts = </span><span class="si">{</span><span class="n">not_cancelled_verts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">unique_removed_faces_revised</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">final_faces_with_stitching</span><span class="p">))</span>
                <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces_revised</span>
                <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot; ------------------ END OF 9/28 ADDITION -------------------&quot;&quot;&quot;</span>
        <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#faces_to_keep = set(np.arange(0,len(main_mesh.faces))).difference(unique_removed_faces)</span>
        <span class="c1">#print(f&quot;unique_removed_faces.shape = {unique_removed_faces.shape}&quot;)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fast_mesh_split</span><span class="p">:</span>
            <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">unique_removed_faces</span><span class="p">],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------- Starting new trial --------------------&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh.faces.shape = </span><span class="si">{</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh.faces.shape = </span><span class="si">{</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces.shape = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(unique_removed_faces) = </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">split_meshes</span><span class="p">,</span><span class="n">components_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">current_random_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After the split has been called&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_meshes = </span><span class="si">{</span><span class="n">split_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;components_faces = </span><span class="si">{</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">components_faces</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">main_mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">.off&quot;</span><span class="p">)</span>
                <span class="n">new_submesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">.off&quot;</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces_</span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.npz&quot;</span><span class="p">,</span><span class="n">unique_removed_faces</span><span class="o">=</span><span class="n">unique_removed_faces</span><span class="p">)</span>


             <span class="c1">#don&#39;t just want to take the biggest mesh: but want to take the one that has the most of the skeleton</span>
            <span class="c1">#piece corresponding to it</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) turn all of the mesh edge_skeleton_faces into meshes, have the main mesh be the whole mesh and </span>
<span class="sd">            have each of the mesh pieces be a central piece</span>
<span class="sd">            2) Call the mesh_pieces_connectivity function and see how many of the periphery pieces are touching each of the submehses</span>
<span class="sd">            3) Pick the mesh that has the most </span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 


                <span class="n">branch_touching_number</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1">#getting the mesh correspondence for each skeleton segment</span>
                <span class="n">branch_correspondence_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">face_subtract_indices</span><span class="p">]</span>
                <span class="c1">#Out of all the submesh splits, see how many of the segment mesh correspondence it is touching</span>
                <span class="k">for</span> <span class="n">curr_central_piece</span> <span class="ow">in</span> <span class="n">split_meshes</span><span class="p">:</span>
                    <span class="n">touching_periphery_pieces</span> <span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span>
                                                <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">new_submesh</span><span class="p">,</span>
                                                <span class="n">central_piece</span> <span class="o">=</span> <span class="n">curr_central_piece</span><span class="p">,</span>
                                                <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">branch_correspondence_meshes</span><span class="p">,</span>
                                                <span class="n">return_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="p">)</span>
                    <span class="n">branch_touching_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">touching_periphery_pieces</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_touching_number = </span><span class="si">{</span><span class="n">branch_touching_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#CONCLUSION: find the submesh split piece that is touching the most skeleton segment mesh correspondences (winning mesh)</span>
                <span class="n">most_branch_containing_piece</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">branch_touching_number</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;most_branch_containing_piece = </span><span class="si">{</span><span class="n">most_branch_containing_piece</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#Make this the </span>


                <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="n">most_branch_containing_piece</span><span class="p">]</span>
                <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces</span><span class="p">[</span><span class="n">components_faces</span><span class="p">[</span><span class="n">most_branch_containing_piece</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh.faces.shape = </span><span class="si">{</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reassigning new_submesh to one of many sub pieces&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh.faces.shape = </span><span class="si">{</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces.shape = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(unique_removed_faces) = </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces</span><span class="p">[</span><span class="n">components_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_mesh.faces.shape = </span><span class="si">{</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assigning submesh to the only submesh&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh.faces.shape = </span><span class="si">{</span><span class="n">new_submesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_removed_faces.shape = </span><span class="si">{</span><span class="n">unique_removed_faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(unique_removed_faces) = </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The split meshes in the mesh correspondence was 0 length&quot;</span><span class="p">)</span>
        
        <span class="c1">#need to further restric the unique_removed_faces to those of most significant piece</span>
        <span class="k">else</span><span class="p">:</span> 
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            12/17 Addition that does a faster spliting of the mesh</span>
<span class="sd">            </span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            1) Find the largest connected component of the face_subtract_indices groups</span>
<span class="sd">            2) Get the face indices for all those in the group</span>
<span class="sd">            3) Get a submesh of that</span>
<span class="sd">            4) Split the submesh into largest conneted component</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1">#1) Find the largest connected component of the face_subtract_indices groups</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In fast_mesh_split&quot;</span><span class="p">)</span>
                <span class="n">c_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
            
                
            <span class="n">conn_face_components</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersecting_array_components</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">,</span><span class="n">sort_components</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">conn_comps_lenghts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_face_components</span><span class="p">])</span>
            <span class="n">max_len_components_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conn_comps_lenghts</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">conn_comps_lenghts</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Largest component time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">c_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
            
            <span class="c1">#2) Get the face indices for all those in the group</span>
            <span class="n">max_len_components_unique_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">face_subtract_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> 
                                                                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_face_components</span><span class="p">[</span><span class="n">cmp_idx</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">cmp_idx</span> <span class="ow">in</span>  <span class="n">max_len_components_idx</span><span class="p">]</span>
            <span class="n">unique_removed_faces_pre</span> <span class="o">=</span> <span class="n">max_len_components_unique_faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">max_len_components_unique_faces</span><span class="p">])]</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_len_components_unique_faces = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">c_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1">#3) Get a submesh of that</span>
            <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">unique_removed_faces_pre</span><span class="p">],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">split_meshes</span><span class="p">,</span><span class="n">components_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_meshes (connectivity = </span><span class="si">{</span><span class="n">connectivity</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">c_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1">#4) Split the submesh into largest conneted component</span>
            <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">unique_removed_faces_pre</span><span class="p">[</span><span class="n">components_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;right split = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">c_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_submesh = </span><span class="si">{</span><span class="n">new_submesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">total_distances</span><span class="p">,</span><span class="n">total_distances_std</span><span class="p">,</span><span class="n">new_submesh</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span></div>


<div class="viewcode-block" id="mesh_correspondence_adaptive_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.mesh_correspondence_adaptive_distance">[docs]</a><span class="k">def</span> <span class="nf">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">,</span>
                                          <span class="n">curr_branch_mesh</span><span class="p">,</span>
                                         <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                          <span class="n">distance_by_mesh_center</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">return_mesh_perc_drop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">stitch_patches</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="c1">#50,</span>
                                         <span class="n">buffer</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                                          <span class="n">bbox_ratio</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                                         <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                                         <span class="n">return_closest_face_on_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">):</span>
    
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
    <span class="c1">#making the skeletons resized to 1000 widths and then can use outlier finding</span>
    
    <span class="n">new_skeleton</span>  <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">,</span><span class="n">segment_width</span> <span class="o">=</span> <span class="n">skeleton_segment_width</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_skeleton = </span><span class="si">{</span><span class="n">new_skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_skeleton.shape = </span><span class="si">{</span><span class="n">new_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">segment_skeletal_mean_distances</span><span class="p">,</span>
     <span class="n">segment_skeletal_std_distances</span><span class="p">,</span>
     <span class="n">mesh_correspondence</span><span class="p">,</span>
     <span class="n">mesh_correspondence_indices</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_skeletal_distance</span><span class="p">(</span>
                        <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">curr_branch_mesh</span><span class="p">,</span>
                        <span class="n">edges</span> <span class="o">=</span> <span class="n">new_skeleton</span><span class="p">,</span>
                        <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                        <span class="n">bbox_ratio</span><span class="o">=</span><span class="n">bbox_ratio</span><span class="p">,</span>
                        <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_threshold</span><span class="p">,</span>
                        <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                        <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">stitch_patches</span><span class="o">=</span> <span class="n">stitch_patches</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span>
    <span class="p">)</span>
    
    
    
    
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> After first skeletal distance call&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_skeletal_mean_distances = </span><span class="si">{</span><span class="n">segment_skeletal_mean_distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_skeletal_std_distances = </span><span class="si">{</span><span class="n">segment_skeletal_std_distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence = </span><span class="si">{</span><span class="n">mesh_correspondence</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence_indices = </span><span class="si">{</span><span class="n">mesh_correspondence_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">mesh_correspondence</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s2">&quot;mesh_correspondence_round_1.off&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_correspondence_indices</span><span class="p">)</span><span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;empty mesh_correspondence_indices returned so returning an empty array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_closest_face_on_empty</span><span class="p">:</span>
            <span class="c1">#1) Get the current nodes of skeleton</span>
            <span class="n">curr_nodes</span><span class="p">,</span><span class="n">curr_edges</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes_edges</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">)</span>
            <span class="n">closest_face</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_closest_face_to_coordinates</span><span class="p">(</span><span class="n">curr_branch_mesh</span><span class="p">,</span><span class="n">curr_nodes</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">closest_face</span><span class="p">]),</span><span class="mi">0</span>
            
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1">#now use the new submesh to calculate the new threshold</span>
    <span class="c1"># -- Step where I compute the new threshold and and then rerun it -- #</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_skeletal_mean_distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">filtered_measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_mean_distances</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">filtered_measurements_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_std_distances</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filtered_measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_mean_distances</span><span class="p">)</span>
        <span class="n">filtered_measurements_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_std_distances</span><span class="p">)</span>



    <span class="c1">#filter out the other outliers: do anything higher than 150% of median should be discounted</span>
    <span class="n">median_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">filtered_measurements</span><span class="p">)</span>
    <span class="n">outlier_mask</span> <span class="o">=</span> <span class="n">filtered_measurements</span> <span class="o">&lt;=</span> <span class="n">median_value</span><span class="o">*</span><span class="mf">1.5</span>
    <span class="n">filtered_measurements</span> <span class="o">=</span> <span class="n">filtered_measurements</span><span class="p">[</span><span class="n">outlier_mask</span><span class="p">]</span>
    <span class="n">filtered_measurements_std</span> <span class="o">=</span> <span class="n">filtered_measurements_std</span><span class="p">[</span><span class="n">outlier_mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtered_measurements = </span><span class="si">{</span><span class="n">filtered_measurements</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># try the mesh subtraction again </span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="n">total_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">filtered_measurements</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">filtered_measurements_std</span><span class="p">)</span>
    
    
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_threshold = </span><span class="si">{</span><span class="n">total_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="p">(</span><span class="n">segment_skeletal_mean_distances_2</span><span class="p">,</span>
     <span class="n">filtered_measurements_std</span><span class="p">,</span>
     <span class="n">mesh_correspondence_2</span><span class="p">,</span>
     <span class="n">mesh_correspondence_indices_2</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_skeletal_distance</span><span class="p">(</span>
                        <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">mesh_correspondence</span><span class="p">,</span>
                        <span class="n">edges</span> <span class="o">=</span> <span class="n">new_skeleton</span><span class="p">,</span>
                        <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                        <span class="n">bbox_ratio</span><span class="o">=</span><span class="n">bbox_ratio</span><span class="p">,</span>
                        <span class="n">distance_threshold</span><span class="o">=</span><span class="n">total_threshold</span><span class="p">,</span>
                        <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                        <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="c1">#stitch_patches=1000,</span>
        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
    <span class="p">)</span>
    
    
    
    <span class="c1">#calculate the mesh percentage drop from the first mesh correspondence to after the adaptive measurement is used</span>
    <span class="n">mesh_perc_drop</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_correspondence_indices_2</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_correspondence_indices</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_perc_drop = </span><span class="si">{</span><span class="n">mesh_perc_drop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> After 2nd skeletal distance call&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_skeletal_mean_distances_2 = </span><span class="si">{</span><span class="n">segment_skeletal_mean_distances_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtered_measurements_std = </span><span class="si">{</span><span class="n">filtered_measurements_std</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence_2 = </span><span class="si">{</span><span class="n">mesh_correspondence_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence_indices_2 = </span><span class="si">{</span><span class="n">mesh_correspondence_indices_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_correspondence_indices_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;empty mesh_correspondence_indices_2 returned so returning original mesh correspondence&quot;</span><span class="p">)</span>
        <span class="n">total_threshol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">segment_skeletal_mean_distances</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">segment_skeletal_std_distances</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_mesh_perc_drop</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh_correspondence_indices</span><span class="p">,</span> <span class="n">total_threshold</span><span class="p">,</span><span class="n">mesh_perc_drop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh_correspondence_indices</span><span class="p">,</span><span class="n">total_threshol</span>
        

    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> segment_skeletal_mean_distances.shape = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_mean_distances</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;segment_skeletal_std_distances.shape = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_std_distances</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;mesh_correspondence.faces.shape = </span><span class="si">{</span><span class="n">mesh_correspondence</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;max(mesh_correspondence_indices)= </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mesh_correspondence_indices</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;mesh_correspondence_indices.shape = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_correspondence_indices</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

              <span class="sa">f</span><span class="s2">&quot;segment_skeletal_mean_distances_2.shape = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segment_skeletal_mean_distances_2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;filtered_measurements_std.shape = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_measurements_std</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;mesh_correspondence_2.faces.shape = </span><span class="si">{</span><span class="n">mesh_correspondence_2</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;max(mesh_correspondence_indices_2)= </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mesh_correspondence_indices_2</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;mesh_correspondence_indices_2.shape = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_correspondence_indices_2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mesh_correspondence_indices</span><span class="p">[</span><span class="n">mesh_correspondence_indices_2</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence_indices = </span><span class="si">{</span><span class="n">mesh_correspondence_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence_indices_2 = </span><span class="si">{</span><span class="n">mesh_correspondence_indices_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#want to show the changes in mesh</span>
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes = [curr_branch_mesh.submesh([mesh_correspondence_indices],append=True)])</span>
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes = [curr_branch_mesh.submesh([mesh_correspondence_indices[mesh_correspondence_indices_2]],append=True)])</span>
        
    <span class="c1"># PROBLEM NOT PASSING BACK A CONNECTED COMPONENT</span>
    <span class="k">if</span> <span class="n">return_mesh_perc_drop</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_correspondence_indices</span><span class="p">[</span><span class="n">mesh_correspondence_indices_2</span><span class="p">],</span> <span class="n">total_threshold</span><span class="p">,</span><span class="n">mesh_perc_drop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_correspondence_indices</span><span class="p">[</span><span class="n">mesh_correspondence_indices_2</span><span class="p">],</span><span class="n">total_threshold</span></div>


<span class="c1"># -------- for the mesh correspondence that creates an exact 1-to1 correspondence of mesh face to skeleton branch------- #</span>
<div class="viewcode-block" id="filter_face_coloring_to_connected_components"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.filter_face_coloring_to_connected_components">[docs]</a><span class="k">def</span> <span class="nf">filter_face_coloring_to_connected_components</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">face_coloring</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
     <span class="n">must_keep_labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To eliminate all but the largest connected component</span>
<span class="sd">    of a label on the mesh face coloring </span>
<span class="sd">    </span>
<span class="sd">    Reason for need: when cancelling out conflict pieces</span>
<span class="sd">    it can split up a mesh into disconnected components and we </span>
<span class="sd">    want only one component so that it can later be expanded during </span>
<span class="sd">    the waterfilling process</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">leftover_labels</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">face_coloring</span><span class="p">),[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">curr_label</span> <span class="ow">in</span> <span class="n">leftover_labels</span><span class="p">:</span>
        <span class="n">label_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_coloring</span><span class="o">==</span><span class="n">curr_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">curr_submesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">label_indices</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_components</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">curr_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        
        <span class="n">winning_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">curr_label</span> <span class="ow">in</span> <span class="n">must_keep_labels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sc</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_components</span><span class="p">):</span>
                <span class="n">curr_component_labels</span> <span class="o">=</span> <span class="n">label_indices</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">curr_component_labels</span><span class="p">,</span><span class="n">must_keep_labels</span><span class="p">[</span><span class="n">curr_label</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">must_keep_labels</span><span class="p">[</span><span class="n">curr_label</span><span class="p">]):</span>
                    <span class="n">winning_index</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">winning_index</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">if</span> <span class="n">winning_index</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">label_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label_indices</span><span class="p">)</span>
            <span class="n">split_components_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">split_components</span><span class="p">[</span><span class="n">winning_index</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
            <span class="n">to_keep_indices</span> <span class="o">=</span> <span class="n">label_indices</span><span class="p">[</span><span class="n">split_components_0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;label_indices = </span><span class="si">{</span><span class="n">label_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_submesh = </span><span class="si">{</span><span class="n">curr_submesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_components = </span><span class="si">{</span><span class="n">split_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_components[0] = </span><span class="si">{</span><span class="n">split_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No winning index in filter_face_coloring_to_connected_components&quot;</span><span class="p">)</span>
        
            
        <span class="n">to_clear_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">label_indices</span><span class="p">,</span> <span class="n">to_keep_indices</span><span class="p">)</span>
        <span class="n">face_coloring</span><span class="p">[</span><span class="n">to_clear_indices</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        
    <span class="k">return</span> <span class="n">face_coloring</span></div>

<div class="viewcode-block" id="waterfill_labeling"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.waterfill_labeling">[docs]</a><span class="k">def</span> <span class="nf">waterfill_labeling</span><span class="p">(</span>
                <span class="n">total_mesh_correspondence</span><span class="p">,</span>
                 <span class="n">submesh_indices</span><span class="p">,</span>
                 <span class="n">total_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">total_mesh_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">propagation_type</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                <span class="n">max_submesh_threshold</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span>
                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) check if the submesh you are propagating labels to is too large</span>
<span class="sd">    2) for each unmarked face get the neighbors of all of the faces, and for all these neighbors get all the labels</span>
<span class="sd">    3) if the neighbors label is not empty. depending on the type of progation type then pick the winning label</span>
<span class="sd">    a. random: just randomly choose from list</span>
<span class="sd">    b. .... not yet implemented</span>
<span class="sd">    4) revise the faces that are still empty and repeat process until all faces are empty (have a max iterations number)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">total_mesh_graph</span><span class="p">:</span>
            <span class="c1">#print(f&quot;converted the mesh ({total_mesh}) into a mesh_graph&quot;)</span>
            <span class="c1">#finding the face adjacency:</span>
            <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span><span class="p">:</span>
                <span class="n">total_mesh_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">total_mesh</span><span class="o">.</span><span class="n">face_adjacency</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#total_mesh_graph = tu.mesh_face_graph_by_vertex(total_mesh)</span>
                <span class="n">total_mesh_graph</span> <span class="o">=</span> <span class="kc">None</span>



<span class="c1">#         if len(c)&gt; max_submesh_threshold:</span>
<span class="c1">#             raise Exception(f&quot;The len of the submesh ({len(submesh_indices)}) exceeds the maximum threshold of {max_submesh_threshold} &quot;)</span>

        <span class="c1">#check that these are unmarked</span>
        <span class="n">curr_unmarked_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">submesh_indices</span> <span class="k">if</span> <span class="n">total_mesh_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> 


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_unmarked_faces</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">submesh_indices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">submesh_indices</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_unmarked_faces</span><span class="p">)</span><span class="si">}</span><span class="s2"> submesh faces were already labeled before waterfill_labeling started&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
            <span class="c1">#s2) for each unmarked face get the neighbors of all of the faces, and for all these neighbors get all the labels</span>
            <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span><span class="p">:</span>
                <span class="n">unmarked_faces_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">total_mesh_graph</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">curr_unmarked_faces</span><span class="p">]</span> <span class="c1">#will be list of lists</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unmarked_faces_neighbors</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">face_neighbors_by_vertices_seperate</span><span class="p">(</span><span class="n">total_mesh</span><span class="p">,</span><span class="n">curr_unmarked_faces</span><span class="p">)</span>
                
            <span class="c1"># old way</span>
            <span class="c1">#unmarked_face_neighbor_labels = [np.array([total_mesh_correspondence[curr_neighbor] for curr_neighbor in z]) for z in unmarked_faces_neighbors]</span>
            
            <span class="c1">#new way that just indexes into array</span>
            <span class="n">total_mesh_correspondence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">total_mesh_correspondence</span><span class="p">)</span>
            <span class="n">unmarked_face_neighbor_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">total_mesh_correspondence</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">unmarked_faces_neighbors</span><span class="p">]</span>
            
            <span class="n">total_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unmarked_face_neighbor_labels</span><span class="p">)))</span>
            
            <span class="c1">#print(f&quot;unmarked_face_neighbor_labels = {unmarked_face_neighbor_labels}&quot;)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmarked_face_neighbor_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_unmarked_faces = </span><span class="si">{</span><span class="n">curr_unmarked_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;i = </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unmarked_faces_neighbors = </span><span class="si">{</span><span class="n">unmarked_faces_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unmarked_face_neighbor_labels = </span><span class="si">{</span><span class="n">unmarked_face_neighbor_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#check if there is only one type of label and if so then autofil</span>
            

            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">total_labels</span><span class="p">:</span>
                <span class="n">total_labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#try to get labels by vertices</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_unmarked_faces</span><span class="p">,</span><span class="s2">&quot;curr_unmarked_faces&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_mesh_graph</span><span class="p">,</span><span class="s2">&quot;total_mesh_graph&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_mesh_correspondence</span><span class="p">,</span><span class="s2">&quot;total_mesh_correspondence&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">submesh_indices</span><span class="p">,</span><span class="s2">&quot;submesh_indices&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;total labels does not have any marked neighbors&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#print(&quot;All surrounding labels are the same so autofilling the remainder of unlabeled labels&quot;)</span>
                <span class="k">for</span> <span class="n">gg</span> <span class="ow">in</span> <span class="n">curr_unmarked_faces</span><span class="p">:</span>
                    <span class="n">total_mesh_correspondence</span><span class="p">[</span><span class="n">gg</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#if there are still one or more labels surrounding our unlabeled region</span>
                <span class="k">for</span> <span class="n">curr_face</span><span class="p">,</span><span class="n">curr_neighbors</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">curr_unmarked_faces</span><span class="p">,</span><span class="n">unmarked_face_neighbor_labels</span><span class="p">):</span>
                    <span class="n">curr_neighbors</span> <span class="o">=</span> <span class="n">curr_neighbors</span><span class="p">[</span><span class="n">curr_neighbors</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">propagation_type</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                            <span class="n">total_mesh_correspondence</span><span class="p">[</span><span class="n">curr_face</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">curr_neighbors</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not implemented propagation_type&quot;</span><span class="p">)</span>

            <span class="c1"># now replace the new curr_unmarked faces</span>
            <span class="n">curr_unmarked_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">submesh_indices</span> <span class="k">if</span> <span class="n">total_mesh_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#old dict way</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_unmarked_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(f&quot;breaking out of loop because zero unmarked faces left after {i} iterations&quot;)</span>
                <span class="k">break</span>


        <span class="c1">#check that no more unmarked faces or error</span>
        <span class="n">end_unmarked_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">submesh_indices</span> <span class="k">if</span> <span class="n">total_mesh_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_unmarked_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> iterations (with max_iterations = </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2"> there were still </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">end_unmarked_faces</span><span class="p">)</span><span class="si">}</span><span class="s2"> faces&quot;</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">total_mesh_correspondence</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_submesh_threshold = </span><span class="si">{</span><span class="n">max_submesh_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_iterations = </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_mesh_correspondence</span><span class="p">,</span><span class="s2">&quot;total_mesh_correspondence&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">submesh_indices</span><span class="p">,</span><span class="s2">&quot;total_mesh&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_mesh</span><span class="p">,</span><span class="s2">&quot;total_mesh_correspondence&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_mesh_graph</span><span class="p">,</span><span class="s2">&quot;total_mesh_graph&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_mesh_correspondence</span><span class="p">,</span><span class="s2">&quot;total_mesh_correspondence&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong in waaterfilling algorithm&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="resolve_empty_conflicting_face_labels"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.resolve_empty_conflicting_face_labels">[docs]</a><span class="k">def</span> <span class="nf">resolve_empty_conflicting_face_labels</span><span class="p">(</span>
                     <span class="n">curr_limb_mesh</span><span class="p">,</span>
                     <span class="n">face_lookup</span><span class="p">,</span>
                     <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="p">[],</span>
                    <span class="n">max_submesh_threshold</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
                    <span class="n">max_color_filling_iterations</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">must_keep_labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="c1"># dictionary mapping labels to the faces they must label at the start,</span>
                    <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                    <span class="n">branch_skeletons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input: </span>
<span class="sd">    - full mesh</span>
<span class="sd">    - current face coloring of mesh (could be incomplete) corresponding to skeletal pieces</span>
<span class="sd">    (but doesn&#39;t need the skeletal pieces to do it&#39;s jobs, those are just represented in the labels)</span>

<span class="sd">    Output: </span>
<span class="sd">    - better face coloring which has labels that:</span>
<span class="sd">        a. cover entire mesh</span>
<span class="sd">        b. the labels exist as only 1 connected component on the mesh</span>



<span class="sd">    Pseudocode of what doing:</span>
<span class="sd">    - clearing out the branch_mesh correspondence stored in limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;]</span>
<span class="sd">    - gets a list of how many subdivided branches there were (becuase this should be the number of labels) and the mesh of whole limb</span>
<span class="sd">    - Builds a face to skeleeton branch correspondence bassed on the current  branch_piece[&quot;correspondence_face_idx&quot;] that already exists</span>
<span class="sd">        This may have overlaps or faces mapped to zero branches that we need to resolve</span>
<span class="sd">    - computes the percentage of empty and conflicting faces </span>
<span class="sd">    - makes sure that at least one face that corresponds to each branch piece (and throws error if so)</span>

<span class="sd">    #Doing the resolution of the empty and conflicting faces:</span>
<span class="sd">    - clears out all conflicting faces and leaves them just like the empty ones</span>
<span class="sd">    - uses the filter_face_coloring_to_connected_components which only keeps the largest connected component of a label </span>
<span class="sd">        (because the zeroing out of conflicting labels could have eliminated or split up some of the labels)</span>
<span class="sd">    - if  a face was totally eliminated then add it back to the face coloring</span>
<span class="sd">    (only does this once so a face could still be missing if one face totally overwrites another face)</span>

<span class="sd">    **At this point: there is at one-to-one correspondence of mesh face to skeletal piece label OR empty label (-1)</span>

<span class="sd">    # Using the waterfilling algorithm: designed at fixing the correspondence to empty label (-1) </span>
<span class="sd">    - get a submesh of the original mesh but only for those empty faces and divide into disconnecteed mesh pieces</span>
<span class="sd">    - run through waterfilling algorithm to color each empty piece</span>
<span class="sd">    - check that there are no more empty faces</span>
<span class="sd">    - gets the one connected mesh component that corresponds to that label (get both the actual mesh and the mesh indexes)</span>

<span class="sd">    #the output of all of the algorithm: </span>
<span class="sd">    - save the result back in  limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;] so it is accurately updated</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">split_results</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="s2">&quot;curr_limb_mesh&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The mesh passed to resolve_empty was not just one connected mesh, split results = </span><span class="si">{</span><span class="n">split_results</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">values</span><span class="p">())))))</span>

    <span class="c1">#get all of the faces that don&#39;t have any faces corresponding</span>
    <span class="n">empty_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">face_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1">#get all of the faces that don&#39;t have any faces corresponding</span>
    <span class="n">conflict_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">face_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;empty_indices % = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">empty_indices</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="se">\n</span><span class="s2"> conflict_indices % = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">conflict_indices</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="n">resolved_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="c1">#doing the face coloring (new way if the keys are unordered)</span>
        <span class="n">face_coloring</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">face_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">face_coloring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#adding in the must keep labels</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">must_keep_labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">face_coloring</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="c1"># -- Need to only take the biggest piece of the non-conflicted mesh and resolve those that were eliminated--</span>
        <span class="n">missing_labels_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_color_filling_iterations</span><span class="p">):</span>

            
            <span class="n">face_coloring</span> <span class="o">=</span> <span class="n">filter_face_coloring_to_connected_components</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">face_coloring</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                                                                        <span class="n">must_keep_labels</span><span class="o">=</span><span class="n">must_keep_labels</span><span class="p">)</span>
            
            <span class="c1"># checking that the face coloring was still maintained</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">must_keep_labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">face_idx</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">face_coloring</span><span class="p">[</span><span class="n">face_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The face_coloring did not maintain the labels to keep&quot;</span><span class="p">)</span>

            <span class="c1"># ----fixing if there were any missing labels --- **** this still has potential for erroring ****</span>

            <span class="n">leftover_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">face_coloring</span><span class="p">)</span>
            <span class="n">missing_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">leftover_labels</span><span class="p">))</span>


            <span class="k">for</span> <span class="n">curr_label</span> <span class="ow">in</span> <span class="n">missing_labels</span><span class="p">:</span>
                <span class="n">labels_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">face_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">curr_label</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
                <span class="n">face_coloring</span><span class="p">[</span><span class="n">labels_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_label</span>
            
            <span class="c1">#adding in the must keep labels</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">must_keep_labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">face_coloring</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">must_keep_labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">face_idx</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">face_coloring</span><span class="p">[</span><span class="n">face_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The face_coloring did not maintain the labels to keep&quot;</span><span class="p">)</span>

            <span class="c1">#filter the faces again: </span>
            <span class="n">face_coloring</span> <span class="o">=</span> <span class="n">filter_face_coloring_to_connected_components</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">face_coloring</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                                                                        <span class="n">must_keep_labels</span><span class="o">=</span><span class="n">must_keep_labels</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">must_keep_labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">face_idx</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">face_coloring</span><span class="p">[</span><span class="n">face_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The face_coloring did not maintain the labels to keep&quot;</span><span class="p">)</span>

            <span class="n">leftover_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">face_coloring</span><span class="p">)</span>
            <span class="n">missing_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">leftover_labels</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Doing No Color conflicts iteration </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> because missing_labels = </span><span class="si">{</span><span class="n">missing_labels</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                    <span class="n">missing_labels_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">missing_labels</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">resolved_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Will resolve any conflicts when exact patches</span>

<span class="sd">            Pseudcode: </span>
<span class="sd">            1) get all the labels that were missing at one time</span>
<span class="sd">            2) Get all the face numbers belonging to those labels</span>
<span class="sd">            3) Find if any are completely overlapping</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">all_possible_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">missing_labels_history</span><span class="p">))</span>
            <span class="n">all_possible_missing_faces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_possible_missing</span><span class="p">])</span>

            <span class="c1">#getting the original faces</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">face_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">mf</span> <span class="ow">in</span> <span class="n">all_possible_missing_faces</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">mf</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                        <span class="n">all_possible_missing_faces</span><span class="p">[</span><span class="n">mf</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>



            <span class="n">all_poss_miss_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_possible_missing_faces</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">perf_connection</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersecting_array_components</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_possible_missing_faces</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span><span class="n">perfect_match</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">#connections_to_fix = [k for k in all_poss_miss_idx[perf_connection] if len(k)&gt;1]</span>
            <span class="n">connections_to_fix</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_poss_miss_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">perf_connection</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;connections_to_fix = </span><span class="si">{</span><span class="n">connections_to_fix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) For all the pairs</span>
<span class="sd">            2) Divide up the submesh of the faces by the closest distance skeleton</span>
<span class="sd">            3) check that all of them have at least one:</span>
<span class="sd">            - If not just do a random assignment (temporary solution for now)</span>
<span class="sd">            4) Doing the actual relabeling</span>


<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">connections_to_fix</span><span class="p">:</span>
                <span class="n">shared_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_possible_missing_faces</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">curr_submesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">shared_faces_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">split_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_by_closest_skeleton</span><span class="p">(</span><span class="n">curr_submesh</span><span class="p">,[</span><span class="n">branch_skeletons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">])</span>

                <span class="n">split_mesh_faces_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">split_mesh_faces</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">split_mesh_faces_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Just divide up the faces between all the labels (don&#39;t even randomize)&quot;</span><span class="p">)</span>
                    <span class="n">faces_to_relabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">shared_faces_idx</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">faces_to_relabel</span> <span class="o">=</span> <span class="p">[</span><span class="n">shared_faces_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">split_mesh_faces</span><span class="p">]</span>

                <span class="n">faces_to_relabel_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">faces_to_relabel</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">faces_to_relabel_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Some of labels did not hae any faces that belonged to them after random/closest skeleton assignment&quot;</span><span class="p">)</span>
                    <span class="n">resolved_flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>


                <span class="c1"># rewriting the face lookup</span>
                <span class="k">for</span> <span class="n">conn_idx</span><span class="p">,</span><span class="n">conn_faces</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="n">faces_to_relabel</span><span class="p">):</span>
                    <span class="n">conn_idx_to_delete</span> <span class="o">=</span> <span class="n">conn</span><span class="p">[</span><span class="n">conn</span> <span class="o">!=</span> <span class="n">conn_idx</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">f_idx</span> <span class="ow">in</span> <span class="n">conn_faces</span><span class="p">:</span>
                        <span class="n">face_lookup</span><span class="p">[</span><span class="n">f_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">face_lookup</span><span class="p">[</span><span class="n">f_idx</span><span class="p">],</span><span class="n">conn_idx_to_delete</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">resolved_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover_labels = </span><span class="si">{</span><span class="n">leftover_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no_missing_labels = </span><span class="si">{</span><span class="n">no_missing_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;missing_labels = </span><span class="si">{</span><span class="n">missing_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="s2">&quot;curr_limb_mesh&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">face_lookup</span><span class="p">,</span><span class="s2">&quot;face_lookup&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">,</span><span class="s2">&quot;no_missing_labels&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">max_submesh_threshold</span><span class="p">,</span><span class="s2">&quot;max_submesh_threshold&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">branch_skeletons</span><span class="p">,</span><span class="s2">&quot;branch_skeletons&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;missing labels was not resolved&quot;</span><span class="p">)</span>



    <span class="c1"># -----now just divide the groups into seperate components</span>
    <span class="n">empty_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_coloring</span><span class="o">==-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span><span class="p">:</span>
        <span class="n">mesh_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">face_adjacency</span><span class="p">)</span> <span class="c1"># creating a graph from the faces</span>
        <span class="n">empty_submesh</span> <span class="o">=</span> <span class="n">mesh_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">empty_faces</span><span class="p">)</span> <span class="c1">#gets the empty submeshes that are disconnected</span>
        <span class="n">empty_connected_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">empty_submesh</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#mesh_graph = tu.mesh_face_graph_by_vertex(curr_limb_mesh)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">empty_face_submesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">empty_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">empty_face_submesh</span><span class="p">):</span>
            <span class="n">meshes</span><span class="p">,</span><span class="n">comp_ind</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_by_vertices</span><span class="p">(</span><span class="n">empty_face_submesh</span><span class="p">,</span><span class="n">return_components</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">empty_connected_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">empty_faces</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">comp_ind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">empty_connected_components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mesh_graph</span><span class="o">=</span><span class="kc">None</span>




    <span class="c1"># ---- Functions that will fill in the rest of the mesh correspondence ---- #</span>

    <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">face_coloring</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BEFORE face_lookup_resolved_test&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">empty_connected_components</span><span class="p">,</span><span class="s2">&quot;empty_connected_components&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">empty_connected_components</span><span class="p">):</span>
        <span class="c1">#print(&quot;len(mesh_graph) = {len(mesh_graph)}&quot;)</span>

        <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">waterfill_labeling</span><span class="p">(</span>
                        <span class="c1">#total_mesh_correspondence=face_lookup_resolved_test,</span>
                        <span class="n">total_mesh_correspondence</span><span class="o">=</span><span class="n">face_coloring_copy</span><span class="p">,</span>
                         <span class="n">submesh_indices</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">comp</span><span class="p">),</span>
                         <span class="n">total_mesh</span><span class="o">=</span><span class="n">curr_limb_mesh</span><span class="p">,</span> <span class="c1">#added this in case doing the vertex connectivity</span>
                        <span class="n">total_mesh_graph</span><span class="o">=</span><span class="n">mesh_graph</span><span class="p">,</span>
                         <span class="n">propagation_type</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                        <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                        <span class="n">max_submesh_threshold</span> <span class="o">=</span> <span class="n">max_submesh_threshold</span><span class="p">,</span>
                        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                        <span class="p">)</span>


    <span class="c1"># -- wheck that the face coloring did not have any empty faces --</span>
    <span class="n">empty_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_coloring_copy</span><span class="o">==-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empty_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="s2">&quot;curr_limb_mesh&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">face_lookup</span><span class="p">,</span><span class="s2">&quot;face_lookup&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">,</span><span class="s2">&quot;no_missing_labels&quot;</span><span class="p">)</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">max_submesh_threshold</span><span class="p">,</span><span class="s2">&quot;max_submesh_threshold&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;empty faces were greater than 0 after waterfilling at: </span><span class="si">{</span><span class="n">empty_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">face_coloring_copy</span></div>


<div class="viewcode-block" id="groups_of_labels_to_resolved_labels"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.groups_of_labels_to_resolved_labels">[docs]</a><span class="k">def</span> <span class="nf">groups_of_labels_to_resolved_labels</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">face_correspondence_lists</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a list of face correspondences of different parts</span>
<span class="sd">    and turn them into an array mapping every face (on the mesh) to a label</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">face_correspondence_lists</span><span class="p">))</span>
    
    <span class="n">face_lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))])</span>
    
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_faces_corresponded</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">face_correspondence_lists</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_faces_corresponded</span><span class="p">:</span>
            <span class="n">face_lookup</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    
    <span class="n">original_labels</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">get_unique_values_dict_of_lists</span><span class="p">(</span><span class="n">face_lookup</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(original_labels),len(original_labels) = </span><span class="si">{</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(original_labels) != len(no_missing_labels) for original_labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">,no_missing_labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There are some missing labels in the initial labeling&quot;</span><span class="p">)</span>
        
    <span class="c1">#here is where can call the function that resolves the face labels</span>
    <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span>
                     <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="p">,</span>
                     <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                     <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="n">no_missing_labels</span>
        
    <span class="p">)</span>
    
    <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">face_coloring_copy</span><span class="p">)</span>
    <span class="n">divided_submeshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span></div>


<span class="sd">&quot;&quot;&quot; ------------ 9/17 Addition: Will expand a certain label until hits the soma border -------- &quot;&quot;&quot;</span>
<div class="viewcode-block" id="waterfill_starting_label_to_soma_border"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.compartment_utils.waterfill_starting_label_to_soma_border">[docs]</a><span class="k">def</span> <span class="nf">waterfill_starting_label_to_soma_border</span><span class="p">(</span><span class="n">curr_branch_mesh</span><span class="p">,</span>
                                           <span class="n">border_vertices</span><span class="p">,</span>
                                            <span class="n">label_to_expand</span><span class="p">,</span> <span class="c1">#the one we want to expand to the border</span>
                                           <span class="n">total_face_labels</span><span class="p">,</span>
                                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">n_touching_soma_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                           <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To expand a certain label so it is touching the soma </span>
<span class="sd">    border vertices</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#     total_face_labels_original = copy.deepcopy(total_face_labels)</span>
<span class="c1">#     su.compressed_pickle(total_face_labels_original,&quot;total_face_labels_original&quot;)</span>
    <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">total_face_labels</span><span class="p">)</span>
    
    <span class="c1">#0) Turn the mesh into a graph</span>
    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span><span class="p">:</span>
        <span class="n">total_mesh_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">curr_branch_mesh</span><span class="o">.</span><span class="n">face_adjacency</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#total_mesh_graph = tu.mesh_face_graph_by_vertex(curr_branch_mesh)</span>
        <span class="n">total_mesh_graph</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#1) Get the nodes that represent the border</span>
    <span class="n">border_faces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">vertices_coordinates_to_faces</span><span class="p">(</span><span class="n">curr_branch_mesh</span><span class="p">,</span><span class="n">border_vertices</span><span class="p">))</span>

    <span class="c1">#the face list of the label we want to expand at its current status</span>
    <span class="n">final_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_face_labels</span> <span class="o">==</span> <span class="n">label_to_expand</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 

    <span class="n">n_touching_soma</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_faces</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">final_faces</span><span class="p">)))</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="k">while</span> <span class="n">n_touching_soma</span> <span class="o">&lt;</span> <span class="n">n_touching_soma_threshold</span> <span class="ow">and</span> <span class="n">n_touching_soma</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_faces</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span><span class="p">:</span>
            <span class="n">final_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">total_mesh_graph</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">final_faces</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">face_neighbors_by_vertices</span><span class="p">(</span><span class="n">curr_branch_mesh</span><span class="p">,</span><span class="n">final_faces</span><span class="p">)</span>
            
        <span class="n">n_touching_soma</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_faces</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">final_faces</span><span class="p">)))</span>
        <span class="n">counter</span><span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="n">max_iterations</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t get the final faces to touch the somas border, before breaking&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">n_touching_soma = </span><span class="si">{</span><span class="n">n_touching_soma</span><span class="si">}</span><span class="s2">, final_faces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">final_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; border_faces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">border_faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span>


    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> iterations to expand the label back&quot;</span><span class="p">)</span>
        
    
    <span class="c1"># ------ 12/3 Addition to make sure no labels are overwritten --------#</span>
    <span class="n">face_lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,[</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">total_face_labels</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">f1</span> <span class="ow">in</span> <span class="n">final_faces</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">label_to_expand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">face_lookup</span><span class="p">[</span><span class="n">f1</span><span class="p">]:</span>
            <span class="n">face_lookup</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label_to_expand</span><span class="p">)</span>
        
<span class="c1">#     total_face_labels[final_faces] = label_to_expand</span>
<span class="c1">#     face_lookup = dict([(k,[v]) for k,v in enumerate(total_face_labels)])</span>
    
    
    <span class="n">total_face_labels</span> <span class="o">=</span> <span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span>
                     <span class="n">curr_limb_mesh</span><span class="o">=</span><span class="n">curr_branch_mesh</span><span class="p">,</span>
                     <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                     <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="n">no_missing_labels</span><span class="p">,</span>
                    <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                     <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">total_face_labels</span></div>


<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>