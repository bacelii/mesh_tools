<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mesh_tools.skeleton_utils &mdash; mesh_tools  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            mesh_tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">mesh_tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mesh_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mesh_tools.skeleton_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mesh_tools.skeleton_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>


<span class="sd">These functions will help with skeletonization</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">ipyvolume</span> <span class="k">as</span> <span class="nn">ipv</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">meshparty</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span><span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">rmtree</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>



<span class="n">max_stitch_distance_default</span> <span class="o">=</span> <span class="mi">10000</span>

<span class="c1">#--- for mesh subtraction ----</span>
<span class="n">mesh_subtraction_distance_threshold_default</span> <span class="o">=</span> <span class="mi">8_000</span>
<span class="n">mesh_subtraction_buffer_default</span> <span class="o">=</span> <span class="mi">1_000</span>

<div class="viewcode-block" id="compare_endpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.compare_endpoints">[docs]</a><span class="k">def</span> <span class="nf">compare_endpoints</span><span class="p">(</span><span class="n">endpioints_1</span><span class="p">,</span><span class="n">endpoints_2</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    comparing the endpoints of a graph: </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from python_tools import networkx_utils as xu</span>
<span class="sd">    xu = reload(xu)mess</span>
<span class="sd">    end_1 = np.array([[2,3,4],[1,4,5]])</span>
<span class="sd">    end_2 = np.array([[1,4,5],[2,3,4]])</span>

<span class="sd">    xu.compare_endpoints(end_1,end_2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#this older way mixed the elements of the coordinates together to just sort the columns</span>
    <span class="c1">#return np.array_equal(np.sort(endpoints_1,axis=0),np.sort(endpoints_2,axis=0))</span>
    
    <span class="c1">#this is correct way to do it (but has to be exact to return true)</span>
    <span class="c1">#return np.array_equal(nu.sort_multidim_array_by_rows(endpoints_1),nu.sort_multidim_array_by_rows(endpoints_2))</span>

    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="n">endpoints_1</span><span class="p">),</span>
                                <span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="n">endpoints_2</span><span class="p">),</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="save_skeleton_cgal"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.save_skeleton_cgal">[docs]</a><span class="k">def</span> <span class="nf">save_skeleton_cgal</span><span class="p">(</span><span class="n">surface_with_poisson_skeleton</span><span class="p">,</span><span class="n">largest_mesh_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    surface_with_poisson_skeleton (np.array) : nx2 matrix with the nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">first_node</span> <span class="o">=</span> <span class="n">surface_with_poisson_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end_nodes</span> <span class="o">=</span>  <span class="n">surface_with_poisson_skeleton</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">skeleton_to_write</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span>  <span class="nb">str</span><span class="p">(</span><span class="n">first_node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span>  <span class="nb">str</span><span class="p">(</span><span class="n">first_node</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">:</span>
        <span class="n">skeleton_to_write</span> <span class="o">+=</span>  <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span>  <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span>  <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">output_file</span> <span class="o">=</span> <span class="n">largest_mesh_path</span>
    <span class="k">if</span> <span class="n">output_file</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.cgal&quot;</span><span class="p">:</span>
        <span class="n">output_file</span> <span class="o">+=</span> <span class="s2">&quot;.cgal&quot;</span>
        
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">skeleton_to_write</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> </div>

<span class="c1">#read in the skeleton files into an array</span>
<div class="viewcode-block" id="read_skeleton_edges_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.read_skeleton_edges_coordinates">[docs]</a><span class="k">def</span> <span class="nf">read_skeleton_edges_coordinates</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">file_path</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;file_path not a string or list&quot;</span><span class="p">)</span>
    <span class="n">new_file_path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">file_path</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
            <span class="n">new_file_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">absolute</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_file_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="n">new_file_path</span>
    
    <span class="n">total_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fil</span> <span class="ow">in</span> <span class="n">file_path</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fil</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">bones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
                    <span class="c1">#print(line)</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:],</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="c1">#print(line[:-1])</span>
                    <span class="c1">#print(line[1:])</span>

                    <span class="c1">#print(bones.size)</span>
                    <span class="k">if</span> <span class="n">bones</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">bones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">bones</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))))</span>
                    <span class="c1">#print(bones)</span>
                <span class="n">total_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bones</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;file </span><span class="si">{</span><span class="n">fil</span><span class="si">}</span><span class="s2"> not found so skipping&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">stack_skeletons</span><span class="p">(</span><span class="n">total_skeletons</span><span class="p">)</span></div>
<span class="c1">#     if len(total_skeletons) &gt; 1:</span>
<span class="c1">#         returned_skeleton = np.vstack(total_skeletons)</span>
<span class="c1">#         return returned_skeleton</span>
<span class="c1">#     if len(total_skeletons) == 0:</span>
<span class="c1">#         print(&quot;There was no skeletons found for these files&quot;)</span>
<span class="c1">#     return np.array(total_skeletons).reshape(-1,2,3)</span>

<span class="c1">#read in the skeleton files into an array</span>
<div class="viewcode-block" id="read_skeleton_verts_edges"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.read_skeleton_verts_edges">[docs]</a><span class="k">def</span> <span class="nf">read_skeleton_verts_edges</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">bones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="c1">#print(line)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:],</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1">#print(line[:-1])</span>
            <span class="c1">#print(line[1:])</span>

            <span class="c1">#print(bones.size)</span>
            <span class="k">if</span> <span class="n">bones</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">bones</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))))</span>
            <span class="c1">#print(bones)</span>
    
    <span class="n">bones_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bones</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="c1">#unpacks so just list of vertices</span>
    <span class="n">vertices_unpacked</span>  <span class="o">=</span> <span class="n">bones_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#reduce the number of repeat vertices and convert to list</span>
    <span class="n">unique_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vertices_unpacked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">unique_rows_list</span> <span class="o">=</span> <span class="n">unique_rows</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1">#assigns the number to the vertex (in the original vertex list) that corresponds to the index in the unique list</span>
    <span class="n">vertices_unpacked_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unique_rows_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">vertices_unpacked</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>

    <span class="c1">#reshapes the vertex list to become an edge list (just with the labels so can put into netowrkx graph)</span>
    <span class="n">edges_with_coefficients</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices_unpacked_coefficients</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unique_rows</span><span class="p">,</span> <span class="n">edges_with_coefficients</span></div>


<div class="viewcode-block" id="skeleton_unique_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_unique_coordinates">[docs]</a><span class="k">def</span> <span class="nf">skeleton_unique_coordinates</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="convert_nodes_edges_to_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_nodes_edges_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">convert_nodes_edges_to_skeleton</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nodes</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span></div>

<div class="viewcode-block" id="convert_skeleton_to_nodes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_skeleton_to_nodes">[docs]</a><span class="k">def</span> <span class="nf">convert_skeleton_to_nodes</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="c1">#unpacks so just list of vertices</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">vertices_unpacked</span>  <span class="o">=</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#reduce the number of repeat vertices and convert to list</span>
    <span class="n">unique_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vertices_unpacked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_rows</span></div>

<span class="n">convert_skeleton_to_coordinates</span> <span class="o">=</span> <span class="n">convert_skeleton_to_nodes</span>
    
<div class="viewcode-block" id="convert_skeleton_to_nodes_edges"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_skeleton_to_nodes_edges">[docs]</a><span class="k">def</span> <span class="nf">convert_skeleton_to_nodes_edges</span><span class="p">(</span><span class="n">bones_array</span><span class="p">):</span>
    <span class="c1">#unpacks so just list of vertices</span>
    <span class="n">bones_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bones_array</span><span class="p">)</span>
    
    <span class="n">vertices_unpacked</span>  <span class="o">=</span> <span class="n">bones_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#reduce the number of repeat vertices and convert to list</span>
    <span class="n">unique_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vertices_unpacked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">unique_rows_list</span> <span class="o">=</span> <span class="n">unique_rows</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1">#assigns the number to the vertex (in the original vertex list) that corresponds to the index in the unique list</span>
    <span class="n">vertices_unpacked_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unique_rows_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">vertices_unpacked</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>

    <span class="c1">#reshapes the vertex list to become an edge list (just with the labels so can put into netowrkx graph)</span>
    <span class="n">edges_with_coefficients</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices_unpacked_coefficients</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unique_rows</span><span class="p">,</span> <span class="n">edges_with_coefficients</span></div>

<div class="viewcode-block" id="convert_skeleton_to_nodes_edges_optimized"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_skeleton_to_nodes_edges_optimized">[docs]</a><span class="k">def</span> <span class="nf">convert_skeleton_to_nodes_edges_optimized</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: will return the nodes and edges but without making the nodes unique</span>
<span class="sd">    (so will have some repeats)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_rows</span>  <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">curr_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_rows</span><span class="p">,</span> <span class="n">curr_edges</span></div>

<div class="viewcode-block" id="calculate_skeleton_segment_distances"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.calculate_skeleton_segment_distances">[docs]</a><span class="k">def</span> <span class="nf">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">my_skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">segment_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">my_skeleton</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">my_skeleton</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cumsum</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">segment_distances</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">segment_distances</span></div>
    
<div class="viewcode-block" id="calculate_coordinate_distances_cumsum"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.calculate_coordinate_distances_cumsum">[docs]</a><span class="k">def</span> <span class="nf">calculate_coordinate_distances_cumsum</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span></div>

<div class="viewcode-block" id="calculate_skeleton_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.calculate_skeleton_distance">[docs]</a><span class="k">def</span> <span class="nf">calculate_skeleton_distance</span><span class="p">(</span><span class="n">my_skeleton</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">total_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">my_skeleton</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">my_skeleton</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_distance</span><span class="p">)</span></div>

<span class="n">calculate_skeletal_distance</span> <span class="o">=</span> <span class="n">calculate_skeleton_distance</span>
<span class="n">calculate_skeletal_length</span> <span class="o">=</span> <span class="n">calculate_skeleton_distance</span>

<div class="viewcode-block" id="plot_ipv_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.plot_ipv_mesh">[docs]</a><span class="k">def</span> <span class="nf">plot_ipv_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span>
                 <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="c1">#print(&quot;inside elephant flipping copy&quot;)</span>
        <span class="n">elephant_mesh_sub</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">elephant_mesh_sub</span> <span class="o">=</span> <span class="n">mesh</span>
    
    
    <span class="c1">#check if the color is a dictionary</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1">#get the type of values stored in there</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">color</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        
        <span class="c1">#if the labels were stored as just numbers/decimals</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
            <span class="c1">#get all of the possible labels</span>
            <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#get random colors for all of the labels</span>
            <span class="n">colors_list</span> <span class="o">=</span>  <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span><span class="n">n_colors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lab</span><span class="p">,</span><span class="n">curr_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span><span class="n">colors_list</span><span class="p">):</span>
                <span class="c1">#find the faces that correspond to that label</span>
                <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">color</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">lab</span><span class="p">]</span>
                <span class="c1">#draw the mesh with that color</span>
                <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces_to_keep</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="n">mesh4</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                               <span class="n">triangles</span><span class="o">=</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
                <span class="n">mesh4</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">curr_color</span>
                <span class="n">mesh4</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>          
        <span class="n">mesh4</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">triangles</span><span class="o">=</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="n">mesh4</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="n">mesh4</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span></div>
        

<div class="viewcode-block" id="plot_ipv_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.plot_ipv_skeleton">[docs]</a><span class="k">def</span> <span class="nf">plot_ipv_skeleton</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(&quot;Edge coordinates in plot_ipv_skeleton were of 0 length so returning&quot;)</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">edge_coordinates</span> <span class="o">=</span> <span class="n">edge_coordinates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">edge_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">edge_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
    
    <span class="c1">#print(f&quot;edge_coordinates inside after change = {edge_coordinates}&quot;)</span>
    <span class="n">unique_skeleton_verts_final</span><span class="p">,</span><span class="n">edges_final</span> <span class="o">=</span> <span class="n">convert_skeleton_to_nodes_edges_optimized</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span>
    <span class="n">mesh2</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> 
                            <span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> 
                            <span class="n">lines</span><span class="o">=</span><span class="n">edges_final</span><span class="p">)</span>
    <span class="c1">#print(f&quot;color in ipv_skeleton = {color}&quot;)</span>
    <span class="n">mesh2</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span> 
    <span class="n">mesh2</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1">#print(f&quot;Color in skeleton ipv plot = {color}&quot;)</span>

    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">unique_skeleton_verts_final</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">unique_skeleton_verts_final</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">unique_skeleton_verts_final</span></div>

<div class="viewcode-block" id="plot_ipv_scatter"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.plot_ipv_scatter">[docs]</a><span class="k">def</span> <span class="nf">plot_ipv_scatter</span><span class="p">(</span><span class="n">scatter_points</span><span class="p">,</span><span class="n">scatter_color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span>
                    <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                    <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scatter_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> 
    
    <span class="n">scatter_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">scatter_points</span> <span class="o">=</span> <span class="n">scatter_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scatter_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scatter_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">#     print(f&quot;scatter_points[:,0] = {scatter_points[:,0]}&quot;)</span>
<span class="c1">#     print(f&quot;scatter_points[:,1] = {scatter_points[:,1]}&quot;)</span>
<span class="c1">#     print(f&quot;scatter_points[:,2] = {scatter_points[:,2]}&quot;)</span>
<span class="c1">#     print(f&quot;scatter_size = {scatter_size}&quot;)</span>
<span class="c1">#     print(f&quot;scatter_color = {scatter_color}&quot;)</span>
    <span class="n">mesh_5</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">scatter_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
            <span class="n">scatter_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">scatter_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> 
            <span class="n">size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> 
            <span class="n">color</span><span class="o">=</span><span class="n">scatter_color</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;sphere&quot;</span><span class="p">)</span>
    <span class="n">mesh_5</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="graph_skeleton_and_mesh"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.graph_skeleton_and_mesh">[docs]</a><span class="k">def</span> <span class="nf">graph_skeleton_and_mesh</span><span class="p">(</span><span class="n">main_mesh_verts</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">main_mesh_faces</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">unique_skeleton_verts_final</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">edges_final</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">edge_coordinates</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">other_meshes</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">other_meshes_colors</span> <span class="o">=</span>  <span class="p">[],</span>
                            <span class="n">mesh_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                            <span class="n">other_meshes_face_components</span> <span class="o">=</span> <span class="p">[],</span>
                            <span class="n">other_skeletons</span> <span class="o">=</span> <span class="p">[],</span>
                            <span class="n">other_skeletons_colors</span> <span class="o">=</span>  <span class="p">[],</span>
                            <span class="n">return_other_colors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">main_mesh_color</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span>
                            <span class="n">main_skeleton_color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">main_mesh_face_coloring</span> <span class="o">=</span> <span class="p">[],</span>
                            <span class="n">other_scatter</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">scatter_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
                            <span class="n">other_scatter_colors</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">main_scatter_color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span>
                            <span class="n">scatter_with_widgets</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                           <span class="n">axis_box_off</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">html_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                           <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">append_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">set_zoom</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">adaptive_min_max_limits</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Graph the final result of skeleton and mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode on how to do face colorings :</span>
<span class="sd">    could get a dictionary mapping faces to colors or groups</span>
<span class="sd">    - if mapped to groups then do random colors (and generate them)</span>
<span class="sd">    - if mapped to colors then just do submeshes and send the colors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(f&quot;other_scatter = {other_scatter}&quot;)</span>
    <span class="c1">#print(f&quot;mesh_alpha = {mesh_alpha}&quot;)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">append_figure</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
    
    <span class="n">main_mesh_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="c1">#print(&quot;Working on main skeleton&quot;)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_skeleton_verts_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
            <span class="n">edge_coordinates</span> <span class="o">=</span> <span class="n">edge_coordinates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">edge_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">edge_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">unique_skeleton_verts_final</span><span class="p">,</span><span class="n">edges_final</span> <span class="o">=</span> <span class="n">convert_skeleton_to_nodes_edges_optimized</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span>
        <span class="n">mesh2</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                                <span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> 
                                <span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> 
                                <span class="n">lines</span><span class="o">=</span><span class="n">edges_final</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>

        <span class="n">mesh2</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">main_skeleton_color</span> 
        <span class="n">mesh2</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
            <span class="n">unique_skeleton_verts_final</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">unique_skeleton_verts_final</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_skeleton_verts_final</span><span class="p">)</span>
    
    <span class="c1">#print(&quot;Working on main mesh&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_verts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_face_coloring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#will go through and color the faces of the main mesh if any sent</span>
            <span class="k">for</span> <span class="n">face_array</span><span class="p">,</span><span class="n">face_color</span> <span class="ow">in</span> <span class="n">main_mesh_face_coloring</span><span class="p">:</span>
                <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_array</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_mesh</span><span class="p">,</span><span class="n">face_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
                <span class="n">main_mesh_verts</span> <span class="o">=</span> <span class="n">main_mesh_verts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">main_mesh_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">main_mesh_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">main_mesh_verts</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">main_mesh_faces</span><span class="p">)</span>

            <span class="n">mesh3</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">main_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">main_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">triangles</span><span class="o">=</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            
            <span class="n">mesh3</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">main_mesh_color</span>
            <span class="n">mesh3</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="c1">#flipping them back</span>
            <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
                <span class="n">main_mesh_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">main_mesh_verts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main_mesh_verts</span><span class="p">)</span>
        
    
    <span class="c1"># cast everything to list type</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">other_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_meshes</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_meshes_colors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_meshes_colors</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">other_meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_meshes_colors</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">other_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_skeletons</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_skeletons_colors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_skeletons_colors</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">other_skeletons_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_skeletons_colors</span><span class="p">]</span>
        
<span class="c1">#     if type(other_scatter) != list and type(other_scatter) != np.ndarray:</span>
<span class="c1">#         other_scatter = [other_scatter]</span>
<span class="c1">#     if type(other_scatter_colors) != list and type(other_scatter_colors) != np.ndarray:</span>
<span class="c1">#         other_scatter_colors = [other_scatter_colors]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">other_scatter</span><span class="p">):</span>
        <span class="n">other_scatter</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_scatter</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">other_scatter_colors</span><span class="p">):</span>
        <span class="n">other_scatter_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_scatter_colors</span><span class="p">]</span>
    
        
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_meshes_face_components</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">other_meshes_colors</span> <span class="o">=</span> <span class="n">other_meshes_face_components</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_meshes_colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">other_meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_mesh_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#get the locations of all of the dictionaries</span>
            <span class="k">if</span> <span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">other_meshes_colors</span><span class="p">:</span>
                <span class="n">other_meshes_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span>
                            <span class="n">user_colors</span><span class="o">=</span><span class="p">[],</span> <span class="c1">#if user sends a prescribed list</span>
                            <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">),</span>
                            <span class="c1">#colors_to_omit=[&quot;green&quot;,&quot;blue&quot;], #because that is the one used for the main mesh</span>
                            <span class="n">alpha_level</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other_meshes_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span>
                            <span class="n">user_colors</span><span class="o">=</span><span class="n">other_meshes_colors</span><span class="p">,</span> <span class="c1">#if user sends a prescribed list</span>
                            <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">),</span>
                            <span class="c1">#colors_to_omit=[&quot;green&quot;,&quot;blue&quot;], #because that is the one used for the main mesh</span>
                            <span class="n">alpha_level</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">)</span>
            
    
       
    <span class="c1">#print(&quot;Working on other meshes&quot;)</span>
    <span class="k">for</span> <span class="n">curr_mesh</span><span class="p">,</span><span class="n">curr_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other_meshes</span><span class="p">,</span><span class="n">other_meshes_colors</span><span class="p">):</span>
        <span class="c1">#print(f&quot;flip_y = {flip_y}&quot;)</span>
        <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">curr_mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    
    
    <span class="c1">#print(&quot;Working on other skeletons&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_skeletons_colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">other_skeletons_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_skeleton_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;random&quot;</span> <span class="ow">in</span> <span class="n">other_skeletons_colors</span><span class="p">:</span>
            <span class="n">other_skeletons_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span>
                        <span class="n">user_colors</span><span class="o">=</span><span class="p">[],</span> <span class="c1">#if user sends a prescribed list</span>
                        <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">),</span>
                        <span class="c1">#colors_to_omit=[&quot;green&quot;,&quot;blue&quot;], #because that is the one used for the main mesh</span>
                        <span class="n">alpha_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">other_skeletons_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span>
                        <span class="n">user_colors</span><span class="o">=</span><span class="n">other_skeletons_colors</span><span class="p">,</span> <span class="c1">#if user sends a prescribed list</span>
                        <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">),</span>
                        <span class="c1">#colors_to_omit=[&quot;green&quot;,&quot;blue&quot;], #because that is the one used for the main mesh</span>
                        <span class="n">alpha_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(f&quot;user colors picked for other_skeletons_colors = {other_skeletons_colors}&quot;)</span>
    
        
    <span class="k">for</span> <span class="n">curr_sk</span><span class="p">,</span><span class="n">curr_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other_skeletons</span><span class="p">,</span><span class="n">other_skeletons_colors</span><span class="p">):</span>
        <span class="n">sk_vertices</span> <span class="o">=</span> <span class="n">plot_ipv_skeleton</span><span class="p">(</span><span class="n">curr_sk</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
        
        <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk_vertices</span><span class="p">)</span>
        
        
    <span class="c1">#printing the scatter plots</span>
    <span class="c1">#print(&quot;Working on other scatter plots&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_scatter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_scatter_colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">other_scatter_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_scatter_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">other_scatter</span><span class="p">)</span>
        
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_scatter_colors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_scatter</span><span class="p">):</span>
        <span class="n">other_scatter_colors</span> <span class="o">+=</span> <span class="n">other_scatter_colors</span>
        
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">scatter_size</span><span class="p">):</span>
        <span class="n">scatter_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">scatter_size</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">other_scatter</span><span class="p">)</span>
        
    
    <span class="k">for</span> <span class="n">curr_scatter</span><span class="p">,</span><span class="n">curr_color</span><span class="p">,</span><span class="n">curr_size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other_scatter</span><span class="p">,</span><span class="n">other_scatter_colors</span><span class="p">,</span><span class="n">scatter_size</span><span class="p">):</span>
<span class="c1">#         print(f&quot;curr_scatter = {curr_scatter}&quot;)</span>
<span class="c1">#         print(f&quot;curr_color = {curr_color}&quot;)</span>
<span class="c1">#         print(f&quot;curr_size= {curr_size}&quot;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scatter_with_widgets</span><span class="p">:</span>
            <span class="n">plot_ipv_scatter</span><span class="p">(</span><span class="n">curr_scatter</span><span class="p">,</span><span class="n">scatter_color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span>
                        <span class="n">scatter_size</span><span class="o">=</span><span class="n">curr_size</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
        <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_scatter</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">scatter_with_widgets</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_multi_scatters</span><span class="p">(</span>
            <span class="n">other_scatter</span><span class="p">,</span><span class="n">other_scatter_colors</span><span class="p">,</span><span class="n">scatter_size</span><span class="p">,</span>
            <span class="n">show_at_end</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">flip_y</span> <span class="o">=</span> <span class="n">flip_y</span><span class="p">,</span>
        <span class="p">)</span>


    <span class="c1">#create the main mesh vertices for setting the bounding box</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No meshes or skeletons passed to the plotting funciton&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">main_mesh_vertices</span> <span class="o">=</span> <span class="n">main_mesh_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#get rid of all empt</span>
        <span class="c1">#print(f&quot;main_mesh_vertices = {main_mesh_vertices}&quot;)</span>
        <span class="n">main_mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">main_mesh_vertices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;***There is nothing to plot***&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    

<span class="c1">#     print(f&quot;main_mesh_vertices = {main_mesh_vertices}&quot;)</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">main_mesh_vertices</span> <span class="o">=</span> <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">main_mesh_vertices</span> <span class="o">=</span> <span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">main_mesh_vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">main_mesh_vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    

    <span class="n">volume_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">volume_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">main_mesh_vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
<span class="c1">#     if len(main_mesh_vertices) &lt; 10:</span>
<span class="c1">#         print(f&quot;main_mesh_vertices = {main_mesh_vertices}&quot;)</span>
<span class="c1">#     print(f&quot;volume_max= {volume_max}&quot;)</span>
<span class="c1">#     print(f&quot;volume_min= {volume_min}&quot;)</span>

    <span class="n">ranges</span> <span class="o">=</span> <span class="n">volume_max</span> <span class="o">-</span> <span class="n">volume_min</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
    <span class="n">min_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">max_index</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">adaptive_min_max_limits</span><span class="p">:</span>
            <span class="n">min_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer</span>
            <span class="n">max_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer</span> 
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">min_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span>  <span class="o">-</span> <span class="n">buffer</span>
            <span class="n">max_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">buffer</span>
            
<span class="c1">#     print(f&quot;min_limits= {min_limits}&quot;)</span>
<span class="c1">#     print(f&quot;max_limits= {max_limits}&quot;)</span>

    <span class="c1">#ipv.xyzlim(-2, 2)</span>
    
    <span class="k">if</span> <span class="n">set_zoom</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">min_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">max_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">min_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">max_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">zlim</span><span class="p">(</span><span class="n">min_limits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">max_limits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">set_style_light</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis_box_off</span><span class="p">:</span>
            <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">axes_off</span><span class="p">()</span>
            <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">box_off</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">axes_on</span><span class="p">()</span>
            <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">box_on</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">html_path</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">html_path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_other_colors</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">other_meshes_colors</span></div>
<span class="w">        </span>


<span class="sd">&quot;&quot;&quot; ------------------- Mesh subtraction ------------------------------------&quot;&quot;&quot;</span>
<span class="c1">#make sure pip3 install trimesh --upgrade so can have slice</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">calcification_Module</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="c1">#  Utility functions</span>
<span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                           <span class="p">])</span>

<div class="viewcode-block" id="gram_schmidt_columns"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.gram_schmidt_columns">[docs]</a><span class="k">def</span> <span class="nf">gram_schmidt_columns</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Q</span></div>
<div class="viewcode-block" id="change_basis_matrix"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.change_basis_matrix">[docs]</a><span class="k">def</span> <span class="nf">change_basis_matrix</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This just gives change of basis matrix for a basis </span>
<span class="sd">    that has the vector v as its 3rd basis vector</span>
<span class="sd">    and the other 2 vectors orthogonal to v </span>
<span class="sd">    (but not necessarily orthogonal to each other)</span>
<span class="sd">    *** not make an orthonormal basis ***</span>
<span class="sd">    </span>
<span class="sd">    -- changed so now pass the non-orthogonal components</span>
<span class="sd">    to the QR decomposition to get them as orthogonal</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1">#print(f&quot;a,b,c = {(a,b,c)}&quot;)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">:</span>
        <span class="n">v_z</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">v_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="p">])</span>
        <span class="c1">#v_x = v_x/np.linalg.norm(v_x)</span>
        <span class="n">v_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="o">/</span><span class="n">c</span><span class="p">])</span>
        <span class="c1">#v_y = v_y/np.linalg.norm(v_y)</span>
        <span class="n">v_x</span><span class="p">,</span> <span class="n">v_y</span> <span class="o">=</span> <span class="n">gram_schmidt_columns</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v_x</span><span class="p">,</span><span class="n">v_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v_x</span><span class="p">,</span><span class="n">v_y</span><span class="p">,</span><span class="n">v_z</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&quot;Z coeffienct too small&quot;)</span>
        <span class="c1">#v_z = v</span>
        <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#print(f&quot;before norm v_z = {v}&quot;)</span>
        <span class="n">v_z</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1">#print(f&quot;after norm v_z = {v_z}&quot;)</span>
        
        <span class="n">v_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">v_y</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="nd">@v_z</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v_x</span><span class="p">,</span><span class="n">v_y</span><span class="p">,</span><span class="n">v_z</span><span class="p">])</span></div>

<div class="viewcode-block" id="mesh_subtraction_by_skeleton_old"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.mesh_subtraction_by_skeleton_old">[docs]</a><span class="k">def</span> <span class="nf">mesh_subtraction_by_skeleton_old</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span>
                                 <span class="n">buffer</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                <span class="n">bbox_ratio</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                                 <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                             <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return significant mesh pieces that are</span>
<span class="sd">    not already accounteed for by the skeleton</span>
<span class="sd">    </span>
<span class="sd">    Example of how to run</span>
<span class="sd">    </span>
<span class="sd">    main_mesh_path = Path(&quot;./Dustin/Dustin.off&quot;)</span>
<span class="sd">    main_mesh = trimesh.load_mesh(str(main_mesh_path.absolute()))</span>
<span class="sd">    skeleton_path = main_mesh_path.parents[0] / Path(main_mesh_path.stem + &quot;_skeleton.cgal&quot;)</span>
<span class="sd">    edges = sk.read_skeleton_edges_coordinates(str(skeleton_path.absolute()))</span>

<span class="sd">    # turn this into nodes and edges</span>
<span class="sd">    main_mesh_nodes, main_mesh_edges = sk.read_skeleton_verts_edges(str(skeleton_path.absolute()))</span>
<span class="sd">    sk.graph_skeleton_and_mesh(</span>
<span class="sd">                main_mesh_verts=main_mesh.vertices,</span>
<span class="sd">                main_mesh_faces=main_mesh.faces,</span>
<span class="sd">                unique_skeleton_verts_final = main_mesh_nodes,</span>
<span class="sd">                edges_final=main_mesh_edges,</span>
<span class="sd">                buffer = 0</span>
<span class="sd">                              )</span>
<span class="sd">                              </span>
<span class="sd">    leftover_pieces =  mesh_subtraction_by_skeleton(main_mesh,edges,</span>
<span class="sd">                                 buffer=0.01,</span>
<span class="sd">                                bbox_ratio=1.2,</span>
<span class="sd">                                 distance_threshold=500,</span>
<span class="sd">                             significance_threshold=500,</span>
<span class="sd">                                print_flag=False)</span>
<span class="sd">                                </span>
<span class="sd">    # Visualize the results: </span>
<span class="sd">    pieces_mesh = trimesh.Trimesh(vertices=np.array([]),</span>
<span class="sd">                                 faces=np.array([]))</span>

<span class="sd">    for l in leftover_pieces:</span>
<span class="sd">        pieces_mesh += l</span>

<span class="sd">    sk.graph_skeleton_and_mesh(</span>
<span class="sd">                main_mesh_verts=pieces_mesh.vertices,</span>
<span class="sd">                main_mesh_faces=pieces_mesh.faces,</span>
<span class="sd">                unique_skeleton_verts_final = main_mesh_nodes,</span>
<span class="sd">                edges_final=main_mesh_edges,</span>
<span class="sd">                buffer = 0</span>
<span class="sd">                              )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">skeleton_nodes</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">skeleton_bounding_corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
               <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
    
    <span class="n">main_mesh_bbox_restricted</span><span class="p">,</span> <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bbox_mesh_restriction</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span>
                                                                        <span class="n">skeleton_bounding_corners</span><span class="p">,</span>
                                                                        <span class="n">bbox_ratio</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inside mesh subtraction, len(main_mesh_bbox_restricted.faces) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;***** Bounding Box Restricted Mesh is empty ****&quot;</span><span class="p">)</span>
        <span class="n">main_mesh_bbox_restricted</span> <span class="o">=</span> <span class="n">main_mesh</span>
        <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#face_subtract_color = []</span>
    <span class="n">face_subtract_indices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#distance_threshold = 2000</span>
    
    <span class="n">edge_loop_print</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ex_edge</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
        <span class="c1">#print(&quot;\n------ New loop ------&quot;)</span>
        <span class="c1">#print(ex_edge)</span>
        
        <span class="c1"># ----------- creating edge and checking distance ----- #</span>
        <span class="n">loop_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">edge_line</span> <span class="o">=</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sum_threshold</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">edge_line</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">sum_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge number </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ex_edge</span><span class="si">}</span><span class="s2">: has sum less than </span><span class="si">{</span><span class="n">sum_threshold</span><span class="si">}</span><span class="s2"> so skipping&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Checking Edge Distance = {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>
        
        <span class="n">cob_edge</span> <span class="o">=</span> <span class="n">change_basis_matrix</span><span class="p">(</span><span class="n">edge_line</span><span class="p">)</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Change of Basis Matrix calculation = {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start - time.time()</span>
        
        <span class="c1">#get the limits of the example edge itself that should be cutoff</span>
        <span class="n">edge_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">cob_edge</span><span class="nd">@ex_edge</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1">#slice_range = np.sort((cob_edge@ex_edge.T)[2,:])</span>
        <span class="n">slice_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span>

        <span class="c1"># adding the buffer to the slice range</span>
        <span class="n">slice_range_buffer</span> <span class="o">=</span> <span class="n">slice_range</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">buffer</span><span class="p">,</span><span class="n">buffer</span><span class="p">])</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Calculate slice= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>

        <span class="c1"># generate face midpoints from the triangles</span>
        <span class="c1">#face_midpoints = np.mean(main_mesh_bbox_restricted.vertices[main_mesh_bbox_restricted.faces],axis=1) # Old way</span>
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">triangles_center</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Face midpoints= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>
        
        <span class="c1">#get the face midpoints that fall within the slice (by lookig at the z component)</span>
        <span class="n">fac_midpoints_trans</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@face_midpoints</span><span class="o">.</span><span class="n">T</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Face midpoints transform= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>
        
        
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;edge midpoint= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>
        
        <span class="n">slice_mask_pre_distance</span> <span class="o">=</span> <span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&gt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                      <span class="p">(</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&lt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Applying slice restriction = {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; 6/18 change</span>
<span class="sd">        # apply the distance threshold to the slice mask</span>
<span class="sd">        edge_midpoint = np.mean(ex_edge,axis=0)</span>
<span class="sd">        #raise Exception(&quot;Add in part for distance threshold here&quot;)</span>
<span class="sd">        distance_check = np.linalg.norm(face_midpoints[:,:2] - edge_midpoint[:2],axis=1) &lt; distance_threshold</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
<span class="c1">#         edge_midpoint = np.mean(cob_edge.T,axis=0)</span>
<span class="c1">#         distance_check = np.linalg.norm((fac_midpoints_trans.T)[:,:2] - edge_midpoint[:2],axis=1) &lt; distance_threshold</span>

        <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edge_trans</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">distance_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">edge_midpoint</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span>
        

        <span class="n">slice_mask</span> <span class="o">=</span> <span class="n">slice_mask_pre_distance</span> <span class="o">&amp;</span> <span class="n">distance_check</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;Applying distance restriction= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>


        <span class="n">face_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">faces</span><span class="p">))[</span><span class="n">slice_mask</span><span class="p">]</span>

        <span class="c1">#get the submesh of valid faces within the slice</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_list</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="p">[]</span>
        
        

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;THERE WERE NO FACES THAT FIT THE DISTANCE (</span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2">) and Z transform requirements&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;So just skipping this edge&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;getting submesh= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>
        
        <span class="c1">#get all disconnected mesh pieces of the submesh and the face indices for lookup later</span>
        <span class="n">sub_components</span><span class="p">,</span><span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1">#print(f&quot;meshes = {sub_components}, with type = {type(sub_components)}&quot;)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">())</span> <span class="p">:</span>
                <span class="n">sub_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_components</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The sub_components were not an array, list or trimesh&quot;</span><span class="p">)</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;splitting the mesh= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>

        <span class="c1">#getting the indices of the submeshes whose bounding box contain the edge </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; 6-19: might want to use bounding_box_oriented? BUT THIS CHANGE COULD SLOW IT DOWN</span>
<span class="sd">        contains_points_results = np.array([s_comp.bounding_box_oriented.contains(ex_edge.reshape(-1,3)) for s_comp in sub_components])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contains_points_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s_comp</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ex_edge</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">s_comp</span> <span class="ow">in</span> <span class="n">sub_components</span><span class="p">])</span>
        
        <span class="n">containing_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)))[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contains_points_results</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">)]</span>
        
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#             print(f&quot;containing indices= {time.time()-loop_start}&quot;)</span>
<span class="c1">#         loop_start = time.time()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Not exactly one containing mesh: </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sub_components_inner</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">]</span>
                    <span class="n">sub_components_face_indexes_inner</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sub_components_inner</span> <span class="o">=</span> <span class="n">sub_components</span>
                    <span class="n">sub_components_face_indexes_inner</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span>

                <span class="c1">#get the center of the edge</span>
                <span class="n">edge_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#print(f&quot;edge_center = {edge_center}&quot;)</span>

                <span class="c1">#find the distance between eacch bbox center and the edge center</span>
                <span class="n">bbox_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub_components_inner</span><span class="p">]</span>
                <span class="c1">#print(f&quot;bbox_centers = {bbox_centers}&quot;)</span>
                <span class="n">closest_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">edge_center</span><span class="o">-</span><span class="n">b_center</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_center</span> <span class="ow">in</span> <span class="n">bbox_centers</span><span class="p">])</span>
                <span class="c1">#print(f&quot;bbox_distance = {closest_bbox}&quot;)</span>
                <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes_inner</span><span class="p">[</span><span class="n">closest_bbox</span><span class="p">]]]</span>

    <span class="c1">#             if edge_loop_print:</span>
    <span class="c1">#                 print(f&quot;finding closest box when 0 or 2 or more containing boxes= {time.time()-loop_start}&quot;)</span>
    <span class="c1">#             loop_start = time.time()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span><span class="c1"># when only one viable submesh piece and just using that sole index</span>
                <span class="c1">#print(f&quot;only one viable submesh piece so using index only number in: {containing_indices}&quot;)</span>

                <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)]]</span>
    <span class="c1">#             if edge_loop_print:</span>
    <span class="c1">#                 print(f&quot;only 1 containig face getting the edge_skeleton_faces= {time.time()-loop_start}&quot;)</span>
    <span class="c1">#             loop_start = time.time()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No contianing indices&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">,</span><span class="s2">&quot;main_mesh_sub&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">,</span><span class="s2">&quot;ex_edge&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">sub_components_face_indexes</span><span class="p">,</span><span class="s2">&quot;sub_components_face_indexes&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">,</span><span class="s2">&quot;containing_indices&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">face_list</span><span class="p">,</span><span class="s2">&quot;face_list&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">faces_bbox_inclusion</span><span class="p">,</span><span class="s2">&quot;faces_bbox_inclusion&quot;</span><span class="p">)</span>
            
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Indexing not work in mesh subtraction&quot;</span><span class="p">)</span>

            
            
            
            

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;****** Warning the edge index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: had no faces in the edge_skeleton_faces*******&quot;</span><span class="p">)</span>
        <span class="n">face_subtract_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span>
<span class="c1">#         if edge_loop_print:</span>
<span class="c1">#                 print(f&quot;check and append for face= {time.time()-loop_start}&quot;)</span>
        <span class="c1">#face_subtract_color.append(viable_colors[i%len(viable_colors)])</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Mesh subtraction time = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">all_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span>

        <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_removed_faces</span><span class="p">)</span>

        <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">unique_removed_faces</span><span class="p">)</span>
        <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">faces_to_keep</span><span class="p">)],</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">main_mesh</span>
    
    <span class="n">significant_pieces</span> <span class="o">=</span> <span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span>
                                                         <span class="n">significance_threshold</span><span class="p">,</span>
                                                         <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">significant_pieces</span></div>

<span class="sd">&quot;&quot;&quot; ------------------- End of Mesh Subtraction ------------------------------------&quot;&quot;&quot;</span>



<span class="sd">&quot;&quot;&quot; ----------Start of Surface Skeeltonization -- &quot;&quot;&quot;</span>



<span class="c1"># # Older version that was not working properly</span>
<span class="c1"># def generate_surface_skeleton(vertices,</span>
<span class="c1">#                               faces, </span>
<span class="c1">#                               surface_samples=1000,</span>
<span class="c1">#                           print_flag=False):</span>
    
<span class="c1">#     #return surface_with_poisson_skeleton,path_length</span>
    
<span class="c1">#     mesh = trimesh.Trimesh(vertices=vertices,</span>
<span class="c1">#                                   faces = faces,</span>
<span class="c1">#                            )</span>


<span class="c1">#     start_time = time.time()</span>

<span class="c1">#     ga = nx.from_edgelist(mesh.edges)</span>

<span class="c1">#     if surface_samples&lt;len(vertices):</span>
<span class="c1">#         k = surface_samples</span>
<span class="c1">#     else:</span>
<span class="c1">#         k = len(vertices)</span>
<span class="c1">#     sampled_nodes = random.sample(ga.nodes, k)</span>


<span class="c1">#     lp_end_list = []</span>
<span class="c1">#     lp_magnitude_list = []</span>

<span class="c1">#     for s in sampled_nodes: </span>
<span class="c1">#         sp_dict = nx.single_source_shortest_path_length(ga,s)</span>

<span class="c1">#         list_keys = list(sp_dict.keys())</span>
<span class="c1">#         longest_path_node = list_keys[len(list_keys)-1]</span>
<span class="c1">#         longest_path_magnitude = sp_dict[longest_path_node]</span>


<span class="c1">#         lp_end_list.append(longest_path_node)</span>
<span class="c1">#         lp_magnitude_list.append(longest_path_magnitude)</span>

<span class="c1">#     #construct skeleton from shortest path</span>
<span class="c1">#     final_start = sampled_nodes[np.argmax(lp_magnitude_list)]</span>
<span class="c1">#     final_end = sampled_nodes[np.argmax(lp_end_list)]</span>

<span class="c1">#     node_list = nx.shortest_path(ga,final_start,final_end)</span>
<span class="c1">#     if len(node_list) &lt; 2:</span>
<span class="c1">#         print(&quot;node_list len &lt; 2 so returning empty list&quot;)</span>
<span class="c1">#         return np.array([])</span>
<span class="c1">#     #print(&quot;node_list = &quot; + str(node_list))</span>

<span class="c1">#     final_skeleton = mesh.vertices[np.vstack([node_list[:-1],node_list[1:]]).T]</span>
<span class="c1">#     if print_flag:</span>
<span class="c1">#         print(f&quot;   Final Time for surface skeleton with sample size = {k} = {time.time() - start_time}&quot;)</span>

<span class="c1">#     return final_skeleton</span>


<div class="viewcode-block" id="generate_surface_skeleton_slower"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.generate_surface_skeleton_slower">[docs]</a><span class="k">def</span> <span class="nf">generate_surface_skeleton_slower</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span>
                              <span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                              <span class="n">surface_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                              <span class="n">n_surface_downsampling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Generates a surface skeleton without using</span>
<span class="sd">    the root method and instead just samples points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#return surface_with_poisson_skeleton,path_length</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span>
                                  <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">,</span>
                           <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span>


    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">ga</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">surface_samples</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="n">sampled_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="n">surface_samples</span> <span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of surface samples exceeded number of vertices, using len(vertices)&quot;</span><span class="p">)</span>
        <span class="n">sampled_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>
        
    <span class="n">lp_end_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lp_magnitude_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sampled_nodes</span><span class="p">:</span> 
        <span class="c1">#gives a dictionary where the key is the end node and the value is the number of</span>
        <span class="c1"># edges on the shortest path</span>
        <span class="n">sp_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_shortest_path_length</span><span class="p">(</span><span class="n">ga</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="n">list_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sp_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="c1">#gets the end node that would make the longest shortest path </span>
        <span class="n">longest_path_node</span> <span class="o">=</span> <span class="n">list_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1">#get the number of edges for the path</span>
        <span class="n">longest_path_magnitude</span> <span class="o">=</span> <span class="n">sp_dict</span><span class="p">[</span><span class="n">longest_path_node</span><span class="p">]</span>


        <span class="c1">#add the ending node and the magnitude of it to lists</span>
        <span class="n">lp_end_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">longest_path_node</span><span class="p">)</span>
        <span class="n">lp_magnitude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">longest_path_magnitude</span><span class="p">)</span>

    <span class="n">lp_end_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lp_end_list</span><span class="p">)</span>
    <span class="c1">#construct skeleton from shortest path</span>
    <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lp_magnitude_list</span><span class="p">)</span>
    <span class="n">final_start</span> <span class="o">=</span> <span class="n">sampled_nodes</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>
    <span class="n">final_end</span> <span class="o">=</span> <span class="n">lp_end_list</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>

    <span class="n">node_list</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">ga</span><span class="p">,</span><span class="n">final_start</span><span class="p">,</span><span class="n">final_end</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;node_list len &lt; 2 so returning empty list&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="c1">#print(&quot;node_list = &quot; + str(node_list))</span>

    <span class="n">final_skeleton</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">node_list</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">node_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Final Time for surface skeleton with sample size = </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_surface_downsampling</span><span class="p">):</span>
        <span class="n">final_skeleton</span> <span class="o">=</span> <span class="n">downsample_skeleton</span><span class="p">(</span><span class="n">final_skeleton</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_skeleton</span></div>


<span class="c1">#from meshparty_skeletonize import *</span>
<div class="viewcode-block" id="setup_root"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.setup_root">[docs]</a><span class="k">def</span> <span class="nf">setup_root</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">is_soma_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">soma_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; function to find the root index to use for this mesh</span>
<span class="sd">    </span>
<span class="sd">    Purpose: The output will be used to find the path for a </span>
<span class="sd">    surface skeletonization (aka: longest shortest path)</span>
<span class="sd">    </span>
<span class="sd">    The output:</span>
<span class="sd">    1) root: One of the end points</span>
<span class="sd">    2) target: The other endpoint:</span>
<span class="sd">    3) root_ds: (N,) matrix of distances from root to all other vertices</span>
<span class="sd">    4) : predecessor matrix for root to shortest paths of all other vertices</span>
<span class="sd">    --&gt; used to find surface path</span>
<span class="sd">    5) valid: boolean mask (NOT USED)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_valid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">is_valid</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># soma mode</span>
    <span class="k">if</span> <span class="n">is_soma_pt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pick the first soma as root</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_d</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">is_soma_pt</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">is_valid_root</span> <span class="o">=</span> <span class="n">is_soma_pt</span> <span class="o">&amp;</span> <span class="n">valid</span>
        <span class="n">valid_root_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_valid_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_root_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_valid_root</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">soma_d</span><span class="p">[</span><span class="n">valid_root_inds</span><span class="p">])</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">valid_root_inds</span><span class="p">[</span><span class="n">min_valid_root</span><span class="p">]</span>
            <span class="n">root_ds</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">dijkstra</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">csgraph</span><span class="p">,</span>
                                                    <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">indices</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
                                                    <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">root_ds</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">find_far_points</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                                    <span class="n">start_ind</span><span class="o">=</span><span class="n">start_ind</span><span class="p">)</span>
        <span class="n">valid</span><span class="p">[</span><span class="n">is_soma_pt</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># there is no soma close, so use far point heuristic</span>
        <span class="n">start_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">root_ds</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">find_far_points</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span> <span class="n">start_ind</span><span class="o">=</span><span class="n">start_ind</span><span class="p">)</span>
    <span class="n">valid</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">root_ds</span><span class="p">[</span><span class="n">valid</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">root_ds</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">valid</span></div>

<div class="viewcode-block" id="surface_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.surface_skeleton">[docs]</a><span class="k">def</span> <span class="nf">surface_skeleton</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                     <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">return_sk</span> <span class="o">=</span> <span class="n">generate_surface_skeleton</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> 
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_sk</span><span class="p">,</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_sk</span></div>
<div class="viewcode-block" id="generate_surface_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.generate_surface_skeleton">[docs]</a><span class="k">def</span> <span class="nf">generate_surface_skeleton</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span>
                              <span class="n">faces</span><span class="p">,</span> 
                              <span class="n">surface_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                              <span class="n">n_surface_downsampling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate a surface skeleton</span>
<span class="sd">    </span>
<span class="sd">    Specifics: New implementation that uses meshparty </span>
<span class="sd">    method of finding root that optimally finds </span>
<span class="sd">    longest shortest path</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">meshparty_skeleton_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">branch_obj_tr_io</span>  <span class="o">=</span> <span class="n">meshparty</span><span class="o">.</span><span class="n">trimesh_io</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">,</span>
                                   <span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">)</span>
    
    <span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">root_ds</span><span class="p">,</span> <span class="n">root_pred</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">setup_root</span><span class="p">(</span><span class="n">branch_obj_tr_io</span><span class="p">)</span>

    <span class="n">current_path</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">root_pred</span><span class="p">)</span>

    <span class="n">surface_sk_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">current_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">current_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">meshparty_surface_skeleton</span> <span class="o">=</span> <span class="n">branch_obj_tr_io</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">surface_sk_edges</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for surface skeletonization = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">meshparty_skeleton_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_surface_downsampling</span><span class="p">):</span>
        <span class="n">meshparty_surface_skeleton</span> <span class="o">=</span> <span class="n">downsample_skeleton</span><span class="p">(</span><span class="n">meshparty_surface_skeleton</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">meshparty_surface_skeleton</span></div>


<div class="viewcode-block" id="downsample_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.downsample_skeleton">[docs]</a><span class="k">def</span> <span class="nf">downsample_skeleton</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">):</span>
    <span class="c1">#print(&quot;current_skeleton = &quot; + str(current_skeleton.shape))</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downsamples the skeleton by 50% number of edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extra_segment</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">current_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">extra_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">current_skeleton</span> <span class="o">=</span> <span class="n">current_skeleton</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#print(&quot;extra_segment = &quot; + str(extra_segment))</span>
        <span class="c1">#print(&quot;extra_segment.shape = &quot; + str(extra_segment.shape))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&quot;extra_segment = &quot; + str(extra_segment))</span>
        <span class="k">pass</span>

    <span class="n">even_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">current_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">odd_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">current_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">even_verts</span> <span class="o">=</span> <span class="n">current_skeleton</span><span class="p">[</span><span class="n">even_indices</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">odd_verts</span> <span class="o">=</span> <span class="n">current_skeleton</span><span class="p">[</span><span class="n">odd_indices</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span>

    <span class="n">downsampled_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">even_verts</span><span class="p">,</span><span class="n">odd_verts</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">even_verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1">#print(&quot;dowsampled_skeleton.shape = &quot; + str(downsampled_skeleton.shape))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(&quot;downsampled_skeleton = &quot; + str(downsampled_skeleton.shape))</span>
        <span class="n">final_downsampled_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">extra_segment</span><span class="p">,</span><span class="n">downsampled_skeleton</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_downsampled_skeleton</span> <span class="o">=</span> <span class="n">downsampled_skeleton</span>
    <span class="k">return</span> <span class="n">final_downsampled_skeleton</span></div>


<span class="c1"># ----- Stitching Algorithm ----- #</span>


<div class="viewcode-block" id="stitch_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.stitch_skeleton">[docs]</a><span class="k">def</span> <span class="nf">stitch_skeleton</span><span class="p">(</span>
                                          <span class="n">staring_edges</span><span class="p">,</span>
                                          <span class="n">max_stitch_distance</span><span class="o">=</span><span class="n">max_stitch_distance_default</span><span class="p">,</span>
                                          <span class="n">stitch_print</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                          <span class="n">main_mesh</span> <span class="o">=</span> <span class="p">[]</span>
                                        <span class="p">):</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_stitch_distance = </span><span class="si">{</span><span class="n">max_stitch_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitched_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">all_skeleton_vertices</span> <span class="o">=</span> <span class="n">staring_edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">unique_rows</span><span class="p">,</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_skeleton_vertices</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">edges_with_coefficients</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting the unique rows and indices= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#create the graph from the edges</span>
    <span class="c1">#B = nx.Graph() #old way</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span>
    <span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="n">x</span><span class="p">,{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)])</span>
    
    
    <span class="n">B</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges_with_coefficients</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Putting edges into networkx graph= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># find the shortest distance between the two different subgraphs:</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance_matrix</span>

    <span class="c1"># UG = B.to_undirected() #no longer need this</span>
    <span class="n">UG</span> <span class="o">=</span> <span class="n">B</span>
    
    <span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making undirected graph= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#get all of the coordinates</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len_subgraphs AT BEGINNING of the loop&quot;</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">n_components</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">UG</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#print(f&quot;At beginning n_components = {n_components}, unique labels = {np.unique(labels)}&quot;)</span>
    
    
    
    <span class="n">subgraph_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">outside_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_components</span><span class="p">)):</span>
        
        <span class="n">counter</span><span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting Loop </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1) Get the indexes of the subgraph</span>
<span class="sd">        2) Build a KDTree from those not in the subgraph (save the vertices of these)</span>
<span class="sd">        3) Query against the nodes in the subgraph  and get the smallest distance</span>
<span class="sd">        4) Create this new edge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stitch_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#1) Get the indexes of the subgraph</span>
        <span class="c1">#n_components, labels = scipy.sparse.csgraph.connected_components(csgraph=nx.adjacency_matrix(UG), directed=False, return_labels=True)</span>
        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding Number of Connected Components= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">subgraph_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Faces belonging to largest component= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#print(&quot;subgraph_components = &quot; + str(subgraph_components))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgraph_components</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">UG</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;all graph is one component!&quot;</span><span class="p">)</span>
            <span class="c1">#print(f&quot;unique labels = {np.unique(labels)}&quot;)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_components = </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">outside_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finding faces not in largest component= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#print(&quot;outside_components = &quot; + str(outside_components))</span>

        <span class="c1">#2) Build a KDTree from those not in the subgraph (save the vertices of these)</span>
        <span class="n">mesh_tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">[</span><span class="n">outside_components</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Building KDTree= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


        <span class="c1">#3) Query against the nodes in the subgraph  and get the smallest distance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conclusion:</span>
<span class="sd">        Distance is of the size of the parts that are in the KDTree</span>
<span class="sd">        The closest nodes represent those that were queryed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">mesh_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">[</span><span class="n">subgraph_components</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh Tree query= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        
        <span class="c1">#check if the distance is too far away </span>
        <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_stitch_distance</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;**** The distance exceeded max stitch distance of </span><span class="si">{</span><span class="n">max_stitch_distance</span><span class="si">}</span><span class="s2">&quot;</span>
                   <span class="sa">f</span><span class="s2">&quot; and still had </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2"> left</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;   Actual distance was </span><span class="si">{</span><span class="n">distances</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding closest distance= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


        <span class="n">closest_outside_node</span> <span class="o">=</span> <span class="n">outside_components</span><span class="p">[</span><span class="n">closest_node</span><span class="p">[</span><span class="n">min_index</span><span class="p">]]</span>
        <span class="n">closest_subgraph_node</span> <span class="o">=</span> <span class="n">subgraph_components</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting nodes to be paired up= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        
        
        <span class="c1">#get the edge distance of edge about to create:</span>

    <span class="c1">#         graph_coordinates=nx.get_node_attributes(UG,&#39;coordinates&#39;)</span>
    <span class="c1">#         prospective_edge_length = np.linalg.norm(np.array(graph_coordinates[closest_outside_node])-np.array(graph_coordinates[closest_subgraph_node]))</span>
    <span class="c1">#         print(f&quot;Edge distance going to create = {prospective_edge_length}&quot;)</span>

        <span class="c1">#4) Create this new edge</span>
        <span class="n">UG</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">closest_subgraph_node</span><span class="p">,</span><span class="n">closest_outside_node</span><span class="p">)</span>

        <span class="c1">#get the label of the closest outside node </span>
        <span class="n">closest_outside_label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">closest_outside_node</span><span class="p">]</span>

        <span class="c1">#get all of the nodes with that same label</span>
        <span class="n">new_subgraph_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">closest_outside_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#relabel the nodes so now apart of the largest component</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">new_subgraph_components</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#move the newly relabeled nodes out of the outside components into the subgraph components</span>
        <span class="c1">## --- SKIP THIS ADDITION FOR RIGHT NOW -- #</span>


        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding Edge = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">n_components</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Time for loop = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1"># get the largest subgraph!!! in case have missing pieces</span>

    <span class="c1">#add all the new edges to the </span>

<span class="c1">#     total_coord = nx.get_node_attributes(UG,&#39;coordinates&#39;)</span>
<span class="c1">#     current_coordinates = np.array(list(total_coord.values()))</span>

    <span class="n">current_coordinates</span> <span class="o">=</span> <span class="n">unique_rows</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#total_edges_stitched = current_coordinates[np.array(list(UG.edges())).reshape(-1,2)] #old way of edges</span>
        <span class="n">total_edges_stitched</span> <span class="o">=</span> <span class="n">current_coordinates</span><span class="p">[</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;getting the total edges stitched didn&#39;t work&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_coordinates = </span><span class="si">{</span><span class="n">current_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;UG.edges_ordered() = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">())</span><span class="si">}</span><span class="s2"> with type = </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.array(UG.edges_ordered()) = </span><span class="si">{</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.array(UG.edges_ordered()).reshape(-1,2) = </span><span class="si">{</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot; total_edges_stitched not calculated&quot;</span><span class="p">)</span>
        <span class="c1">#print(&quot;returning &quot;)</span>
        <span class="c1">#total_edges_stitched</span>
    

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for skeleton stitching = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">stitched_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">total_edges_stitched</span></div>


<div class="viewcode-block" id="stack_skeletons"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.stack_skeletons">[docs]</a><span class="k">def</span> <span class="nf">stack_skeletons</span><span class="p">(</span><span class="n">sk_list</span><span class="p">,</span><span class="n">graph_cleaning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">list_of_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_skeletons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No skeletons to stack so returning empty list&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_skeletons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#print(&quot;only one skeleton so no stacking needed&quot;)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_of_skeletons</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_sk</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">list_of_skeletons</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">graph_cleaning</span><span class="p">:</span>
            <span class="n">final_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">final_sk</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">final_sk</span></div>

<span class="c1">#------------ The actual skeletonization from mesh contraction----------- #</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">calcification_param_Module</span> <span class="kn">import</span> <span class="n">calcification_param</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
<div class="viewcode-block" id="calcification"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.calcification">[docs]</a><span class="k">def</span> <span class="nf">calcification</span><span class="p">(</span>
                    <span class="n">location_with_filename</span><span class="p">,</span>
                    <span class="n">max_triangle_angle</span> <span class="o">=</span><span class="mf">1.91986</span><span class="p">,</span>
                    <span class="n">quality_speed_tradeoff</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="c1">#0.1,</span>
                    <span class="n">medially_centered_speed_tradeoff</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="c1">#0.2,</span>
                    <span class="n">area_variation_factor</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span><span class="c1">#0.0001,</span>
                    <span class="n">max_iterations</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="c1">#500,</span>
                    <span class="n">is_medially_centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">min_edge_length</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                    <span class="n">edge_length_multiplier</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                    <span class="n">print_parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">):</span>

    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">location_with_filename</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
        <span class="n">location_with_filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">location_with_filename</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="n">location_with_filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
        <span class="n">location_with_filename</span> <span class="o">=</span> <span class="n">location_with_filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    
    <span class="c1">#print(f&quot;location_with_filename = {location_with_filename}&quot;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_edge_length = </span><span class="si">{</span><span class="n">min_edge_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="n">calcification_param</span><span class="p">(</span>
        <span class="n">location_with_filename</span><span class="p">,</span>
        <span class="n">max_triangle_angle</span><span class="p">,</span>
        <span class="n">quality_speed_tradeoff</span><span class="p">,</span>
        <span class="n">medially_centered_speed_tradeoff</span><span class="p">,</span>
        <span class="n">area_variation_factor</span><span class="p">,</span>
        <span class="n">max_iterations</span><span class="p">,</span>
        <span class="n">is_medially_centered</span><span class="p">,</span>
        <span class="n">min_edge_length</span><span class="p">,</span>
        <span class="n">edge_length_multiplier</span><span class="p">,</span>
        <span class="n">print_parameters</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">location_with_filename</span><span class="o">+</span><span class="s2">&quot;_skeleton.cgal&quot;</span></div>

<span class="n">cgal_skeletonization_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">max_triangle_angle</span> <span class="o">=</span><span class="mf">1.91986</span><span class="p">,</span>
    <span class="n">quality_speed_tradeoff</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">medially_centered_speed_tradeoff</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="c1">#0.2,</span>
    <span class="n">area_variation_factor</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span><span class="c1">#0.0001,</span>
    <span class="n">max_iterations</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="c1">#500,</span>
    <span class="n">is_medially_centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">min_edge_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">edge_length_multiplier</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
<span class="p">)</span>
<div class="viewcode-block" id="skeleton_cgal"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_cgal">[docs]</a><span class="k">def</span> <span class="nf">skeleton_cgal</span><span class="p">(</span>
    <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_to_write</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="s2">&quot;./temp.off&quot;</span><span class="p">,</span>
    <span class="n">remove_mesh_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">remove_skeleton_temp_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">manifold_fix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_skeleton_file_path_and_status</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">cgal_original_parameters</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Write the mesh to a file</span>
<span class="sd">    2) Pass the file to the calcification</span>
<span class="sd">    3) Delete the temporary file</span>
<span class="sd">    </span>
<span class="sd">    -- will now check and fix mesh manifoldness</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Polyhedron mesh;</span>
<span class="sd">    if (!input)</span>
<span class="sd">    {</span>
<span class="sd">        std::cerr &lt;&lt; &quot;Cannot open file &quot; &lt;&lt; std::endl;</span>
<span class="sd">        return 2;</span>
<span class="sd">    }</span>
<span class="sd">    std::vector&lt;K::Point_3&gt; points;</span>
<span class="sd">    std::vector&lt; std::vector&lt;std::size_t&gt; &gt; polygons;</span>
<span class="sd">    if (!CGAL::read_OFF(input, points, polygons))</span>
<span class="sd">    {</span>
<span class="sd">        std::cerr &lt;&lt; &quot;Error parsing the OFF file &quot; &lt;&lt; std::endl;</span>
<span class="sd">        return 3;</span>
<span class="sd">    }</span>
<span class="sd">    CGAL::Polygon_mesh_processing::orient_polygon_soup(points, polygons);</span>
<span class="sd">    CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(points, polygons, mesh);</span>
<span class="sd">    if(!CGAL::is_closed(mesh)){</span>
<span class="sd">        std::cerr &lt;&lt; &quot;Not closed mesh&quot;&lt;&lt;std::endl;</span>
<span class="sd">        return 4;</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#----------- 1/15 Addition: Will fix manifold issues</span>
    <span class="k">if</span> <span class="n">manifold_fix</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_manifold</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span> <span class="c1">#should only be one piece</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">poisson_surface_reconstruction</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                 <span class="n">return_largest_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">manifold_clean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Manifold status before skeletonization = </span><span class="si">{</span><span class="n">tu</span><span class="o">.</span><span class="n">is_manifold</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Watertight status before skeletonization = </span><span class="si">{</span><span class="n">tu</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="n">tu</span><span class="o">.</span><span class="n">write_neuron_off</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;mesh_watertight.off&quot;</span><span class="p">)</span>
    
    <span class="c1">#1) Write the mesh to a file</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">written_path</span> <span class="o">=</span> <span class="n">write_neuron_off</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">written_path</span> <span class="o">=</span> <span class="n">mesh_path</span>
    
    <span class="c1">#2) Pass the file to the calcification</span>
    <span class="n">sk_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cgal_original_parameters</span><span class="p">:</span>
        <span class="n">skeleton_results</span><span class="p">,</span><span class="n">sk_file</span> <span class="o">=</span> <span class="n">calcification</span><span class="p">(</span><span class="n">written_path</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton_results</span><span class="p">,</span><span class="n">sk_file</span> <span class="o">=</span> <span class="n">calcification</span><span class="p">(</span>
            <span class="n">written_path</span><span class="p">,</span>
            <span class="o">**</span><span class="n">cgal_skeletonization_parameters</span>
        <span class="p">)</span>
    
    
    <span class="c1">#3) Delete the temporary file</span>
    <span class="k">if</span> <span class="n">remove_mesh_temp_file</span><span class="p">:</span>
        <span class="n">Path</span><span class="p">(</span><span class="n">written_path</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
    

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for skeletonizing </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sk_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">significant_poisson_skeleton</span> <span class="o">=</span> <span class="n">read_skeleton_edges_coordinates</span><span class="p">([</span><span class="n">sk_file</span><span class="p">])</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">significant_poisson_skeleton</span><span class="p">,</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_skeleton_file_path_and_status</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_results</span><span class="p">,</span><span class="n">sk_file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">significant_poisson_skeleton</span> <span class="o">=</span> <span class="n">read_skeleton_edges_coordinates</span><span class="p">([</span><span class="n">sk_file</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning skeleton of size </span><span class="si">{</span><span class="n">significant_poisson_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">remove_skeleton_temp_file</span><span class="p">:</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">sk_file</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">significant_poisson_skeleton</span></div>
    
<div class="viewcode-block" id="skeleton_cgal_original_parameters"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_cgal_original_parameters">[docs]</a><span class="k">def</span> <span class="nf">skeleton_cgal_original_parameters</span><span class="p">(</span>
    <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cgal_original_parameters</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">curr_kwargs</span> <span class="o">=</span> <span class="n">cgal_skeletonization_parameters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">curr_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="n">return_sk</span> <span class="o">=</span> <span class="n">skeleton_cgal</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
        <span class="o">**</span><span class="n">curr_kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_sk</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_sk</span></div>
        
        




<div class="viewcode-block" id="example_cgal_skeletonization_original_params"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.example_cgal_skeletonization_original_params">[docs]</a><span class="k">def</span> <span class="nf">example_cgal_skeletonization_original_params</span><span class="p">(</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;./elephant.off&quot;</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">elephant_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_cgal_original_parameters</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">medially_centered_speed_tradeoff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="c1">#     max_triangle_angle =1.91986,</span>
        <span class="n">quality_speed_tradeoff</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="c1">#0.1,</span>
    <span class="c1">#     medially_centered_speed_tradeoff=0.5,</span>
    <span class="c1">#     area_variation_factor=0.0001,#0.0001,</span>
    <span class="c1">#     max_iterations=5000,#500,</span>
    <span class="c1">#     is_medially_centered=True,</span>
    <span class="c1">#     min_edge_length =  meshu.bounding_box_diagonal(mesh)*edge_length_multiplier,</span>
    <span class="c1">#     edge_length_multiplier = 0,#edge_length_multiplier,</span>
    <span class="c1">#     print_parameters = True,</span>
        <span class="n">remove_skeleton_temp_file</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span>

    
        
    <span class="k">return</span> <span class="n">elephant_sk</span></div>

<span class="c1"># ---------- Does the cleaning of the skeleton -------------- #</span>

<span class="c1">#old way that didnt account for the nodes that are close together</span>
<div class="viewcode-block" id="convert_skeleton_to_graph_old"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_skeleton_to_graph_old">[docs]</a><span class="k">def</span> <span class="nf">convert_skeleton_to_graph_old</span><span class="p">(</span><span class="n">staring_edges</span><span class="p">,</span>
                             <span class="n">stitch_print</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">all_skeleton_vertices</span> <span class="o">=</span> <span class="n">staring_edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">unique_rows</span><span class="p">,</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_skeleton_vertices</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#need to merge unique indices so if within a certain range of each other then merge them together</span>
    
    <span class="n">edges_with_coefficients</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting the unique rows and indices= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#create the graph from the edges</span>
    <span class="c1">#B = nx.Graph() #old way</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span>
    <span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)])</span>
    <span class="c1">#print(&quot;just added the nodes&quot;)</span>
    
    <span class="c1">#print(f&quot;xu.get_edge_attributes(B)= {xu.get_edge_attributes(B)}&quot;)</span>
    
    <span class="c1">#B.add_edges_from(edges_with_coefficients) #older weights without weights</span>
    <span class="c1">#adds weights for the edges</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">[</span><span class="n">edges_with_coefficients</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">unique_rows</span><span class="p">[</span><span class="n">edges_with_coefficients</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edges_with_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">edges_with_coefficients</span><span class="p">,</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">B</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">edges_with_weights</span><span class="p">)</span>
    <span class="c1">#print(&quot;right after add_weighted_edges_from&quot;)</span>
    <span class="c1">#print(f&quot;xu.get_edge_attributes(B)= {xu.get_edge_attributes(B)}&quot;)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(B.edges()) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Putting edges into networkx graph= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># find the shortest distance between the two different subgraphs:</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance_matrix</span>
    <span class="c1">#print(f&quot;B.__class__ = {B.__class__}&quot;)</span>
    <span class="c1">#print(f&quot;xu.get_edge_attributes(B)= {xu.get_edge_attributes(B)}&quot;)</span>
    <span class="n">UG</span> <span class="o">=</span> <span class="n">B</span>
    <span class="c1">#UG = B.to_undirected()</span>
    
    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making undirected graph= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1">#UG.remove_edges_from(nx.selfloop_edges(UG))</span>
    <span class="n">UG</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">UG</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(UG.edges()) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">UG</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#print(f&quot;UG.__class__ = {UG.__class__}&quot;)</span>
    <span class="c1">#make sure the edges are ordered </span>
    <span class="n">UG</span><span class="o">.</span><span class="n">reorder_edges</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(UG.edges()) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">UG</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#print(f&quot;UG.__class__ = {UG.__class__}&quot;)</span>
    <span class="k">return</span> <span class="n">UG</span></div>


<div class="viewcode-block" id="convert_skeleton_to_graph"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_skeleton_to_graph">[docs]</a><span class="k">def</span> <span class="nf">convert_skeleton_to_graph</span><span class="p">(</span>
    <span class="n">staring_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stitch_print</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">combine_node_dist</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
    <span class="n">node_matching_size_threshold</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To automatically convert a skeleton to a graph</span>
<span class="sd">    </span>
<span class="sd">    * 7/9 adjustments: make so slight differences in coordinates not affect the graph</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode for how you could apply the closeness to skeletons</span>
<span class="sd">    1) Get the unique rows</span>
<span class="sd">    2) See if there are any rows that are the same (that gives you what to change them to)</span>
<span class="sd">    3) put those into a graph and find the connected components</span>
<span class="sd">    4) Pick the first node in the component to be the dominant one</span>
<span class="sd">    a. for each non-dominant node, replace every occurance of the non-dominant one with the dominant one in indices</span>
<span class="sd">    - add the non-dominant ones to a list to delete </span>
<span class="sd">    </span>
<span class="sd">    ** this will result in an indices that doesn&#39;t have any of the repeat nodes, but the repeat nodes are still </span>
<span class="sd">    taking up the numbers that they were originally in order with ***</span>
<span class="sd">    </span>
<span class="sd">    np.delete(x,[1,3],axis=0)) # to delete the rows </span>
<span class="sd">    </span>
<span class="sd">    5) remap the indices and delete the unique rows that were not used</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    5) Do everything like normal</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_skeleton_vertices</span> <span class="o">=</span> <span class="n">staring_edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">unique_rows</span><span class="p">,</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_skeleton_vertices</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">#need to merge unique indices so if within a certain range of each other then merge them together</span>
        <span class="n">reshaped_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reshaped_indices</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="n">unique_rows</span> <span class="o">=</span> <span class="n">vertices</span>
    
    <span class="c1">#This is fine because know there might be but fix it later on! (in terms of concept graph)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reshaped_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">reshaped_indices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**** Warning: There were redundant edges in the skeleton*****&quot;</span><span class="p">)</span>
    
    <span class="c1">#part where will combine nodes that are very close</span>
    
    <span class="c1">#only do this if small enough, if too big then must skip (because will get memory error)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_matching_size_threshold</span><span class="p">:</span>
    
        <span class="n">matching_nodes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">get_matching_vertices</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">,</span><span class="n">equiv_distance</span><span class="o">=</span><span class="n">combine_node_dist</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Overall this loop will change the unique_rows and indices to account for nodes that should be merged</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Example graph for finding components</span>
            <span class="n">ex_edges</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ex_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">ex_edges</span><span class="p">)</span>


            <span class="c1">#get the connected components</span>
            <span class="n">all_conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">ex_graph</span><span class="p">))</span>

            <span class="n">to_delete_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c_comp</span> <span class="ow">in</span> <span class="n">all_conn_comp</span><span class="p">:</span>
                <span class="n">curr_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c_comp</span><span class="p">)</span>
                <span class="n">dom_node</span> <span class="o">=</span> <span class="n">curr_comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">non_dom_nodes</span> <span class="o">=</span> <span class="n">curr_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">for</span> <span class="n">n_dom</span> <span class="ow">in</span> <span class="n">non_dom_nodes</span><span class="p">:</span>
                    <span class="n">indices</span><span class="p">[</span><span class="n">indices</span><span class="o">==</span><span class="n">n_dom</span><span class="p">]</span> <span class="o">=</span> <span class="n">dom_node</span>
                    <span class="n">to_delete_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_dom</span><span class="p">)</span>

            <span class="n">unique_leftovers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="c1">#construct a dictionary for mapping</span>
            <span class="n">map_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_leftovers</span><span class="p">)])</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gettng rid of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">to_delete_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes INSIDE SKELETON TO GRAPH CONVERSION&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">vec_translate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>    
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">map_dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)(</span><span class="n">a</span><span class="p">)</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">vec_translate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1">#now delete the rows that were ignored</span>
            <span class="n">unique_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">,</span><span class="n">to_delete_nodes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1">#do a check to make sure everything is working</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The indices list does not match the size of the unique rows&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;np.unique(indices.ravel()) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="si">}</span><span class="s2">, len(unique_rows)= </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#resume regular conversion</span>
    <span class="n">edges_with_coefficients</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    
    

    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INSIDE CONVERT_SKELETON_TO_GRAPH Getting the unique rows and indices= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#create the graph from the edges</span>
    <span class="c1">#B = nx.Graph() #old way</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span>
    <span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">)])</span>
    <span class="c1">#print(&quot;just added the nodes&quot;)</span>
    <span class="c1">#print(f&quot;xu.get_edge_attributes(B)= {xu.get_edge_attributes(B)}&quot;)</span>
    
    <span class="c1">#B.add_edges_from(edges_with_coefficients) #older weights without weights</span>
    <span class="c1">#adds weights for the edges</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unique_rows</span><span class="p">[</span><span class="n">edges_with_coefficients</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">unique_rows</span><span class="p">[</span><span class="n">edges_with_coefficients</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edges_with_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">edges_with_coefficients</span><span class="p">,</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">B</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">edges_with_weights</span><span class="p">)</span>
    <span class="c1">#print(&quot;right after add_weighted_edges_from&quot;)</span>
    <span class="c1">#print(f&quot;xu.get_edge_attributes(B)= {xu.get_edge_attributes(B)}&quot;)</span>

    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Putting edges into networkx graph= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># find the shortest distance between the two different subgraphs:</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance_matrix</span>
    <span class="c1">#print(f&quot;B.__class__ = {B.__class__}&quot;)</span>
    <span class="c1">#print(f&quot;xu.get_edge_attributes(B)= {xu.get_edge_attributes(B)}&quot;)</span>
    <span class="n">UG</span> <span class="o">=</span> <span class="n">B</span>
    <span class="c1">#UG = B.to_undirected()</span>
    
    <span class="k">if</span> <span class="n">stitch_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making undirected graph= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">stitch_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stitch_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1">#UG.remove_edges_from(nx.selfloop_edges(UG))</span>
    <span class="n">UG</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">UG</span><span class="p">)</span>
    <span class="c1">#print(f&quot;UG.__class__ = {UG.__class__}&quot;)</span>
    <span class="c1">#make sure the edges are ordered </span>
    <span class="n">UG</span><span class="o">.</span><span class="n">reorder_edges</span><span class="p">()</span>
    <span class="c1">#print(f&quot;UG.__class__ = {UG.__class__}&quot;)</span>
    <span class="k">return</span> <span class="n">UG</span></div>


<div class="viewcode-block" id="convert_graph_to_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_graph_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">UG</span><span class="p">):</span>
    <span class="n">UG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">convert_node_labels_to_integers</span><span class="p">(</span><span class="n">UG</span><span class="p">)</span>
    <span class="n">total_coord</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">UG</span><span class="p">,</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
    <span class="n">current_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">total_coord</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#total_edges_stitched = current_coordinates[np.array(list(UG.edges())).reshape(-1,2)] # old way</span>
        <span class="n">total_edges_stitched</span> <span class="o">=</span> <span class="n">current_coordinates</span><span class="p">[</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;getting the total edges stitched didn&#39;t work&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_coordinates = </span><span class="si">{</span><span class="n">current_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;UG.edges() = </span><span class="si">{</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="si">}</span><span class="s2"> with type = </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.array(UG.edges()) = </span><span class="si">{</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.array(UG.edges()).reshape(-1,2) = </span><span class="si">{</span><span class="n">UG</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot; total_edges_stitched not calculated&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">total_edges_stitched</span></div>

<div class="viewcode-block" id="list_len_measure"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.list_len_measure">[docs]</a><span class="k">def</span> <span class="nf">list_len_measure</span><span class="p">(</span><span class="n">curr_list</span><span class="p">,</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_distance"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeletal_distance">[docs]</a><span class="k">def</span> <span class="nf">skeletal_distance</span><span class="p">(</span><span class="n">curr_list</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">coordinates_dict</span><span class="p">):</span>
    
    <span class="c1">#clean_time = time.time()</span>
    <span class="c1">#coordinates_dict = nx.get_node_attributes(G,&#39;coordinates&#39;)</span>
    <span class="c1">#print(f&quot;Extracting attributes = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#clean_time = time.time()</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinates_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_list</span><span class="p">]</span>
    <span class="c1">#print(f&quot;Reading dict = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#clean_time = time.time()</span>
    <span class="n">norm_values</span> <span class="o">=</span>  <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="p">))]</span>
    <span class="c1">#print(f&quot;Calculating norms = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#print(f&quot;norm_values = {norm_values}&quot;)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="clean_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.clean_skeleton">[docs]</a><span class="k">def</span> <span class="nf">clean_skeleton</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_distance_to_junction</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">return_skeleton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#must be the same size as soma_border_vertices</span>
    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_removed_skeletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">error_if_endpoints_must_keep_not_endnode</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example of how to use: </span>
<span class="sd">    </span>
<span class="sd">    Simple Example:  </span>
<span class="sd">    def distance_measure_func(path,G=None):</span>
<span class="sd">    #print(&quot;new thing&quot;)</span>
<span class="sd">    return len(path)</span>

<span class="sd">    new_G = clean_skeleton(G,distance_measure_func,return_skeleton=False)</span>
<span class="sd">    nx.draw(new_G,with_labels=True)</span>
<span class="sd">    </span>
<span class="sd">    More complicated example:</span>
<span class="sd">    </span>
<span class="sd">    from mesh_tools import skeleton_utils as sk</span>
<span class="sd">    from importlib import reload</span>
<span class="sd">    sk = reload(sk)</span>

<span class="sd">    from pathlib import Path</span>
<span class="sd">    test_skeleton = Path(&quot;./Dustin_vp6/Dustin_soma_0_branch_0_0_skeleton.cgal&quot;)</span>
<span class="sd">    if not test_skeleton.exists():</span>
<span class="sd">        print(str(test_skeleton)[:-14])</span>
<span class="sd">        file_of_skeleton = sk.calcification(str(test_skeleton.absolute())[:-14])</span>
<span class="sd">    else:</span>
<span class="sd">        file_of_skeleton = test_skeleton</span>

<span class="sd">    # import the skeleton</span>
<span class="sd">    test_sk = sk.read_skeleton_edges_coordinates(test_skeleton)</span>
<span class="sd">    import trimesh</span>
<span class="sd">    test_mesh = trimesh.load_mesh(str(str(test_skeleton.absolute())[:-14] + &quot;.off&quot;))</span>
<span class="sd">    sk.graph_skeleton_and_mesh(test_mesh.vertices,</span>
<span class="sd">                              test_mesh.faces,</span>
<span class="sd">                              edge_coordinates=test_sk)</span>

<span class="sd">    # clean the skeleton and then visualize</span>
<span class="sd">    import time</span>
<span class="sd">    clean_time = time.time()</span>
<span class="sd">    cleaned_skeleton = clean_skeleton(test_sk,</span>
<span class="sd">                        distance_func=skeletal_distance,</span>
<span class="sd">                  min_distance_to_junction=10000,</span>
<span class="sd">                  return_skeleton=True,</span>
<span class="sd">                  print_flag=True)</span>
<span class="sd">    print(f&quot;Total time for skeleton clean {time.time() - clean_time}&quot;)</span>

<span class="sd">    # see what skeleton looks like now</span>
<span class="sd">    test_mesh = trimesh.load_mesh(str(str(test_skeleton.absolute())[:-14] + &quot;.off&quot;))</span>
<span class="sd">    sk.graph_skeleton_and_mesh(test_mesh.vertices,</span>
<span class="sd">                              test_mesh.faces,</span>
<span class="sd">                              edge_coordinates=cleaned_skeleton)</span>
<span class="sd">                              </span>
<span class="sd">                              </span>
<span class="sd">    --------------- end of example -----------------</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; --- old way which had index error when completley straight line </span>
<span class="sd">    def end_node_path_to_junciton(curr_G,end_node):</span>
<span class="sd">        curr_node = end_node</span>
<span class="sd">        node_list = [curr_node]</span>
<span class="sd">        for i in range(len(curr_G)):</span>
<span class="sd">            neighbors = list(curr_G[curr_node])</span>
<span class="sd">            if len(neighbors) &lt;= 2:</span>
<span class="sd">                curr_node = [k for k in neighbors if k not in node_list][0]</span>
<span class="sd">                node_list.append(curr_node)</span>
<span class="sd">                #print(f&quot;node_list = {node_list}&quot;)</span>
<span class="sd">            else:</span>
<span class="sd">                break</span>
<span class="sd">        return node_list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">distance_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">distance_func</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletal_distance</span>
    
    <span class="k">def</span> <span class="nf">end_node_path_to_junciton</span><span class="p">(</span><span class="n">curr_G</span><span class="p">,</span><span class="n">end_node</span><span class="p">):</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">end_node</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_G</span><span class="p">)):</span>
            <span class="c1">#print(f&quot;\nloop #{i} with curr_node = {curr_node}&quot;)</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_G</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>
            <span class="c1">#print(f&quot;neighbors = {neighbors}&quot;)</span>
            <span class="c1">#print(f&quot;node_list = {node_list}&quot;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1">#print(f&quot;[k for k in neighbors if k not in node_list] = {[k for k in neighbors if k not in node_list]}&quot;)</span>
                <span class="n">possible_curr_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_curr_nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#this is when it is just one straight line</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_node</span> <span class="o">=</span> <span class="n">possible_curr_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
                    <span class="c1">#print(f&quot;node_list = {node_list}&quot;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">node_list</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using Distance measure </span><span class="si">{</span><span class="n">distance_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()),</span><span class="nb">type</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">())]:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;coordinates_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
    
    
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
    
    
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">endpoints_must_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_must_keep</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints_must_keep = </span><span class="si">{</span><span class="n">endpoints_must_keep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">all_single_nodes_to_eliminate</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoints_must_keep</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of end_nodes BEFORE filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">end_nodes_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">end_nodes</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">end_k</span> <span class="ow">in</span> <span class="n">endpoints_must_keep</span><span class="p">:</span>
            <span class="n">end_node_idx</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">end_k</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_node_idx</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">end_node_idx</span> <span class="o">=</span> <span class="n">end_node_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">end_node_must_keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">end_nodes</span><span class="o">==</span><span class="n">end_node_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">error_if_endpoints_must_keep_not_endnode</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end_nodes = </span><span class="si">{</span><span class="n">end_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end_node_idx = </span><span class="si">{</span><span class="n">end_node_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong when trying to find end nodes&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end_nodes = </span><span class="si">{</span><span class="n">end_nodes</span><span class="si">}</span><span class="s2"> wasn&#39;t endnode but continuing anyway&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="n">all_single_nodes_to_eliminate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_node_must_keep_idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Passed end node to keep that wasn&#39;t in the graph&quot;</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_single_nodes_to_eliminate = </span><span class="si">{</span><span class="n">all_single_nodes_to_eliminate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">new_end_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_single_nodes_to_eliminate</span><span class="p">])</span>

        <span class="c1">#doing the reassigning</span>
        <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">new_end_nodes</span>
        
            
    <span class="c1">#clean_time = time.time()</span>
    <span class="n">paths_to_j</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_node_path_to_junciton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">]</span>
    <span class="c1">#print(f&quot;Total time for node path to junction = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#clean_time = time.time()</span>
    <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_func</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">paths_to_j</span><span class="p">])</span>
    <span class="c1">#print(f&quot;Calculating distances = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#clean_time = time.time()</span>
    
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>
    <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">end_nodes_dist_to_j</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>
    
    <span class="n">skeletons_removed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#no end nodes so need to return </span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no small end nodes to get rid of so returning whole skeleton&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        
        
        
        
        <span class="n">current_end_node</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)]</span>
        <span class="c1">#print(f&quot;Ordering the nodes = {time.time() - clean_time}&quot;)</span>
        <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total end_nodes = </span><span class="si">{</span><span class="n">end_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#current_end_node = ordered_end_nodes[0]</span>
        <span class="n">paths_removed</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">))):</span>
            <span class="n">current_path_to_junction</span> <span class="o">=</span> <span class="n">end_node_path_to_junciton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current_end_node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="c1">#print(f&quot;ordered_end_nodes = {ordered_end_nodes}&quot;)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">current_end_node = </span><span class="si">{</span><span class="n">current_end_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_path_to_junction = </span><span class="si">{</span><span class="n">current_path_to_junction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance_func</span><span class="p">(</span><span class="n">current_path_to_junction</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the current distance that was below was </span><span class="si">{</span><span class="n">distance_func</span><span class="p">(</span><span class="n">current_path_to_junction</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1">#remove the nodes</span>
                
                <span class="n">path_to_rem</span> <span class="o">=</span> <span class="n">current_path_to_junction</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">skeletons_removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">path_to_rem</span><span class="p">)))</span>
                
                <span class="n">paths_removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">current_path_to_junction</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">end_nodes</span> <span class="o">!=</span> <span class="n">current_end_node</span><span class="p">]</span>
                <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_func</span><span class="p">(</span><span class="n">end_node_path_to_junciton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">])</span>

                <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>
                <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">end_nodes_dist_to_j</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)</span><span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">current_end_node</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)]</span>
    <span class="c1">#             if print_flag:</span>
    <span class="c1">#                 print(f&quot;   insdie if statement ordered_end_nodes = {ordered_end_nodes}&quot;)</span>

                <span class="c1">#current_end_node = ordered_end_nodes[0]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            
    <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done cleaning networkx graph with </span><span class="si">{</span><span class="n">paths_removed</span><span class="si">}</span><span class="s2"> paths removed&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_skeleton</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_removed_skeletons</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">),</span><span class="n">skeletons_removed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_removed_skeletons</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">G</span><span class="p">,</span><span class="n">skeletons_removed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">G</span></div>
    

<span class="n">min_distance_to_junction_default</span> <span class="o">=</span> <span class="mi">4001</span>
<div class="viewcode-block" id="filter_away_small_skeleton_offshoots"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.filter_away_small_skeleton_offshoots">[docs]</a><span class="k">def</span> <span class="nf">filter_away_small_skeleton_offshoots</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">min_distance_to_junction</span> <span class="o">=</span> <span class="n">min_distance_to_junction_default</span><span class="p">,</span>
    <span class="n">endpoints_must_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_removed_skeletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="n">return_sk</span> <span class="o">=</span> <span class="n">clean_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">min_distance_to_junction</span> <span class="o">=</span> <span class="n">min_distance_to_junction</span><span class="p">,</span>
        <span class="n">endpoints_must_keep</span><span class="o">=</span><span class="n">endpoints_must_keep</span><span class="p">,</span>
        <span class="n">print_flag</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_removed_skeletons</span><span class="o">=</span><span class="n">return_removed_skeletons</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span>
                <span class="n">skeleton</span>
            <span class="p">],</span>
            <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">],</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">return_sk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_sk</span></div>

<span class="n">filter_away_leaf_skeletons</span> <span class="o">=</span> <span class="n">filter_away_small_skeleton_offshoots</span>




<div class="viewcode-block" id="clean_skeleton_with_soma_verts"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.clean_skeleton_with_soma_verts">[docs]</a><span class="k">def</span> <span class="nf">clean_skeleton_with_soma_verts</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                   <span class="n">distance_func</span><span class="p">,</span>
                  <span class="n">min_distance_to_junction</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                  <span class="n">return_skeleton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">soma_border_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#should be list of soma vertices</span>
                   <span class="n">distance_to_ignore_end_nodes_close_to_soma_border</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                   <span class="n">skeleton_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#must be the same size as soma_border_vertices</span>
                  <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example of how to use: </span>
<span class="sd">    </span>
<span class="sd">    Simple Example:  </span>
<span class="sd">    def distance_measure_func(path,G=None):</span>
<span class="sd">    #print(&quot;new thing&quot;)</span>
<span class="sd">    return len(path)</span>

<span class="sd">    new_G = clean_skeleton(G,distance_measure_func,return_skeleton=False)</span>
<span class="sd">    nx.draw(new_G,with_labels=True)</span>
<span class="sd">    </span>
<span class="sd">    More complicated example:</span>
<span class="sd">    </span>
<span class="sd">    from mesh_tools import skeleton_utils as sk</span>
<span class="sd">    from importlib import reload</span>
<span class="sd">    sk = reload(sk)</span>

<span class="sd">    from pathlib import Path</span>
<span class="sd">    test_skeleton = Path(&quot;./Dustin_vp6/Dustin_soma_0_branch_0_0_skeleton.cgal&quot;)</span>
<span class="sd">    if not test_skeleton.exists():</span>
<span class="sd">        print(str(test_skeleton)[:-14])</span>
<span class="sd">        file_of_skeleton = sk.calcification(str(test_skeleton.absolute())[:-14])</span>
<span class="sd">    else:</span>
<span class="sd">        file_of_skeleton = test_skeleton</span>

<span class="sd">    # import the skeleton</span>
<span class="sd">    test_sk = sk.read_skeleton_edges_coordinates(test_skeleton)</span>
<span class="sd">    import trimesh</span>
<span class="sd">    test_mesh = trimesh.load_mesh(str(str(test_skeleton.absolute())[:-14] + &quot;.off&quot;))</span>
<span class="sd">    sk.graph_skeleton_and_mesh(test_mesh.vertices,</span>
<span class="sd">                              test_mesh.faces,</span>
<span class="sd">                              edge_coordinates=test_sk)</span>

<span class="sd">    # clean the skeleton and then visualize</span>
<span class="sd">    import time</span>
<span class="sd">    clean_time = time.time()</span>
<span class="sd">    cleaned_skeleton = clean_skeleton(test_sk,</span>
<span class="sd">                        distance_func=skeletal_distance,</span>
<span class="sd">                  min_distance_to_junction=10000,</span>
<span class="sd">                  return_skeleton=True,</span>
<span class="sd">                  print_flag=True)</span>
<span class="sd">    print(f&quot;Total time for skeleton clean {time.time() - clean_time}&quot;)</span>

<span class="sd">    # see what skeleton looks like now</span>
<span class="sd">    test_mesh = trimesh.load_mesh(str(str(test_skeleton.absolute())[:-14] + &quot;.off&quot;))</span>
<span class="sd">    sk.graph_skeleton_and_mesh(test_mesh.vertices,</span>
<span class="sd">                              test_mesh.faces,</span>
<span class="sd">                              edge_coordinates=cleaned_skeleton)</span>
<span class="sd">                              </span>
<span class="sd">                              </span>
<span class="sd">    --------------- end of example -----------------</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; --- old way which had index error when completley straight line </span>
<span class="sd">    def end_node_path_to_junciton(curr_G,end_node):</span>
<span class="sd">        curr_node = end_node</span>
<span class="sd">        node_list = [curr_node]</span>
<span class="sd">        for i in range(len(curr_G)):</span>
<span class="sd">            neighbors = list(curr_G[curr_node])</span>
<span class="sd">            if len(neighbors) &lt;= 2:</span>
<span class="sd">                curr_node = [k for k in neighbors if k not in node_list][0]</span>
<span class="sd">                node_list.append(curr_node)</span>
<span class="sd">                #print(f&quot;node_list = {node_list}&quot;)</span>
<span class="sd">            else:</span>
<span class="sd">                break</span>
<span class="sd">        return node_list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">end_node_path_to_junciton</span><span class="p">(</span><span class="n">curr_G</span><span class="p">,</span><span class="n">end_node</span><span class="p">):</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">end_node</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_G</span><span class="p">)):</span>
            <span class="c1">#print(f&quot;\nloop #{i} with curr_node = {curr_node}&quot;)</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_G</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>
            <span class="c1">#print(f&quot;neighbors = {neighbors}&quot;)</span>
            <span class="c1">#print(f&quot;node_list = {node_list}&quot;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1">#print(f&quot;[k for k in neighbors if k not in node_list] = {[k for k in neighbors if k not in node_list]}&quot;)</span>
                <span class="n">possible_curr_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_curr_nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#this is when it is just one straight line</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_node</span> <span class="o">=</span> <span class="n">possible_curr_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
                    <span class="c1">#print(f&quot;node_list = {node_list}&quot;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">node_list</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using Distance measure </span><span class="si">{</span><span class="n">distance_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()),</span><span class="nb">type</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">())]:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;coordinates_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
    
    
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; 9/16 Addition: Will ignore certain end nodes whose distance is too close to soma border&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">soma_border_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#assuming that has the correct length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>


<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            OLD METHOD THAT DID NOT TRAVERSE ACROSS MESH GRAPH </span>
<span class="sd">            </span>
<span class="sd">            Pseducode:</span>
<span class="sd">            1) Get the coordinates for all of the end nodes</span>
<span class="sd">            2) Put the soma border vertices in a KDTree</span>
<span class="sd">            3) Query the KDTree with the node endpoints coordinates</span>
<span class="sd">            4) Filter endpoints for only those farther than distance_to_ignore_end_nodes_close_to_soma_border</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            print(f&quot;Number of end_nodes BEFORE filtering = {len(end_nodes)}&quot;)</span>
<span class="sd">            end_nodes_coordinates = xu.get_node_attributes(G,node_list=end_nodes)</span>
<span class="sd">            soma_KD = KDTree(soma_border_vertices)</span>
<span class="sd">            distances,closest_nodes = soma_KD.query(end_nodes_coordinates)</span>
<span class="sd">            end_nodes = end_nodes[distances&gt;distance_to_ignore_end_nodes_close_to_soma_border]</span>
<span class="sd">            print(f&quot;Number of end_nodes AFTER filtering = {len(end_nodes)}&quot;)</span>
<span class="sd">        </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Going to ignore certain endnodes that are </span><span class="si">{</span><span class="n">distance_to_ignore_end_nodes_close_to_soma_border</span><span class="si">}</span><span class="s2"> nm close to soma border vertices&quot;</span><span class="p">)</span>
            <span class="c1">#New method that traverses across mesh graph</span>
            <span class="k">if</span> <span class="n">skeleton_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Skeleton_mesh is None when trying to account for soma_border_vertices in cleaning&quot;</span><span class="p">)</span>
                
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of end_nodes BEFORE filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">end_nodes_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">end_nodes</span><span class="p">)</span>
            
            <span class="c1">#0) Get the mesh vertices and create a KDTree from them</span>
            <span class="n">mesh_KD</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">skeleton_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            
            <span class="c1">#3) Create Weighted Graph from vertex edges</span>
            <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_vertex_graph</span><span class="p">(</span><span class="n">skeleton_mesh</span><span class="p">)</span>
            
            <span class="n">all_single_nodes_to_eliminate</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">if</span> <span class="n">endpoints_must_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="p">[[]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_border_vertices</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sm_idx</span><span class="p">,</span> <span class="n">sbv</span> <span class="ow">in</span> <span class="n">soma_border_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># See if there is a node for use to keep</span>
<span class="w">                </span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot; OLD WAY BEFORE MAKING MULTIPLE POSSIBLE SOMA TOUCHES</span>
<span class="sd">                end_k = endpoints_must_keep[sm_idx]</span>
<span class="sd">                &quot;&quot;&quot;</span>
                
                <span class="n">end_k_list</span> <span class="o">=</span> <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">end_k</span> <span class="ow">in</span> <span class="n">end_k_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">end_k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">end_node_must_keep</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">end_k</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">end_node_must_keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">end_nodes</span><span class="o">==</span><span class="n">end_node_must_keep</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">all_single_nodes_to_eliminate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_node_must_keep_idx</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using an already specified end node: </span><span class="si">{</span><span class="n">end_node_must_keep</span><span class="si">}</span><span class="s2"> with index </span><span class="si">{</span><span class="n">end_node_must_keep_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;checking was correct node end_nodes[index] = </span><span class="si">{</span><span class="n">end_nodes</span><span class="p">[</span><span class="n">end_node_must_keep_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
            
                <span class="c1">#1) Map the soma border vertices to the mesh vertices</span>
                <span class="n">soma_border_distances</span><span class="p">,</span><span class="n">soma_border_closest_nodes</span> <span class="o">=</span> <span class="n">mesh_KD</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sbv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

                <span class="c1">#2) Map the endpoints to closest mesh vertices</span>
                <span class="n">end_nodes_distances</span><span class="p">,</span><span class="n">end_nodes_closest_nodes</span> <span class="o">=</span> <span class="n">mesh_KD</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">end_nodes_coordinates</span><span class="p">)</span>



                <span class="c1">#4) For each endpoint, find shortest distance from endpoint to a soma border along graph</span>
                <span class="c1"># for en,en_mesh_vertex in zip(end_nodes,end_nodes_closest_nodes):</span>
                <span class="c1">#     #find the shortest path to a soma border vertex</span>
                <span class="n">node_idx_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">node_idx_to_eliminate</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">node_idx_to_eliminate_len</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">en_idx</span><span class="p">,</span><span class="n">en</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">end_nodes_closest_nodes</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">path_len</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra</span><span class="p">(</span><span class="n">vertex_graph</span><span class="p">,</span>
                                                                   <span class="n">source</span> <span class="o">=</span> <span class="n">en</span><span class="p">,</span>
                                                                   <span class="n">target</span><span class="o">=</span><span class="n">soma_border_closest_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                   <span class="n">cutoff</span><span class="o">=</span><span class="n">distance_to_ignore_end_nodes_close_to_soma_border</span>
                                                                  <span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">node_idx_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">en_idx</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#a valid path was found</span>
                        <span class="n">node_idx_to_eliminate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">en_idx</span><span class="p">)</span>
                        <span class="n">node_idx_to_eliminate_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_len</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;May Eliminate end_node </span><span class="si">{</span><span class="n">en_idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">end_nodes</span><span class="p">[</span><span class="n">en_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> because path_len to soma border was </span><span class="si">{</span><span class="n">path_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_idx_to_eliminate_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#see if there matches a node that we must keep</span>
                    
                    
                    <span class="n">single_node_idx_to_eliminate</span> <span class="o">=</span> <span class="n">node_idx_to_eliminate</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">node_idx_to_eliminate_len</span><span class="p">)]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;single_node_to_eliminate = </span><span class="si">{</span><span class="n">single_node_idx_to_eliminate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">all_single_nodes_to_eliminate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">single_node_idx_to_eliminate</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No close endpoints to choose from for elimination&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_single_nodes_to_eliminate = </span><span class="si">{</span><span class="n">all_single_nodes_to_eliminate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">new_end_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_single_nodes_to_eliminate</span><span class="p">])</span>

            <span class="c1">#doing the reassigning</span>
            <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">new_end_nodes</span>
            
    <span class="c1">#clean_time = time.time()</span>
    <span class="n">paths_to_j</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_node_path_to_junciton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">]</span>
    <span class="c1">#print(f&quot;Total time for node path to junction = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#clean_time = time.time()</span>
    <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_func</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">paths_to_j</span><span class="p">])</span>
    <span class="c1">#print(f&quot;Calculating distances = {time.time() - clean_time}&quot;)</span>
    <span class="c1">#clean_time = time.time()</span>
    
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>
    <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">end_nodes_dist_to_j</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#no end nodes so need to return </span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no small end nodes to get rid of so returning whole skeleton&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        
        
        
        
        <span class="n">current_end_node</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)]</span>
        <span class="c1">#print(f&quot;Ordering the nodes = {time.time() - clean_time}&quot;)</span>
        <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total end_nodes = </span><span class="si">{</span><span class="n">end_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#current_end_node = ordered_end_nodes[0]</span>
        <span class="n">paths_removed</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">))):</span>
            <span class="n">current_path_to_junction</span> <span class="o">=</span> <span class="n">end_node_path_to_junciton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current_end_node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="c1">#print(f&quot;ordered_end_nodes = {ordered_end_nodes}&quot;)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">current_end_node = </span><span class="si">{</span><span class="n">current_end_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_path_to_junction = </span><span class="si">{</span><span class="n">current_path_to_junction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance_func</span><span class="p">(</span><span class="n">current_path_to_junction</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the current distance that was below was </span><span class="si">{</span><span class="n">distance_func</span><span class="p">(</span><span class="n">current_path_to_junction</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1">#remove the nodes</span>
                <span class="n">paths_removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">current_path_to_junction</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">end_nodes</span> <span class="o">!=</span> <span class="n">current_end_node</span><span class="p">]</span>
                <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_func</span><span class="p">(</span><span class="n">end_node_path_to_junciton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">])</span>

                <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>
                <span class="n">end_nodes_dist_to_j</span> <span class="o">=</span> <span class="n">end_nodes_dist_to_j</span><span class="p">[</span><span class="n">end_nodes_dist_to_j</span><span class="o">&lt;</span><span class="n">min_distance_to_junction</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)</span><span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">current_end_node</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">end_nodes_dist_to_j</span><span class="p">)]</span>
    <span class="c1">#             if print_flag:</span>
    <span class="c1">#                 print(f&quot;   insdie if statement ordered_end_nodes = {ordered_end_nodes}&quot;)</span>

                <span class="c1">#current_end_node = ordered_end_nodes[0]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            
    <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done cleaning networkx graph with </span><span class="si">{</span><span class="n">paths_removed</span><span class="si">}</span><span class="s2"> paths removed&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_skeleton</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span></div>
    
<div class="viewcode-block" id="combine_close_branch_points"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.combine_close_branch_points">[docs]</a><span class="k">def</span> <span class="nf">combine_close_branch_points</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">combine_threshold</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span>
                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">skeleton_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a skeleton or graph and return a skelton/graph </span>
<span class="sd">    where close branch points are combined</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example Code of how could get the orders: </span>
<span class="sd">    # How could potentially get the edge order we wanted</span>
<span class="sd">    endpoint_neighbors_to_order_map = dict()</span>
<span class="sd">    for k in endpoint_neighbors:</span>
<span class="sd">        total_orders = []</span>
<span class="sd">        total_orders_neighbors = []</span>
<span class="sd">        for j in p:</span>
<span class="sd">            try:</span>
<span class="sd">                total_orders.append(curr_sk_graph[j][k][&quot;order&quot;])</span>
<span class="sd">                total_orders_neighbors.append(j)</span>
<span class="sd">            except:</span>
<span class="sd">                pass</span>
<span class="sd">        order_index = np.argmin(total_orders)</span>
<span class="sd">        endpoint_neighbors_to_order_map[(k,total_orders_neighbors[order_index])] = total_orders[order_index]</span>
<span class="sd">    endpoint_neighbors_to_order_map</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk = reload(sk)</span>
<span class="sd">    from python_tools import numpy_utils as nu</span>
<span class="sd">    nu = reload(nu)</span>
<span class="sd">    branch_skeleton_data_cleaned = []</span>
<span class="sd">    for i,curr_sk in enumerate(branch_skeleton_data):</span>
<span class="sd">        print(f&quot;\n----- Working on skeleton {i} ---------&quot;)</span>
<span class="sd">        new_sk = sk.combine_close_branch_points(curr_sk,print_flag=True)</span>
<span class="sd">        print(f&quot;Original Sk = {curr_sk.shape}, Cleaned Sk = {new_sk.shape}&quot;)</span>
<span class="sd">        branch_skeleton_data_cleaned.append(new_sk)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;combine_threshold = </span><span class="si">{</span><span class="n">combine_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">branches_flag</span> <span class="o">=</span> <span class="kc">False</span>    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skeleton_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#Create an array that maps the branch idx to the endpoints and make a copy</span>
        <span class="n">branch_idx_to_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skeleton_branches</span><span class="p">])</span>
        <span class="n">branch_idx_to_endpoints_original</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">branch_idx_to_endpoints</span><span class="p">)</span>
        <span class="n">branch_keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_branches</span><span class="p">))</span>
        
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">skeleton_branches</span><span class="p">)</span>
        <span class="n">branches_flag</span> <span class="o">=</span> <span class="kc">True</span>
    
    
    <span class="n">convert_back_to_skeleton</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#1) convert the skeleton to a graph</span>
    
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
        <span class="n">curr_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">convert_back_to_skeleton</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_sk_graph</span> <span class="o">=</span> <span class="n">skeleton</span>

    <span class="c1">#2) Get all of the high degree nodes</span>
    <span class="n">high_degree_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_greater_or_equal_degree_k</span><span class="p">(</span><span class="n">curr_sk_graph</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checked that thes high degree nodes were correctly retrieved</span>
<span class="sd">    high_degree_coordinates = xu.get_node_attributes(curr_sk_graph,node_list = high_degree_nodes)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_skeletons=[curr_sk],</span>
<span class="sd">                              other_scatter=[high_degree_coordinates])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#3) Get paths between all of them high degree nodes</span>
    <span class="n">valid_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_path_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">high_degree_nodes</span><span class="p">:</span>
        <span class="n">degree_copy</span> <span class="o">=</span> <span class="n">high_degree_nodes</span><span class="p">[</span><span class="n">high_degree_nodes</span> <span class="o">!=</span> <span class="n">s</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">degree_copy</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">path_len</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra</span><span class="p">(</span><span class="n">curr_sk_graph</span><span class="p">,</span><span class="n">source</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">combine_threshold</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#a valid path was found</span>
                <span class="n">degree_no_endpoints</span> <span class="o">=</span> <span class="n">degree_copy</span><span class="p">[</span><span class="n">degree_copy</span> <span class="o">!=</span> <span class="n">t</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">degree_no_endpoints</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">match_path</span><span class="o">=</span><span class="kc">False</span>
                    <span class="k">for</span> <span class="n">v_p</span> <span class="ow">in</span> <span class="n">valid_paths</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v_p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                            <span class="n">match_path</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">match_path</span><span class="p">:</span>
                        <span class="n">valid_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
                        <span class="n">valid_path_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_len</span><span class="p">)</span>
                        
                    
                    
<span class="c1">#                     sorted_path = np.sort(path)</span>
<span class="c1">#                     try:</span>
                        
                        
<span class="c1">#                         if len(nu.matching_rows(valid_paths,sorted_path)) &gt; 0:</span>
<span class="c1">#                             continue</span>
<span class="c1">#                         else:</span>
<span class="c1">#                             valid_paths.append(sorted_path)</span>
<span class="c1">#                     except:</span>
<span class="c1">#                         print(f&quot;valid_paths = {valid_paths}&quot;)</span>
<span class="c1">#                         print(f&quot;sorted_path = {sorted_path}&quot;)</span>
<span class="c1">#                         print(f&quot;nu.matching_rows(valid_paths,sorted_path) = {nu.matching_rows(valid_paths,sorted_path)}&quot;)</span>
<span class="c1">#                         raise Exception()</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid paths to replace&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_paths = </span><span class="si">{</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_path_lengths = </span><span class="si">{</span><span class="n">valid_path_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                     
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding all paths = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid paths found so just returning the original&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">branches_flag</span><span class="p">:</span>
            <span class="n">skeleton_branches</span><span class="p">,</span><span class="n">branch_keep_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">skeleton</span>
    
    <span class="c1"># Need to combine paths if there is any overlapping:</span>
    <span class="n">valid_paths</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # --------------If there were valid paths found -------------</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_sk_graph_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_sk_graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Copying graph= </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;length of Graph = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p_idx</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">):</span>
        
        
        <span class="n">path_degrees</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_degree</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on path </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_degrees = </span><span class="si">{</span><span class="n">path_degrees</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">p_end_nodes</span> <span class="o">=</span> <span class="n">p</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1">#get endpoint coordinates</span>
        <span class="n">path_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="n">end_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">path_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting coordinates = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
<span class="c1">#         print(f&quot;end_coordinates = {end_coordinates}&quot;)</span>
<span class="c1">#         print(f&quot;branch_idx_to_endpoints = {branch_idx_to_endpoints}&quot;)</span>
<span class="c1">#         print(f&quot;branch_idx_to_endpoints.shape = {branch_idx_to_endpoints.shape}&quot;)</span>


        <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">end_coordinates_try_2</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">p_end_nodes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end_coordinates = </span><span class="si">{</span><span class="n">end_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end_coordinates_try_2 = </span><span class="si">{</span><span class="n">end_coordinates_try_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_idx_to_endpoints = </span><span class="si">{</span><span class="n">branch_idx_to_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">branches_flag</span><span class="p">:</span>
            <span class="c1">#find the branch_idx with the found endpoints (if multiple then continue)</span>
            <span class="n">branch_idxs</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">find_matching_endpoints_row</span><span class="p">(</span><span class="n">branch_idx_to_endpoints</span><span class="p">,</span><span class="n">end_coordinates</span><span class="p">)</span>
        
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_idxs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_idxs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching endpoints for branch&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">branch_position_to_delete</span> <span class="o">=</span> <span class="n">branch_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding matching endpoints = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
        <span class="c1">#get the coordinates of the path and average them for new node</span>
        <span class="n">average_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">path_coordinates</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1">#replace the old end nodes with the new one</span>
        <span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">new_node_id</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">add_new_coordinate_node</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">node_coordinate</span><span class="o">=</span><span class="n">average_endpoints</span><span class="p">,</span><span class="n">replace_nodes</span><span class="o">=</span><span class="n">p_end_nodes</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding new coordinate node = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="c1">#go through and change all remaining paths to now include the new combined node id</span>
        <span class="k">for</span> <span class="n">p_idx_curr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_paths[p_idx_curr] = </span><span class="si">{</span><span class="n">valid_paths</span><span class="p">[</span><span class="n">p_idx_curr</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;p_end_nodes = </span><span class="si">{</span><span class="n">p_end_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_node_id = </span><span class="si">{</span><span class="n">new_node_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(valid_paths[p_idx_curr]==p_end_nodes[0]) | (valid_paths[p_idx_curr]==p_end_nodes[1]) = </span><span class="si">{</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">[</span><span class="n">p_idx_curr</span><span class="p">]</span><span class="o">==</span><span class="n">p_end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">valid_paths</span><span class="p">[</span><span class="n">p_idx_curr</span><span class="p">]</span><span class="o">==</span><span class="n">p_end_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
            <span class="n">valid_paths</span><span class="p">[</span><span class="n">p_idx_curr</span><span class="p">][(</span><span class="n">valid_paths</span><span class="p">[</span><span class="n">p_idx_curr</span><span class="p">]</span><span class="o">==</span><span class="n">p_end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">valid_paths</span><span class="p">[</span><span class="n">p_idx_curr</span><span class="p">]</span><span class="o">==</span><span class="n">p_end_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">new_node_id</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Changing all remaining paths = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">branches_flag</span><span class="p">:</span>
            <span class="c1">#delete the branch id from the index</span>
            <span class="n">branch_idx_to_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">branch_idx_to_endpoints</span><span class="p">,</span> <span class="n">branch_position_to_delete</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">branch_keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">branch_keep_idx</span><span class="p">,</span><span class="n">branch_position_to_delete</span><span class="p">)</span>



            <span class="c1">#go through and replace and of the endpoints list that were the old endpoints now with the new one</span>
            <span class="n">match_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">branch_idx_to_endpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">end_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">match_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">branch_idx_to_endpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">end_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">replace_mask</span> <span class="o">=</span> <span class="n">match_1</span> <span class="o">|</span> <span class="n">match_2</span>
            <span class="n">branch_idx_to_endpoints</span><span class="p">[</span><span class="n">replace_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">average_endpoints</span>
            
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Replacing branch index = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="c1">#delete the nodes that were on the path</span>
        <span class="n">curr_sk_graph_cp</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing nodes = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    
    
    <span class="k">if</span> <span class="n">branches_flag</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1) Find the branches that were not filtered away</span>
<span class="sd">        2) Get the new and original endpoints of the filtered branches</span>
<span class="sd">        3) For all filtered branches:</span>
<span class="sd">           i) convert skeleton into a graph</span>
<span class="sd">           For each endpoint</span>
<span class="sd">               ii) send the original endpoint to get replaced by new one</span>
<span class="sd">           iii) convert back into skeleton and save</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#1) Find the branches that were not filtered away</span>
        <span class="n">skeleton_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">skeleton_branches</span><span class="p">)</span>
        <span class="n">filtered_skeleton_branches</span> <span class="o">=</span> <span class="n">skeleton_branches</span><span class="p">[</span><span class="n">branch_keep_idx</span><span class="p">]</span>
        
        <span class="c1">#2) Get the new and original endpoints of the filtered branches</span>
        <span class="n">original_endpoints</span> <span class="o">=</span> <span class="n">branch_idx_to_endpoints_original</span><span class="p">[</span><span class="n">branch_keep_idx</span><span class="p">]</span>
        <span class="n">new_endpoints</span> <span class="o">=</span> <span class="n">branch_idx_to_endpoints</span>
        
        <span class="c1">#3) For all filtered branches:</span>
        <span class="n">edited_skeleton_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f_sk</span><span class="p">,</span><span class="n">f_old_ep</span><span class="p">,</span><span class="n">f_new_ep</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filtered_skeleton_branches</span><span class="p">,</span><span class="n">original_endpoints</span><span class="p">,</span><span class="n">new_endpoints</span><span class="p">):</span>
            <span class="n">f_sk_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">f_sk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">old_ep</span><span class="p">,</span><span class="n">new_ep</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f_old_ep</span><span class="p">,</span><span class="n">f_new_ep</span><span class="p">):</span>
                <span class="n">f_sk_graph</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">add_new_coordinate_node</span><span class="p">(</span><span class="n">f_sk_graph</span><span class="p">,</span>
                                           <span class="n">node_coordinate</span><span class="o">=</span><span class="n">new_ep</span><span class="p">,</span>
                                           <span class="n">replace_coordinates</span><span class="o">=</span><span class="n">old_ep</span><span class="p">,</span>
                                          <span class="n">return_node_id</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">edited_skeleton_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">f_sk_graph</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering branches = </span><span class="si">{</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">combine_close_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">combine_close_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">edited_skeleton_branches</span><span class="p">,</span><span class="n">branch_keep_idx</span>
        

    <span class="k">if</span> <span class="n">convert_back_to_skeleton</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_sk_graph_cp</span></div>






<div class="viewcode-block" id="old_combine_close_branch_points"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.old_combine_close_branch_points">[docs]</a><span class="k">def</span> <span class="nf">old_combine_close_branch_points</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                <span class="n">combine_threshold</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span>
                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a skeleton or graph and return a skelton/graph </span>
<span class="sd">    where close branch points are combined</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example Code of how could get the orders: </span>
<span class="sd">    # How could potentially get the edge order we wanted</span>
<span class="sd">    endpoint_neighbors_to_order_map = dict()</span>
<span class="sd">    for k in endpoint_neighbors:</span>
<span class="sd">        total_orders = []</span>
<span class="sd">        total_orders_neighbors = []</span>
<span class="sd">        for j in p:</span>
<span class="sd">            try:</span>
<span class="sd">                total_orders.append(curr_sk_graph[j][k][&quot;order&quot;])</span>
<span class="sd">                total_orders_neighbors.append(j)</span>
<span class="sd">            except:</span>
<span class="sd">                pass</span>
<span class="sd">        order_index = np.argmin(total_orders)</span>
<span class="sd">        endpoint_neighbors_to_order_map[(k,total_orders_neighbors[order_index])] = total_orders[order_index]</span>
<span class="sd">    endpoint_neighbors_to_order_map</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk = reload(sk)</span>
<span class="sd">    from python_tools import numpy_utils as nu</span>
<span class="sd">    nu = reload(nu)</span>
<span class="sd">    branch_skeleton_data_cleaned = []</span>
<span class="sd">    for i,curr_sk in enumerate(branch_skeleton_data):</span>
<span class="sd">        print(f&quot;\n----- Working on skeleton {i} ---------&quot;)</span>
<span class="sd">        new_sk = sk.combine_close_branch_points(curr_sk,print_flag=True)</span>
<span class="sd">        print(f&quot;Original Sk = {curr_sk.shape}, Cleaned Sk = {new_sk.shape}&quot;)</span>
<span class="sd">        branch_skeleton_data_cleaned.append(new_sk)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">convert_back_to_skeleton</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#1) convert the skeleton to a graph</span>
    
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
        <span class="n">curr_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">convert_back_to_skeleton</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_sk_graph</span> <span class="o">=</span> <span class="n">skeleton</span>

    <span class="c1">#2) Get all of the high degree nodes</span>
    <span class="n">high_degree_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_greater_or_equal_degree_k</span><span class="p">(</span><span class="n">curr_sk_graph</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checked that thes high degree nodes were correctly retrieved</span>
<span class="sd">    high_degree_coordinates = xu.get_node_attributes(curr_sk_graph,node_list = high_degree_nodes)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_skeletons=[curr_sk],</span>
<span class="sd">                              other_scatter=[high_degree_coordinates])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#3) Get paths between all of them high degree nodes</span>
    <span class="n">valid_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_path_endpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_path_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">high_degree_nodes</span><span class="p">:</span>
        <span class="n">degree_copy</span> <span class="o">=</span> <span class="n">high_degree_nodes</span><span class="p">[</span><span class="n">high_degree_nodes</span> <span class="o">!=</span> <span class="n">s</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">degree_copy</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">path_len</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra</span><span class="p">(</span><span class="n">curr_sk_graph</span><span class="p">,</span><span class="n">source</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">combine_threshold</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#a valid path was found</span>
                <span class="n">degree_no_endpoints</span> <span class="o">=</span> <span class="n">degree_copy</span><span class="p">[</span><span class="n">degree_copy</span> <span class="o">!=</span> <span class="n">t</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">degree_no_endpoints</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">match_path</span><span class="o">=</span><span class="kc">False</span>
                    <span class="k">for</span> <span class="n">v_p</span> <span class="ow">in</span> <span class="n">valid_paths</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v_p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                            <span class="n">match_path</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">match_path</span><span class="p">:</span>
                        <span class="n">valid_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
                        <span class="n">valid_path_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_len</span><span class="p">)</span>
                        <span class="n">valid_path_endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">])</span>
                        
                    
                    
<span class="c1">#                     sorted_path = np.sort(path)</span>
<span class="c1">#                     try:</span>
                        
                        
<span class="c1">#                         if len(nu.matching_rows(valid_paths,sorted_path)) &gt; 0:</span>
<span class="c1">#                             continue</span>
<span class="c1">#                         else:</span>
<span class="c1">#                             valid_paths.append(sorted_path)</span>
<span class="c1">#                     except:</span>
<span class="c1">#                         print(f&quot;valid_paths = {valid_paths}&quot;)</span>
<span class="c1">#                         print(f&quot;sorted_path = {sorted_path}&quot;)</span>
<span class="c1">#                         print(f&quot;nu.matching_rows(valid_paths,sorted_path) = {nu.matching_rows(valid_paths,sorted_path)}&quot;)</span>
<span class="c1">#                         raise Exception()</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid paths to replace&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_paths = </span><span class="si">{</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_path_lengths = </span><span class="si">{</span><span class="n">valid_path_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid paths found so just returning the original&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">skeleton</span>
    
    <span class="c1"># Need to combine paths if there is any overlapping:</span>
    <span class="n">valid_paths</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # --------------If there were valid paths found -------------</span>
<span class="sd">    </span>
<span class="sd">    5) For the paths that past the thresholding:</span>
<span class="sd">    With a certain path</span>
<span class="sd">    a. take the 2 end high degree nodes and get all of their neighbors</span>
<span class="sd">    a2. get the coordinates of the endpoints and average them for new node</span>
<span class="sd">    b. Create a new node with all the neighbors and averaged coordinate</span>
<span class="sd">    c. replace all of the other paths computed (if they had the 2 end high degree nodes) replace with the new node ID</span>
<span class="sd">    d. Delete the old high degree ends and all nodes on the path</span>
<span class="sd">    Go to another path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_sk_graph_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_sk_graph</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">p_end_nodes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">,</span><span class="n">valid_path_endpoints</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on path </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#a. take the 2 end high degree nodes and get all of their neighbors</span>
        <span class="n">endpoint_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]))</span>
        <span class="n">endpoint_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">endpoint_neighbors</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoint_neighbors = </span><span class="si">{</span><span class="n">endpoint_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;p_end_nodes = </span><span class="si">{</span><span class="n">p_end_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#a2. get the coordinates of the endpoints and average them for new node</span>
        <span class="c1">#endpoint_coordinates = np.vstack([xu.get_node_attributes(curr_sk_graph_cp,node_list=k) for k in p])</span>
        <span class="n">path_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="n">end_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">path_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;end_coordinates = </span><span class="si">{</span><span class="n">end_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="c1">#         print(f&quot;endpoint_coordinates = {endpoint_coordinates}&quot;)</span>
<span class="c1">#         print(f&quot;endpoint_coordinates_try_2 = {endpoint_coordinates_try_2}&quot;)</span>
        <span class="n">average_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">path_coordinates</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
        <span class="c1">#b. Create a new node with all the neighbors and averaged coordinate</span>
        <span class="n">new_node_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">curr_sk_graph_cp</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_node_id</span><span class="p">,</span><span class="n">coordinates</span><span class="o">=</span><span class="n">average_endpoints</span><span class="p">)</span>
        
        <span class="c1">#c. replace all of the other paths computed (if they had the 2 end high degree nodes) replace with the new node ID</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoint_neighbors = </span><span class="si">{</span><span class="n">endpoint_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_sk_graph_cp</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="n">new_node_id</span><span class="p">,</span><span class="n">k</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">average_endpoints</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">endpoint_neighbors</span><span class="p">])</span>
        
    <span class="c1">#d. Delete the old high degree ends and all nodes on the path</span>
    <span class="n">concat_valid_paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">valid_paths</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Concatenating all paths and deleting: </span><span class="si">{</span><span class="n">concat_valid_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">curr_sk_graph_cp</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">concat_valid_paths</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">convert_back_to_skeleton</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">curr_sk_graph_cp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_sk_graph_cp</span></div>

    
    
    
<span class="c1"># ---------------------- Full Skeletonization Function --------------------- #</span>



<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshlab</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="skeletonize_connected_branch_meshparty"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeletonize_connected_branch_meshparty">[docs]</a><span class="k">def</span> <span class="nf">skeletonize_connected_branch_meshparty</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                           <span class="n">segment_size</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                           <span class="n">invalidation_d</span> <span class="o">=</span> <span class="mi">1200</span><span class="p">,</span>
                                           <span class="n">combine_close_skeleton_nodes_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                           <span class="n">filter_end_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                           <span class="n">filter_end_node_length</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
                                           <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">only_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span>
                                          <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To do the meshparty skeletonization and skeleton procedure</span>
<span class="sd">    </span>
<span class="sd">    Example: Applying skeletonization to an axon mesh</span>
<span class="sd">    </span>
<span class="sd">    axon_mesh = neuron_obj.axon_mesh</span>
<span class="sd">    meshparty_sk,sk_meshparty_obj = sk.skeletonize_connected_branch_meshparty(axon_mesh,</span>
<span class="sd">                                                            root=neuron_obj.axon_starting_coordinate,</span>
<span class="sd">                                                            invalidation_d=1200,</span>
<span class="sd">                                                            #combine_close_skeleton_nodes_threshold=20000,</span>
<span class="sd">                                                                              filter_end_node_length=3000,</span>
<span class="sd">                                                                             )</span>

<span class="sd">    ipvu.plot_objects(axon_mesh,meshparty_sk)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># --------------- Part 3: Meshparty skeletonization and Decomposition ------------- #</span>
    <span class="n">sk_meshparty_obj</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize_mesh_largest_component</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                            <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
                                                              <span class="n">filter_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                               <span class="n">invalidation_d</span><span class="o">=</span><span class="n">invalidation_d</span><span class="p">,</span>
                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;meshparty_segment_size = </span><span class="si">{</span><span class="n">meshparty_segment_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeleton_obj_to_branches</span><span class="p">(</span><span class="n">sk_meshparty_obj</span><span class="p">,</span>
                                                          <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
                                                          <span class="n">meshparty_segment_size</span><span class="o">=</span><span class="n">segment_size</span><span class="p">,</span>
                                                          <span class="n">return_skeleton_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="n">combine_close_skeleton_nodes_threshold</span><span class="p">,</span>
                                                 <span class="n">filter_end_nodes</span><span class="o">=</span><span class="n">filter_end_nodes</span><span class="p">,</span>
                                                 <span class="n">filter_end_node_length</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time meshparty skeletonization: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting the skeleton&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">new_skeleton</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">only_skeleton</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_skeleton</span><span class="p">,</span><span class="n">sk_meshparty_obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_skeleton</span></div>



<div class="viewcode-block" id="skeletonize_connected_branch"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeletonize_connected_branch">[docs]</a><span class="k">def</span> <span class="nf">skeletonize_connected_branch</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                        <span class="n">output_folder</span><span class="o">=</span><span class="s2">&quot;./temp&quot;</span><span class="p">,</span>
                        <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span>
                        <span class="n">surface_reconstruction_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                        <span class="n">surface_reconstruction_width</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#250,</span>
                        <span class="n">poisson_stitch_size</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
                        <span class="n">n_surface_downsampling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">n_surface_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                        <span class="n">skeleton_print</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">mesh_subtraction_distance_threshold</span><span class="o">=</span><span class="n">mesh_subtraction_distance_threshold_default</span><span class="p">,</span>
                        <span class="n">mesh_subtraction_buffer</span><span class="o">=</span><span class="n">mesh_subtraction_buffer_default</span><span class="p">,</span><span class="c1">#50,</span>
                        <span class="n">max_stitch_distance</span> <span class="o">=</span><span class="mi">10_000</span><span class="p">,</span><span class="c1"># 18000,</span>
                        <span class="n">current_min_edge</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                        <span class="n">close_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">use_surface_after_CGAL</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">remove_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">remove_mesh_interior_face_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a mesh and construct a full skeleton of it</span>
<span class="sd">    (Assuming the Soma is already extracted)</span>
<span class="sd">    </span>
<span class="sd">    1) Poisson Surface Reconstruction</span>
<span class="sd">    2) CGAL skeletonization of all signfiicant pieces </span>
<span class="sd">        (if above certain size ! threshold) </span>
<span class="sd">                --&gt; if not skip straight to surface skeletonization</span>
<span class="sd">    3) Using CGAL skeleton, find the leftover mesh not skeletonized</span>
<span class="sd">    4) Do surface reconstruction on the parts that are left over</span>
<span class="sd">    - with some downsampling</span>
<span class="sd">    5) Stitch the skeleton </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">skeleton_print</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">export_leftover_debug</span> <span class="o">=</span> <span class="kc">False</span>
    
        
    <span class="k">if</span> <span class="n">use_surface_after_CGAL</span><span class="p">:</span>
        <span class="n">restriction_threshold</span> <span class="o">=</span> <span class="n">surface_reconstruction_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">restriction_threshold</span> <span class="o">=</span> <span class="n">poisson_stitch_size</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;restriction_threshold = </span><span class="si">{</span><span class="n">restriction_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;connectivity = </span><span class="si">{</span><span class="n">connectivity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside skeletonize_connected_branch and use_surface_after_CGAL=</span><span class="si">{</span><span class="n">use_surface_after_CGAL</span><span class="si">}</span><span class="s2">, surface_reconstruction_size=</span><span class="si">{</span><span class="n">surface_reconstruction_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#check that the mesh is all one piece</span>

    <span class="k">if</span> <span class="n">remove_mesh_interior_face_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing interior meshes greater than </span><span class="si">{</span><span class="n">remove_mesh_interior_face_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="n">remove_mesh_interior_face_threshold</span><span class="p">,</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">#splitting the mesh into significant pieces</span>
    <span class="n">current_mesh_splits_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                               <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                  <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">))</span>
    
    <span class="n">face_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">current_mesh_splits_pre</span><span class="p">])</span> 
    <span class="n">keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_lens</span> <span class="o">&gt;</span> <span class="n">restriction_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;keep_idx = </span><span class="si">{</span><span class="n">keep_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_idx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">keep_idx</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="n">current_mesh_splits</span> <span class="o">=</span> <span class="n">current_mesh_splits_pre</span><span class="p">[</span><span class="n">keep_idx</span><span class="p">]</span>
    
    
<span class="c1">#     if len(current_mesh_splits) &gt; 1:</span>
<span class="c1">#         print(f&quot;The mesh passed has {len(current_mesh_splits)} pieces so just taking the largest one {current_mesh_splits[0]}&quot;)</span>
<span class="c1">#         current_mesh = current_mesh_splits[0]</span>

    <span class="c1"># check the size of the branch and if small enough then just do</span>
    <span class="c1"># Surface Skeletonization</span>
    
    <span class="n">skeleton_ready_for_stitching_total</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mesh_idx</span><span class="p">,</span><span class="n">current_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_splits</span><span class="p">):</span>
        
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">surface_reconstruction_size</span><span class="p">:</span>
            <span class="c1">#do a surface skeletonization</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Doing skeleton surface reconstruction&quot;</span><span class="p">)</span>
<span class="c1">#             surf_sk = generate_surface_skeleton(current_mesh.vertices,</span>
<span class="c1">#                                         current_mesh.faces,</span>
<span class="c1">#                                         surface_samples=n_surface_samples,</span>
<span class="c1">#                                                  n_surface_downsampling=n_surface_downsampling )</span>

            <span class="n">surf_sk</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)</span>
            <span class="n">skeleton_ready_for_stitching</span> <span class="o">=</span>  <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">surf_sk</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1">#if can&#39;t simply do a surface skeletonization then </span>
            <span class="c1">#use cgal method that requires temp folder</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">()):</span>
                <span class="n">output_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_folder</span><span class="p">))</span>
                <span class="n">output_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># CGAL Step 1: Do Poisson Surface Reconstruction</span>
            <span class="n">Poisson_obj</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


            <span class="n">skeleton_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     Starting Screened Poisson&quot;</span><span class="p">)</span>
            <span class="n">new_mesh</span><span class="p">,</span><span class="n">output_subprocess_obj</span> <span class="o">=</span> <span class="n">Poisson_obj</span><span class="p">(</span>   
                                        <span class="n">vertices</span><span class="o">=</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                         <span class="n">faces</span><span class="o">=</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                        <span class="n">mesh_filename</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.off&quot;</span><span class="p">,</span>
                                         <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">delete_temp_files</span><span class="o">=</span><span class="n">delete_temp_files</span><span class="p">,</span>
                                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">close_holes</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the close holes feature&quot;</span><span class="p">)</span>

                <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">)</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Old Way </span>

<span class="sd">                FillHoles_obj = meshlab.FillHoles(output_folder,overwrite=True)</span>

<span class="sd">                new_mesh,output_subprocess_obj = FillHoles_obj(   </span>
<span class="sd">                                                    vertices=new_mesh.vertices,</span>
<span class="sd">                                                     faces=new_mesh.faces,</span>
<span class="sd">                                                     return_mesh=True,</span>
<span class="sd">                                                     delete_temp_files=delete_temp_files,</span>
<span class="sd">                                                    )</span>
<span class="sd">                &quot;&quot;&quot;</span>


            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-----Time for Screened Poisson= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">skeleton_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="c1">#2) Filter away for largest_poisson_piece:</span>

            <span class="c1">#the connectivity her HAS to edges or could send a non-manifold mesh to calcification</span>
            <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">,</span>
                                                <span class="n">significance_threshold</span><span class="o">=</span><span class="n">restriction_threshold</span><span class="p">,</span>
                                                  <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Signifiant mesh pieces of </span><span class="si">{</span><span class="n">surface_reconstruction_size</span><span class="si">}</span><span class="s2"> size &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;after poisson = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">skeleton_ready_for_stitching</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">skeleton_files</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># to be erased later on if need be</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No signficant skeleton pieces so just doing surface skeletonization&quot;</span><span class="p">)</span>
                <span class="c1"># do surface skeletonization on all of the pieces</span>
                <span class="n">surface_mesh_pieces</span> <span class="o">=</span> <span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">,</span>
                                                <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                              <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

                <span class="c1">#get the skeletons for all those pieces</span>
<span class="c1">#                 current_mesh_skeleton_list = [</span>
<span class="c1">#                     generate_surface_skeleton(p.vertices,</span>
<span class="c1">#                                         p.faces,</span>
<span class="c1">#                                         surface_samples=n_surface_samples,</span>
<span class="c1">#                                         n_surface_downsampling=n_surface_downsampling )</span>
<span class="c1">#                     for p in surface_mesh_pieces</span>
<span class="c1">#                 ]</span>
                
                <span class="n">current_mesh_skeleton_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">surface_mesh_pieces</span>
                <span class="p">]</span>
                

                <span class="n">skeleton_ready_for_stitching</span> <span class="o">=</span> <span class="n">stack_skeletons</span><span class="p">(</span><span class="n">current_mesh_skeleton_list</span><span class="p">)</span>

                <span class="c1">#will stitch them together later</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#if there are parts that can do the cgal skeletonization</span>
                <span class="n">skeleton_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_pieces = </span><span class="si">{</span><span class="n">mesh_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     Starting Calcification (Changed back where stitches large poissons)&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">piece</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_pieces</span><span class="p">):</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot; Old way that didnt&#39; check for manifoldness</span>

<span class="sd">                    current_mesh_path = output_folder / f&quot;{name}_{zz}&quot;</span>
<span class="sd">                    #if skeleton_print:</span>

<span class="sd">                    print(f&quot;current_mesh_path = {current_mesh_path}&quot;)</span>
<span class="sd">                    written_path = write_neuron_off(piece,current_mesh_path)</span>

<span class="sd">                    returned_value, sk_file_name = calcification(written_path,</span>
<span class="sd">                                                                   min_edge_length = current_min_edge)</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="c1">#print(f&quot;Path sending to calcification = {written_path[:-4]}&quot;)</span>

                    <span class="n">returned_value</span><span class="p">,</span> <span class="n">sk_file_name</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_cgal</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">piece</span><span class="p">,</span>
                                                                    <span class="n">filepath</span><span class="o">=</span> <span class="n">output_folder</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">zz</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                         <span class="n">return_skeleton_file_path_and_status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">min_edge_length</span> <span class="o">=</span> <span class="n">current_min_edge</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;returned_value = </span><span class="si">{</span><span class="n">returned_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_file_name = </span><span class="si">{</span><span class="n">sk_file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
                        
                    <span class="k">if</span> <span class="n">error_on_bad_cgal_return</span> <span class="ow">and</span> <span class="n">returned_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">piece</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sk_file_name</span><span class="si">}</span><span class="s2">_not_sk&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;******</span><span class="se">\n\n\n\n\n\n\n\n\n\n\n\n</span><span class="s2">   SKELETON NOT FORMED </span><span class="se">\n\n\n\n\n\n\n\n\n\n\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bad skeleton cgal return value = </span><span class="si">{</span><span class="n">sk_file_name</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">sk_file_name</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                        
                    <span class="c1">#print(f&quot;Time for skeletonizatin = {time.time() - skeleton_start}&quot;)</span>
                    <span class="n">skeleton_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk_file_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-----Time for Running Calcification = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">skeleton_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#collect the skeletons and subtract from the mesh</span>

                <span class="n">significant_poisson_skeleton</span> <span class="o">=</span> <span class="n">read_skeleton_edges_coordinates</span><span class="p">(</span><span class="n">skeleton_files</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_files = </span><span class="si">{</span><span class="n">skeleton_files</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;significant_poisson_skeleton = </span><span class="si">{</span><span class="n">significant_poisson_skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">significant_poisson_skeleton</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;significant_poisson_skeleton_</span><span class="si">{</span><span class="n">mesh_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">significant_poisson_skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1">#                 if not use_surface_after_CGAL:</span>
    <span class="c1">#                     surf_sk = generate_surface_skeleton(m.vertices,</span>
    <span class="c1">#                                                m.faces,</span>
    <span class="c1">#                                                surface_samples=n_surface_samples,</span>
    <span class="c1">#                                     n_surface_downsampling=n_surface_downsampling )</span>
    <span class="c1">#                     return surf_sk</span>
    <span class="c1">#                     raise gu.CGAL_skel_error(f&quot;No CGAL skeleton was generated when the {use_surface_after_CGAL} flag was set&quot;)</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot;------------------ 1 / 2 /2021 Addition ------------------------&quot;&quot;&quot;</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No recorded skeleton so skipping&quot;</span>
                         <span class="s2">&quot; to meshparty skeletonization&quot;</span><span class="p">)</span>

                    <span class="n">skeleton_ready_for_stitching</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize_connected_branch_meshparty</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1">#leftover_meshes_sig = [current_mesh]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">remove_cycles</span><span class="p">:</span>
                        <span class="n">significant_poisson_skeleton</span> <span class="o">=</span> <span class="n">remove_cycles_from_skeleton</span><span class="p">(</span><span class="n">significant_poisson_skeleton</span><span class="p">)</span>


                    <span class="k">if</span> <span class="n">use_surface_after_CGAL</span><span class="p">:</span>
                        <span class="n">boolean_significance_threshold</span><span class="o">=</span><span class="mi">5</span>

                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before mesh subtraction number of skeleton edges = </span><span class="si">{</span><span class="n">significant_poisson_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">mesh_pieces_leftover</span> <span class="o">=</span>  <span class="n">mesh_subtraction_by_skeleton</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                                                                    <span class="n">significant_poisson_skeleton</span><span class="p">,</span>
                                                                    <span class="n">buffer</span><span class="o">=</span><span class="n">mesh_subtraction_buffer</span><span class="p">,</span>
                                                                    <span class="n">distance_threshold</span><span class="o">=</span><span class="n">mesh_subtraction_distance_threshold</span><span class="p">,</span>
                                                                    <span class="c1">#significance_threshold=boolean_significance_threshold,</span>
                                                                   <span class="p">)</span>

                        <span class="c1"># *****adding another significance threshold*****</span>

                        <span class="n">leftover_meshes_sig</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_pieces_leftover</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">surface_reconstruction_size</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">leftover_meshes_sig</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;leftover_meshes_sig_before_filter_</span><span class="si">{</span><span class="n">mesh_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="c1">#want to filter these significant pieces for only those below a certain width</span>
<span class="w">                    </span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    This part has been deprecated because would not help catch those segments where the </span>
<span class="sd">                    cgal skeletonization failed</span>
<span class="sd">                    </span>
<span class="sd">                    </span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">surface_reconstruction_width</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">surface_reconstruction_width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;USING THE SDF WIDTHS TO FILTER SURFACE SKELETONS&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover_meshes_sig before filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">leftover_meshes_sig_new</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="kn">from</span> <span class="nn">trimesh.ray</span> <span class="kn">import</span> <span class="n">ray_pyembree</span>
                        <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)</span>
<span class="w">                        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Pseudocode:</span>
<span class="sd">                        For each leftover significant mesh</span>
<span class="sd">                        1) Map the leftover piece back to the original face</span>
<span class="sd">                        2) Get the widths fo the piece</span>
<span class="sd">                        3) get the median of the non-zero values</span>
<span class="sd">                        4) if greater than the surface_reconstruction_width then add to list</span>

<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">leftover_meshes_sig</span><span class="p">:</span>
                            <span class="n">face_indices_leftover_0</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">lm</span><span class="p">)</span>
                            <span class="n">curr_width_distances</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span>
                              <span class="n">face_inds</span><span class="o">=</span><span class="n">face_indices_leftover_0</span><span class="p">,</span>
                                                     <span class="n">ray_inter</span><span class="o">=</span><span class="n">ray_inter</span>
                            <span class="p">)</span>
                            <span class="n">filtered_widths</span> <span class="o">=</span> <span class="n">curr_width_distances</span><span class="p">[</span><span class="n">curr_width_distances</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_widths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">filtered_widths</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">surface_reconstruction_width</span><span class="p">:</span>
                                <span class="n">leftover_meshes_sig_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>

                        <span class="n">leftover_meshes_sig</span> <span class="o">=</span> <span class="n">leftover_meshes_sig_new</span>
                        <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover_meshes_sig AFTER filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;leftover_meshes_sig_after_filter_</span><span class="si">{</span><span class="n">mesh_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">leftover_meshes</span> <span class="o">=</span> <span class="n">combine_meshes</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">)</span>
                
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(leftover_meshes_sig) = </span><span class="si">{</span><span class="n">leftover_meshes_sig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">export_leftover_debug</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">curr_m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">):</span>
                                <span class="n">debug_folder_name</span> <span class="o">=</span> <span class="s2">&quot;leftover_test&quot;</span>
                                <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">debug_folder_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="n">tu</span><span class="o">.</span><span class="n">write_neuron_off</span><span class="p">(</span><span class="n">curr_m</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">debug_folder_name</span><span class="si">}</span><span class="s2">/limb_</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">zz</span><span class="si">}</span><span class="s2">.off&quot;</span><span class="p">)</span>

                    <span class="n">leftover_meshes_sig_surf_sk</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">leftover_meshes_sig</span><span class="p">):</span>
    <span class="c1">#                     surf_sk = generate_surface_skeleton(m.vertices,</span>
    <span class="c1">#                                                    m.faces,</span>
    <span class="c1">#                                                    surface_samples=n_surface_samples,</span>
    <span class="c1">#                                         n_surface_downsampling=n_surface_downsampling )</span>
                        <span class="n">surf_sk</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">surf_sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">leftover_meshes_sig_surf_sk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_sk</span><span class="p">)</span>
                    <span class="n">leftovers_stacked</span> <span class="o">=</span> <span class="n">stack_skeletons</span><span class="p">(</span><span class="n">leftover_meshes_sig_surf_sk</span><span class="p">)</span>
                    <span class="c1">#print(f&quot;significant_poisson_skeleton = {significant_poisson_skeleton}&quot;)</span>
                    <span class="c1">#print(f&quot;leftover_meshes_sig_surf_sk = {leftover_meshes_sig_surf_sk}&quot;)</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">leftovers_stacked</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;leftovers_stacked_</span><span class="si">{</span><span class="n">mesh_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;STacking the leftover and significant poisson skeleton&quot;</span><span class="p">)</span>
                    <span class="n">skeleton_ready_for_stitching</span> <span class="o">=</span> <span class="n">stack_skeletons</span><span class="p">([</span><span class="n">significant_poisson_skeleton</span><span class="p">,</span><span class="n">leftovers_stacked</span><span class="p">])</span>
                
        <span class="n">skeleton_ready_for_stitching_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skeleton_ready_for_stitching</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">skeleton_ready_for_stitching_total</span><span class="p">,</span><span class="s2">&quot;skeleton_ready_for_stitching_total&quot;</span><span class="p">)</span>
            
    <span class="n">skeleton_ready_for_stitching</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">skeleton_ready_for_stitching_total</span><span class="p">])</span>
    <span class="c1">#now want to stitch together whether generated from </span>
    <span class="k">if</span> <span class="n">skeleton_print</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After cgal process the un-stitched skeleton has shape </span><span class="si">{</span><span class="n">skeleton_ready_for_stitching</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#su.compressed_pickle(skeleton_ready_for_stitching,&quot;sk_before_stitiching&quot;)</span>

    <span class="c1"># Now want to always do the skeleton stitching</span>
    <span class="c1">#if use_surface_after_CGAL:</span>
    <span class="n">stitched_skeletons_full</span> <span class="o">=</span> <span class="n">stitch_skeleton</span><span class="p">(</span>
                                              <span class="n">skeleton_ready_for_stitching</span><span class="p">,</span>
                                              <span class="n">max_stitch_distance</span><span class="o">=</span><span class="n">max_stitch_distance</span><span class="p">,</span>
                                              <span class="n">stitch_print</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                              <span class="n">main_mesh</span> <span class="o">=</span> <span class="p">[]</span>
                                            <span class="p">)</span>
    <span class="c1">#else:</span>
    <span class="c1">#stitched_skeletons_full = skeleton_ready_for_stitching</span>

    <span class="c1">#stitched_skeletons_full_cleaned = clean_skeleton(stitched_skeletons_full)</span>

    <span class="c1"># erase the skeleton files if need to be</span>
    <span class="k">if</span> <span class="n">delete_temp_files</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sk_fi</span> <span class="ow">in</span> <span class="n">skeleton_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">sk_fi</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">Path</span><span class="p">(</span><span class="n">sk_fi</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>

    <span class="c1"># if created temp folder then erase if empty</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_folder</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./temp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">()):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The process was using a temp folder&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">output_folder</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Temp folder was empty so deleting it&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output_folder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_folder</span><span class="o">.</span><span class="n">absolute</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">stitched_skeletons_full</span></div>
    
<div class="viewcode-block" id="soma_skeleton_stitching"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.soma_skeleton_stitching">[docs]</a><span class="k">def</span> <span class="nf">soma_skeleton_stitching</span><span class="p">(</span><span class="n">total_soma_skeletons</span><span class="p">,</span><span class="n">soma_mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will stitch together the meshes that are touching</span>
<span class="sd">    the soma </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Compute the soma mesh center point</span>
<span class="sd">    2) For meshes that were originally connected to soma</span>
<span class="sd">    a. Find the closest skeletal point to soma center</span>
<span class="sd">    b. Add an edge from closest point to soma center</span>
<span class="sd">    3) Then do stitching algorithm on all of remaining disconnected</span>
<span class="sd">        skeletons</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1) Compute the soma mesh center point</span>
    <span class="n">soma_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">soma_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">soma_connecting_skeleton</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">skel</span> <span class="ow">in</span> <span class="n">total_soma_skeletons</span><span class="p">:</span>
        <span class="c1">#get the unique vertex points</span>
        <span class="n">unique_skeleton_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">skel</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># a. Find the closest skeletal point to soma center</span>
        <span class="c1"># b. Add an edge from closest point to soma center</span>
        <span class="n">mesh_tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">unique_skeleton_nodes</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">mesh_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">soma_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">closest_skeleton_vert</span> <span class="o">=</span> <span class="n">unique_skeleton_nodes</span><span class="p">[</span><span class="n">closest_node</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)]]</span>
        <span class="n">soma_connecting_skeleton</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">closest_skeleton_vert</span><span class="p">,</span><span class="n">soma_center</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_connecting_skeleton[0].shape = </span><span class="si">{</span><span class="n">soma_connecting_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_soma_skeletons[0].shape = </span><span class="si">{</span><span class="n">total_soma_skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># stith all of the ekeletons together</span>
    <span class="n">soma_stitched_sk</span> <span class="o">=</span> <span class="n">stack_skeletons</span><span class="p">(</span><span class="n">total_soma_skeletons</span> <span class="o">+</span> <span class="n">soma_connecting_skeleton</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">soma_stitched_sk</span></div>



<span class="c1"># ------ Functions to help with the compartment ---- #</span>
<span class="c1"># converted into a function</span>

<div class="viewcode-block" id="get_ordered_branch_nodes_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.get_ordered_branch_nodes_coordinates">[docs]</a><span class="k">def</span> <span class="nf">get_ordered_branch_nodes_coordinates</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Purpose: want to get ordered skeleton coordinates:</span>
<span class="sd">    1) get both end nodes</span>
<span class="sd">    2) count shortest path between them (to get order)</span>
<span class="sd">    3) then use the get node attributes function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#find the 2 endpoints:</span>
    <span class="n">sk_graph_clean</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
    <span class="n">enpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sk_graph_clean</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1">#print(f&quot;enpoints= {enpoints}&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enpoints</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="s2">&quot;skeleton_graph&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sk_graph_clean</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_graph_clean.degree = </span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="n">sk_graph_clean</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of endpoints was not 2 for a branch&quot;</span><span class="p">)</span>

    <span class="c1"># gets the shortest path</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">sk_graph_clean</span><span class="p">,</span><span class="n">enpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">enpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
    <span class="c1">#print(f&quot;shortest_path = {shortest_path}&quot;)</span>

    <span class="n">skeleton_node_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">shortest_path</span><span class="p">)</span>
    <span class="c1">#print(f&quot;skeleton_node_coordinates = {skeleton_node_coordinates}&quot;)</span>

    <span class="k">if</span> <span class="n">nodes</span><span class="o">==</span><span class="kc">False</span> <span class="ow">and</span> <span class="n">coordinates</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_node_coordinates</span>
    <span class="k">elif</span> <span class="n">nodes</span><span class="o">==</span><span class="kc">True</span> <span class="ow">and</span> <span class="n">coordinates</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shortest_path</span>
    <span class="k">elif</span> <span class="n">nodes</span><span class="o">==</span><span class="kc">True</span> <span class="ow">and</span> <span class="n">coordinates</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shortest_path</span><span class="p">,</span><span class="n">skeleton_node_coordinates</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;neither nodes or coordinates set to return from get_ordered_branch_nodes_coordinates&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="split_skeleton_into_edges"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.split_skeleton_into_edges">[docs]</a><span class="k">def</span> <span class="nf">split_skeleton_into_edges</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will split a skeleton into a list of skeletons where each skeleton is just</span>
<span class="sd">    one previous edge of the skeleton before</span>
<span class="sd">    </span>
<span class="sd">    Example of how to use: </span>
<span class="sd">    </span>
<span class="sd">    returned_split = split_skeleton_into_edges(downsampled_skeleton)</span>
<span class="sd">    print(len(returned_split), downsampled_skeleton.shape)</span>
<span class="sd">    returned_split</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">total_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">current_skeleton</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total_skeletons</span></div>
    
        
<div class="viewcode-block" id="decompose_skeleton_to_branches"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.decompose_skeleton_to_branches">[docs]</a><span class="k">def</span> <span class="nf">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">,</span>
                                   <span class="n">max_branch_distance</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                  <span class="n">skip_branch_threshold</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
                                  <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">remove_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example of how to run: </span>
<span class="sd">    elephant_skeleton = sk.read_skeleton_edges_coordinates(&quot;../test_neurons/elephant_skeleton.cgal&quot;)</span>
<span class="sd">    elephant_skeleton_branches = sk.decompose_skeleton_to_branches(elephant_skeleton)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_skeletons=[sk.stack_skeletons(elephant_skeleton_branches)])</span>
<span class="sd">    </span>
<span class="sd">    ***** Future error possibly: there could be issues in the future where had triangles of degree &gt; 2 in your skeleton******</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()),</span><span class="nb">type</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">())]:</span>
        <span class="n">el_sk_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">el_sk_graph</span> <span class="o">=</span> <span class="n">current_skeleton</span>
    
    
    
    <span class="n">el_sk_graph</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">el_sk_graph</span><span class="p">)</span>
    <span class="n">degree_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">el_sk_graph</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">branch_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">degree_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">seperated_branch_graph</span> <span class="o">=</span> <span class="n">el_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">branch_nodes</span><span class="p">)</span>
    
    <span class="n">branch_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">branch_skeleton_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_cycle_iterations</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="n">seperated_branch_graph_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">seperated_branch_graph</span><span class="p">))</span>
    <span class="c1"># now add back the nodes that were missing for each branch and collect all of the skeletons</span>
    <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">seperated_branch_graph_comp</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        new method of decomposing that avoids keeping loops (but will error if getting rid of large loop)</span>
<span class="sd">        </span>
<span class="sd">        # old way </span>
<span class="sd">        all_neighbors = [xu.get_neighbors(el_sk_graph,n) for n in curr_branch] </span>
<span class="sd">        all_neighbors.append(list(curr_branch))</span>
<span class="sd">        total_neighbors = np.unique(np.hstack(all_neighbors))</span>
<span class="sd">        branch_subgraph = el_sk_graph.subgraph(total_neighbors)</span>
<span class="sd">        branch_skeletons.append(sk.convert_graph_to_skeleton(branch_subgraph))</span>
<span class="sd">        </span>
<span class="sd">        New method: only if the two endpoints are connected together, then we give </span>
<span class="sd">        back a skeleton just of those endpoints (so this will skip the current branch alltogether)</span>
<span class="sd">        --&gt; but if skipping a branch that is too big then error</span>
<span class="sd">        - else do the old method</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">all_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">el_sk_graph</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_branch</span><span class="p">]</span> 
        <span class="n">all_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">))</span>
        <span class="n">total_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_neighbors</span><span class="p">))</span>
        
        <span class="c1">#check to see if the t junctions are connected</span>
        <span class="n">high_degree_neigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_neighbors</span> <span class="k">if</span> <span class="n">degree_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_degree_neigh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Too many high degree nodes found in branch of decomposition&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_degree_neigh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">high_degree_neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">el_sk_graph</span><span class="p">,</span><span class="n">high_degree_neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;high-degree endpoints were connected so just using that connection&quot;</span><span class="p">)</span>
                
                <span class="c1">#check that what skipping isn&#39;t too big</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_branch = </span><span class="si">{</span><span class="n">curr_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">el_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">))</span>
                    <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">))</span>
                    <span class="k">if</span>  <span class="n">skip_distance</span> <span class="o">&gt;</span> <span class="n">skip_branch_threshold</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch that we are skipping is too large with skip distance: </span><span class="si">{</span><span class="n">skip_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#save this for later when add back all high degree branches that are connected</span>
<span class="c1">#                 branch_skeletons.append((xu.get_node_attributes(el_sk_graph,attribute_name=&quot;coordinates&quot;</span>
<span class="c1">#                                                                 ,node_list=high_degree_neigh,</span>
<span class="c1">#                                                                return_array=True)).reshape(1,2,3))</span>
                <span class="k">continue</span>

        
        
        
        
        <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">el_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">total_neighbors</span><span class="p">)</span>
        
        <span class="c1">#12/17 NO LONGER attempting to eliminate any cycles</span>
        <span class="k">if</span> <span class="n">remove_cycles</span><span class="p">:</span>
            <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_cycle</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
        
        <span class="n">branch_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">))</span>
        <span class="n">branch_skeleton_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
        
    <span class="c1">#observation: seem to be losing branches that have two high degree nodes connected to each other and no other loop around it</span>
        
    <span class="c1">#add back all of the high degree branches that form subgraphs</span>
    <span class="n">high_degree_branch_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">degree_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">seperated_branch_graph</span> <span class="o">=</span> <span class="n">el_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">high_degree_branch_nodes</span><span class="p">)</span>
    <span class="c1">#get the connected components</span>
    <span class="n">high_degree_conn_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">seperated_branch_graph</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Here is where need to make a decision about what to do with high degree nodes: </span>
<span class="sd">    I say just split all of the edges just into branches and then problem is solved (1 edge branches)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">for</span> <span class="n">c_comp</span> <span class="ow">in</span> <span class="n">high_degree_conn_comp</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_comp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#add the subgraph to the branches</span>
            <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">el_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c_comp</span><span class="p">))</span>
            <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
            <span class="c1">#and constant loop that check for cycle in this complexand if there is one then delete a random edge from the cycle</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Might have to add in more checks for more complicated high degree node complexes</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="c1">#new method that will delete any cycles might find in the branches</span>
        
            <span class="c1">#12/17 NO LONGER attempting to eliminate any cycles</span>
            <span class="k">if</span> <span class="n">remove_cycles</span><span class="p">:</span>
                <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_cycle</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
        
            <span class="n">high_degree_branch_complex</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
            <span class="n">seperated_high_degree_edges</span> <span class="o">=</span> <span class="n">split_skeleton_into_edges</span><span class="p">(</span><span class="n">high_degree_branch_complex</span><span class="p">)</span>
                    
            <span class="c1">#branch_skeletons.append(sk.convert_graph_to_skeleton(branch_subgraph)) #old way</span>
            <span class="n">branch_skeletons</span> <span class="o">+=</span> <span class="n">seperated_high_degree_edges</span>
            <span class="n">branch_skeleton_indices</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
            
            
            <span class="c1">#check if there every was a cycle: </span>
            

    <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">branch_skeletons</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#print(&quot;Testing for cycle&quot;)</span>
            <span class="n">edges_in_cycle</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">br</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was a cycle found in the branch subgraph&quot;</span><span class="p">)</span>
        
    <span class="n">branch_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_skeletons</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch_skeletons</span><span class="p">,</span><span class="n">branch_skeleton_indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch_skeletons</span></div>

<div class="viewcode-block" id="convert_branch_graph_to_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.convert_branch_graph_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">convert_branch_graph_to_skeleton</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Want an ordered skeleton that is only a line </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the ordered node coordinates</span>
<span class="sd">    2) Create an edge array like [(0,1),(1,2).... (n_nodes-1,n_nodes)]</span>
<span class="sd">    3) index the edges intot he node coordinates and return</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeleton_node_coordinates</span> <span class="o">=</span> <span class="n">get_ordered_branch_nodes_coordinates</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
    <span class="c1">#print(f&quot;skeleton_node_coordinates.shape = {skeleton_node_coordinates.shape}&quot;)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_node_coordinates</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>    </div>


<span class="c1"># def divide_branch(curr_branch_skeleton,</span>
<span class="c1">#                            segment_width):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     When wanting to divide up one branch into multiple branches that </span>
<span class="c1">#     don&#39;t exceed a certain size</span>
    
<span class="c1">#     Pseudocode: </span>
<span class="c1">#     1) Resize the skee</span>
    
<span class="c1">#     &quot;&quot;&quot;</span>

<div class="viewcode-block" id="resize_skeleton_branch"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.resize_skeleton_branch">[docs]</a><span class="k">def</span> <span class="nf">resize_skeleton_branch</span><span class="p">(</span>
                            <span class="n">curr_branch_skeleton</span><span class="p">,</span>
                           <span class="n">segment_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">n_segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">try_order_skeleton_from_original</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sk = reload(sk)</span>
<span class="sd">    cleaned_skeleton = sk.resize_skeleton_branch(curr_branch_skeleton,segment_width=1000)</span>

<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[curr_branch_mesh],</span>
<span class="sd">                              other_skeletons=[cleaned_skeleton])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">segment_width</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">n_segments</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Both segment_width and n_segments are non-positive&quot;</span><span class="p">)</span>
    
    
    <span class="c1">#curr_branch_nodes_coordinates = np.vstack([curr_branch_skeleton[:,0,:].reshape(-1,3),curr_branch_skeleton[-1,1,:].reshape(-1,3)])</span>
    <span class="c1">#print(f&quot;curr_branch_nodes_coordinates = {curr_branch_nodes_coordinates}&quot;)  </span>

    <span class="c1">#final product of this is it gets a skeleton that goes in a line from one endpoint to the other </span>
    <span class="c1">#(because skeleton can possibly be not ordered)</span>
    <span class="n">skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">)</span>
    <span class="n">skeleton_node_coordinates</span> <span class="o">=</span> <span class="n">get_ordered_branch_nodes_coordinates</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
    <span class="n">cleaned_skeleton</span> <span class="o">=</span> <span class="n">convert_branch_graph_to_skeleton</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cleaned_skeleton size = </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">cleaned_skeleton</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># #already checked that these were good                 </span>
    <span class="c1"># print(f&quot;skeleton_node_coordinates = {skeleton_node_coordinates}&quot;)</span>
    <span class="c1"># print(f&quot;cleaned_skeleton = {cleaned_skeleton}&quot;)</span>


    <span class="c1"># gets the distance markers of how far have traveled from end node for each node</span>
    <span class="n">seg_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">cleaned_skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;seg_bins= </span><span class="si">{</span><span class="n">seg_bins</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_segments</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segment_width</span> <span class="o">=</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">n_segments</span> <span class="c1">#sets the width to </span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_width = </span><span class="si">{</span><span class="n">segment_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">segment_width</span><span class="o">&gt;</span><span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1">#print(&quot;Skeletal width required was longer than the current skeleton so just returning the endpoints&quot;)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cleaned_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cleaned_skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    

    <span class="c1">#gets the distance of each segment</span>
    <span class="n">segment_widths</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">cleaned_skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_widths = </span><span class="si">{</span><span class="n">segment_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#print(f&quot;total_distance = {sk.calculate_skeleton_distance(cleaned_skeleton)}&quot;)</span>

    <span class="n">n_full_segs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">segment_width</span><span class="p">)</span>
    <span class="n">new_seg_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">segment_width</span><span class="p">,</span><span class="n">segment_width</span><span class="o">*</span><span class="n">n_full_segs</span><span class="o">+</span><span class="mf">0.000000001</span><span class="p">,</span><span class="n">segment_width</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.000001</span><span class="p">:</span>
            <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;End of new_seg_endpoints is greater than original skeleton &quot;</span><span class="p">)</span>

    <span class="c1">#accounts for the perfect fit</span>
    <span class="k">if</span> <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1">#print(&quot;exact match so eliminating last new bin&quot;)</span>
        <span class="n">new_seg_endpoints</span> <span class="o">=</span> <span class="n">new_seg_endpoints</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#remove the last one because will readd it back</span>

    <span class="c1">#print(f&quot;seg_bins = {seg_bins}&quot;)</span>
    <span class="c1">#print(f&quot;new_seg_endpoints = {new_seg_endpoints}&quot;)</span>

    <span class="c1">#getting the vertices</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3) for each new segment endpoint, </span>
<span class="sd">    a) calculate between which two existing skeleton segment end points it would exist</span>
<span class="sd">    (using just a distnace measurement from each end point to the next)</span>
<span class="sd">    b)calculate the coordinate that is a certain distance in middle based on which endpoints between</span>

<span class="sd">    new_vector * (new_seg_endpoint - lower_bin_distance)/seg_width + lower_bin_vector</span>
<span class="sd">    # &quot;&quot;&quot;</span>

    <span class="n">bin_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">new_seg_endpoints</span><span class="p">,</span> <span class="n">seg_bins</span><span class="p">)</span>
    <span class="c1">#print(f&quot;bin_indices = {bin_indices}&quot;)</span>
    <span class="c1"># print(f&quot;bin_indices = {bin_indices}&quot;)</span>
    <span class="c1"># print(f&quot;seg_bins[bin_indices-1]= {seg_bins[bin_indices-1]}&quot;)</span>
    <span class="c1"># print(f&quot;new_seg_endpoints - seg_bins[bin_indices-1] = {(new_seg_endpoints - seg_bins[bin_indices-1]).astype(&#39;int&#39;)}&quot;)</span>
    <span class="c1">#print(f&quot;skeleton_node_coordinates (SHOULD BE ORDERED) = {skeleton_node_coordinates}&quot;)</span>
    <span class="n">new_coordinates</span> <span class="o">=</span> <span class="p">(((</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="p">]</span> <span class="o">-</span> <span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                       <span class="o">*</span><span class="p">((</span><span class="n">new_seg_endpoints</span> <span class="o">-</span> <span class="n">seg_bins</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">segment_widths</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1">#print(f&quot;new_coordinates = {new_coordinates.shape}&quot;)</span>

    <span class="c1">#add on the ending coordinates</span>
    <span class="n">final_new_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">new_coordinates</span><span class="p">,</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
    <span class="c1">#print(f&quot;final_new_coordinates = {final_new_coordinates.shape}&quot;)</span>

    <span class="c1">#make a new skeleton from the coordinates</span>
    <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">final_new_coordinates</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">final_new_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_skeleton = </span><span class="si">{</span><span class="n">new_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="k">if</span> <span class="n">try_order_skeleton_from_original</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">new_skeleton</span><span class="p">,</span>
                                        <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="n">curr_branch_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                            <span class="n">error_on_non_start_coordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">new_skeleton</span></div>


<div class="viewcode-block" id="skeleton_graph_nodes_to_group"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_graph_nodes_to_group">[docs]</a><span class="k">def</span> <span class="nf">skeleton_graph_nodes_to_group</span><span class="p">(</span><span class="n">skeleton_grpah</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks that no nodes in graph are in the same coordinates and need to be combined</span>
<span class="sd">    </span>
<span class="sd">    Example Use Case: </span>
<span class="sd">    </span>
<span class="sd">    example_skeleton = current_mesh_data[0][&quot;branch_skeletons&quot;][0]</span>
<span class="sd">    skeleton_grpah = sk.convert_skeleton_to_graph(example_skeleton)</span>
<span class="sd">    limb_nodes_to_group = sk.skeleton_graph_nodes_to_group(skeleton_grpah)</span>
<span class="sd">    limb_nodes_to_group</span>

<span class="sd">    #decompose the skeleton and then recompose and see if any nodes to group</span>
<span class="sd">    decomposed_branches = sk.decompose_skeleton_to_branches(example_skeleton)</span>
<span class="sd">    decomposed_branches_stacked = sk.stack_skeletons(example_skeleton)</span>
<span class="sd">    restitched_decomposed_skeleton = sk.convert_graph_to_skeleton(sk.convert_skeleton_to_graph(decomposed_branches_stacked))</span>
<span class="sd">    sk.skeleton_graph_nodes_to_group(restitched_decomposed_skeleton)</span>

<span class="sd">    #shows that the restitched skeleton is still just one connected componet</span>
<span class="sd">    connected_components = nx.connected_components(sk.convert_skeleton_to_graph(decomposed_branches_stacked))</span>
<span class="sd">    len(list(connected_components))</span>

<span class="sd">    sk.graph_skeleton_and_mesh(other_skeletons = [restitched_decomposed_skeleton])</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">skeleton_grpah</span><span class="p">)</span>  <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()),</span><span class="nb">type</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">())]:</span>
        <span class="n">skeleton_grpah</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton_grpah</span><span class="p">)</span>
    <span class="c1">#get all of the vertices</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">skeleton_grpah</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">)</span>
    <span class="c1">#get the distances between coordinates</span>
    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">get_coordinate_distance_matrix</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    
    <span class="c1">#great a graph out of the distance matrix with a value of 0</span>
    <span class="n">nodes_to_combine</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance_matrix</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="c1">#clean graph for any self loops</span>
    <span class="n">nodes_to_combine</span>  <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">nodes_to_combine</span><span class="p">)</span>
    
    <span class="n">grouped_nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">nodes_to_combine</span><span class="p">)</span>
    <span class="n">nodes_to_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouped_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">nodes_to_group</span></div>

<div class="viewcode-block" id="recompose_skeleton_from_branches"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.recompose_skeleton_from_branches">[docs]</a><span class="k">def</span> <span class="nf">recompose_skeleton_from_branches</span><span class="p">(</span><span class="n">decomposed_branches</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes skeleton branches and stitches them back together without any repeating nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decomposed_branches_stacked</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">decomposed_branches</span><span class="p">)</span>
    <span class="n">restitched_decomposed_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">decomposed_branches_stacked</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">restitched_decomposed_skeleton</span></div>

<div class="viewcode-block" id="clean_skeleton_with_decompose"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.clean_skeleton_with_decompose">[docs]</a><span class="k">def</span> <span class="nf">clean_skeleton_with_decompose</span><span class="p">(</span><span class="n">distance_cleaned_skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to eliminate the loops that are cleaned in the decompose process from the skeleton and then reconstruct</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) decompose skeleton</span>
<span class="sd">    2) recompose skeleton (was checked that no nodes to recombine)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">distance_cleaned_skeleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">recompose_skeleton_from_branches</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span></div>

<div class="viewcode-block" id="divide_branch"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.divide_branch">[docs]</a><span class="k">def</span> <span class="nf">divide_branch</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">,</span>
                            <span class="n">segment_width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                           <span class="n">equal_width</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">n_segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When wanting to divide up one branch into multiple branches that </span>
<span class="sd">    don&#39;t exceed a certain size</span>

<span class="sd">    Example of how to use: </span>
<span class="sd">    </span>
<span class="sd">    sk = reload(sk)</span>

<span class="sd">    curr_index = 1</span>
<span class="sd">    ex_branch = total_branch_skeletons[curr_index]</span>
<span class="sd">    ex_mesh = total_branch_meshes[curr_index]</span>
<span class="sd">    # sk.graph_skeleton_and_mesh(other_skeletons=[ex_branch],</span>
<span class="sd">    #                           other_meshes=[ex_mesh])</span>



<span class="sd">    #there were empty arrays which is causing the error!</span>
<span class="sd">    returned_branches = sk.divide_branch(curr_branch_skeleton=ex_branch,</span>
<span class="sd">                                segment_width = 1000,</span>
<span class="sd">                                equal_width=False,</span>
<span class="sd">                                n_segments = 0)</span>

<span class="sd">    print(len(returned_branches))</span>
<span class="sd">    lengths = [sk.calculate_skeleton_distance(k) for k in returned_branches]</span>
<span class="sd">    print(f&quot;lengths = {lengths}&quot;)</span>


<span class="sd">    sk.graph_skeleton_and_mesh(</span>
<span class="sd">                                other_skeletons=returned_branches[:10],</span>
<span class="sd">                            other_skeletons_colors=[&quot;black&quot;],</span>
<span class="sd">                              #other_skeletons=[ex_branch],</span>
<span class="sd">                              other_meshes=[ex_mesh])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">segment_width</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">n_segments</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Both segment_width and n_segments are non-positive&quot;</span><span class="p">)</span>

    <span class="n">skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">)</span>
    <span class="n">skeleton_node_coordinates</span> <span class="o">=</span> <span class="n">get_ordered_branch_nodes_coordinates</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
    <span class="n">cleaned_skeleton</span> <span class="o">=</span> <span class="n">convert_branch_graph_to_skeleton</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>

    <span class="n">seg_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">cleaned_skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>



    <span class="k">if</span> <span class="n">n_segments</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segment_width</span> <span class="o">=</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">n_segments</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">segment_width</span><span class="o">&gt;</span><span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1">#print(&quot;Skeletal width required was longer than the current skeleton so just returning the endpoints&quot;)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cleaned_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cleaned_skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>


    <span class="n">segment_widths</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">cleaned_skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#print(f&quot;total_distance = {sk.calculate_skeleton_distance(cleaned_skeleton)}&quot;)</span>

    <span class="k">if</span> <span class="n">equal_width</span> <span class="ow">and</span> <span class="n">n_segments</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(&quot;making all of the branch segments equal width&quot;)</span>
        <span class="n">n_segments_that_fit</span> <span class="o">=</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">segment_width</span>
        <span class="c1">#print(f&quot;n_segments_that_fit = {n_segments_that_fit}&quot;)</span>
        <span class="k">if</span> <span class="n">n_segments_that_fit</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_segments_that_fit</span><span class="p">):</span> <span class="c1">#if there is some leftover </span>
            <span class="n">segment_width</span> <span class="o">=</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_segments_that_fit</span><span class="p">)</span>
            <span class="c1">#print(f&quot;New segment width in order to make them equal = {segment_width}\n&quot;)</span>

    <span class="n">n_full_segs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">segment_width</span><span class="p">)</span>
    <span class="c1">#print(f&quot;n_full_segs = {n_full_segs}&quot;)</span>

    <span class="c1">#old way</span>
    <span class="n">new_seg_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">segment_width</span><span class="p">,</span><span class="n">segment_width</span><span class="o">*</span><span class="n">n_full_segs</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span><span class="n">segment_width</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;new_seg_endpoints[-1] - seg_bins[-1] = {new_seg_endpoints[-1] - seg_bins[-1]}&quot;)</span>
    <span class="k">if</span> <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;End of new_seg_endpoints is greater than original skeleton &quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1">#accounts for the perfect fit</span>
    <span class="k">if</span> <span class="n">new_seg_endpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">seg_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1">#print(&quot;exact match so eliminating last new bin&quot;)</span>
        <span class="n">new_seg_endpoints</span> <span class="o">=</span> <span class="n">new_seg_endpoints</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#remove the last one because will readd it back</span>

    <span class="c1">#print(f&quot;seg_bins = {seg_bins}&quot;)</span>
    <span class="c1">#print(f&quot;new_seg_endpoints = {new_seg_endpoints}&quot;)</span>

    <span class="c1">#getting the vertices</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3) for each new segment endpoint, </span>
<span class="sd">    a) calculate between which two existing skeleton segment end points it would exist</span>
<span class="sd">    (using just a distnace measurement from each end point to the next)</span>
<span class="sd">    b)calculate the coordinate that is a certain distance in middle based on which endpoints between</span>

<span class="sd">    new_vector * (new_seg_endpoint - lower_bin_distance)/seg_width + lower_bin_vector</span>
<span class="sd">    # &quot;&quot;&quot;</span>

    <span class="n">bin_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">new_seg_endpoints</span><span class="p">,</span> <span class="n">seg_bins</span><span class="p">)</span>

    <span class="n">new_coordinates</span> <span class="o">=</span> <span class="p">(((</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="p">]</span> <span class="o">-</span> <span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                       <span class="o">*</span><span class="p">((</span><span class="n">new_seg_endpoints</span> <span class="o">-</span> <span class="n">seg_bins</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">segment_widths</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1">#these should be the same size</span>
    <span class="c1">#     print(f&quot;bin_indices = {bin_indices}&quot;)</span>
    <span class="c1">#     print(f&quot;new_coordinates = {new_coordinates}&quot;)</span>
    <span class="c1">#     return bin_indices,new_coordinates</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Using the bin_indices and new_coordinates construct a list of branches with the original vertices plus the new cuts</span>
<span class="sd">    Pseudocode:</span>

<span class="sd">    indices mean that they are greater than or equal to the bin below but absolutely less than the bin indices value</span>
<span class="sd">    --&gt; need to make sure that the new cut does not fall on current cut</span>
<span class="sd">    --&gt; do this by checking that the last node before the cut isn&#39;t equal to the cut</span>

<span class="sd">    1) include all of the skeleton points but not including the bin idexed numer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">returned_branches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skeleton_node_coordinates</span> <span class="c1">#these are the original coordinates</span>
    <span class="k">for</span> <span class="n">z</span><span class="p">,(</span><span class="n">curr_bin</span><span class="p">,</span><span class="n">new_c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bin_indices</span><span class="p">,</span><span class="n">new_coordinates</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
<span class="c1">#             print(f&quot;curr_bin = {curr_bin}&quot;)</span>
<span class="c1">#             print(f&quot;bin_indices = {bin_indices}&quot;)</span>
            
            <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">skeleton_node_coordinates</span><span class="p">[:</span><span class="n">curr_bin</span><span class="p">]</span>
<span class="c1">#             print(f&quot;previous_nodes = {previous_nodes}&quot;)</span>
<span class="c1">#             print(f&quot;previous_nodes[-1] = {previous_nodes[-1]}&quot;)</span>
<span class="c1">#             print(f&quot;new_c = {new_c}&quot;)</span>
<span class="c1">#             print(f&quot;np.linalg.norm(previous_nodes[:-1]- new_c) = {np.linalg.norm(previous_nodes[-1]- new_c)}&quot;)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">previous_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span> <span class="n">new_c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span>
                <span class="c1">#print(&quot;inside linalg_norm&quot;)</span>
                <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">previous_nodes</span><span class="p">,</span><span class="n">new_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
            
            <span class="c1">#print(f&quot;previous_nodes = {previous_nodes}&quot;)</span>
            <span class="c1">#now create the branch</span>
            <span class="n">returned_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">previous_nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">previous_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="c1">#print(f&quot;returned_branches = {returned_branches}&quot;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if this was not the first branch</span>
            <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">new_coordinates</span><span class="p">[</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_bin</span> <span class="o">&gt;</span> <span class="n">bin_indices</span><span class="p">[</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">previous_nodes</span><span class="p">,</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="p">[</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">curr_bin</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">previous_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span> <span class="n">new_c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span>
                <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">previous_nodes</span><span class="p">,</span><span class="n">new_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

            <span class="n">returned_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">previous_nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">previous_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>


    <span class="c1">#     if np.array_equal(returned_branches[-1],np.array([], dtype=&quot;float64&quot;).reshape(-1,2,3)):</span>
    <span class="c1">#         print(f&quot;previous_nodes= {previous_nodes}&quot;)</span>
    <span class="c1">#         print(f&quot;new_c = {new_c}&quot;)</span>
    <span class="c1">#         print(f&quot;curr_bin = {curr_bin}&quot;)</span>
    <span class="c1">#         print(f&quot;bin_indices = {bin_indices}&quot;)</span>
    <span class="c1">#         print(f&quot;z = {z}&quot;)</span>
    <span class="c1">#         raise Exception(&quot;stopping&quot;)</span>

    <span class="c1">#add this last section to the skeleton</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_c</span> <span class="o">-</span> <span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span> <span class="c1">#so the last node has not been added yet</span>
        <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">new_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_bins</span><span class="p">):</span>
            <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">previous_nodes</span><span class="p">,</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="n">bin_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_node_coordinates</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">previous_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">previous_nodes</span><span class="p">,</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
        <span class="n">returned_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">previous_nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">previous_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="c1">#check 1: that the first and last of original branch is the same as the decomposed</span>
    <span class="n">first_coord</span> <span class="o">=</span> <span class="n">returned_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_coord</span> <span class="o">=</span> <span class="n">returned_branches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
<span class="c1">#     print(f&quot;first original coord = {skeleton_node_coordinates[0]}&quot;)</span>
<span class="c1">#     print(f&quot;last original coord = {skeleton_node_coordinates[-1]}&quot;)</span>
<span class="c1">#     print(f&quot;first_coord = {first_coord}&quot;)</span>
<span class="c1">#     print(f&quot;last_coord = {last_coord}&quot;)</span>
    
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">first_coord</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_node_coordinates = </span><span class="si">{</span><span class="n">skeleton_node_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;first_coord = </span><span class="si">{</span><span class="n">first_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;First coordinate does not match&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">skeleton_node_coordinates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">last_coord</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_node_coordinates = </span><span class="si">{</span><span class="n">skeleton_node_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;last_coord = </span><span class="si">{</span><span class="n">last_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Last coordinate does not match&quot;</span><span class="p">)</span>

    
    <span class="c1">#check 2: that it is all one connected branch</span>
    <span class="n">total_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">returned_branches</span><span class="p">)</span>
    <span class="n">total_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">total_skeleton</span><span class="p">)</span>
    <span class="n">n_comps</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">total_skeleton_graph</span><span class="p">)</span>
    
    
    <span class="c1">#print(f&quot;Number of connected components is {n_comps}&quot;)</span>
    
    <span class="k">if</span> <span class="n">n_comps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of connected components is </span><span class="si">{</span><span class="n">n_comps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of returning branches = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">returned_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">returned_branches</span></div>

<span class="c1"># -------- for the mesh correspondence -------</span>
<span class="c1"># def waterfill_labeling(</span>
<span class="c1">#                 total_mesh_correspondence,</span>
<span class="c1">#                  submesh_indices,</span>
<span class="c1">#                  total_mesh=None,</span>
<span class="c1">#                 total_mesh_graph=None,</span>
<span class="c1">#                  propagation_type=&quot;random&quot;,</span>
<span class="c1">#                 max_iterations = 1000,</span>
<span class="c1">#                 max_submesh_threshold = 1000</span>
<span class="c1">#                 ):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Pseudocode:</span>
<span class="c1">#     1) check if the submesh you are propagating labels to is too large</span>
<span class="c1">#     2) for each unmarked face get the neighbors of all of the faces, and for all these neighbors get all the labels</span>
<span class="c1">#     3) if the neighbors label is not empty. depending on the type of progation type then pick the winning label</span>
<span class="c1">#     a. random: just randomly choose from list</span>
<span class="c1">#     b. .... not yet implemented</span>
<span class="c1">#     4) revise the faces that are still empty and repeat process until all faces are empty (have a max iterations number)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
    
<span class="c1">#     if not total_mesh_graph:</span>
<span class="c1">#         #finding the face adjacency:</span>
<span class="c1">#         total_mesh_graph = nx.from_edgelist(total_mesh.face_adjacency)</span>
    
    
    
<span class="c1">#     if len(submesh_indices)&gt; max_submesh_threshold:</span>
<span class="c1">#         raise Exception(f&quot;The len of the submesh ({len(submesh_indices)}) exceeds the maximum threshold of {max_submesh_threshold} &quot;)</span>
    
<span class="c1">#     #check that these are unmarked</span>
<span class="c1">#     curr_unmarked_faces = [k for k in submesh_indices if total_mesh_correspondence[k] == -1] </span>
    
    
<span class="c1">#     if len(curr_unmarked_faces)&lt;len(submesh_indices):</span>
<span class="c1">#         raise Exception(f&quot;{len(submesh_indices)-len(curr_unmarked_faces)} submesh faces were already labeled before waterfill_labeling started&quot;)</span>
    
<span class="c1">#     for i in range(max_iterations):</span>
<span class="c1">#         #s2) for each unmarked face get the neighbors of all of the faces, and for all these neighbors get all the labels</span>
<span class="c1">#         unmarked_faces_neighbors = [xu.get_neighbors(total_mesh_graph,j) for j in curr_unmarked_faces] #will be list of lists</span>
<span class="c1">#         #print(f&quot;unmarked_faces_neighbors = {unmarked_faces_neighbors}&quot;)</span>
<span class="c1">#         unmarked_face_neighbor_labels = [np.array([total_mesh_correspondence[curr_neighbor] for curr_neighbor in z]) for z in unmarked_faces_neighbors]</span>
<span class="c1">#         #print(f&quot;unmarked_face_neighbor_labels = {unmarked_face_neighbor_labels}&quot;)</span>
        
<span class="c1">#         if len(unmarked_face_neighbor_labels) == 0:</span>
<span class="c1">#             print(f&quot;curr_unmarked_faces = {curr_unmarked_faces}&quot;)</span>
<span class="c1">#             print(f&quot;i = {i}&quot;)</span>
<span class="c1">#             print(f&quot;unmarked_faces_neighbors = {unmarked_faces_neighbors}&quot;)</span>
<span class="c1">#             print(f&quot;unmarked_face_neighbor_labels = {unmarked_face_neighbor_labels}&quot;)</span>
            
<span class="c1">#         #check if there is only one type of label and if so then autofil</span>
<span class="c1">#         total_labels = list(np.unique(np.concatenate(unmarked_face_neighbor_labels)))</span>
        
<span class="c1">#         if -1 in total_labels:</span>
<span class="c1">#             total_labels.remove(-1)</span>
        
<span class="c1">#         if len(total_labels) == 0:</span>
<span class="c1">#             raise Exception(&quot;total labels does not have any marked neighbors&quot;)</span>
<span class="c1">#         elif len(total_labels) == 1:</span>
<span class="c1">#             print(&quot;All surrounding labels are the same so autofilling the remainder of unlabeled labels&quot;)</span>
<span class="c1">#             for gg in curr_unmarked_faces:</span>
<span class="c1">#                 total_mesh_correspondence[gg] = total_labels[0]</span>
<span class="c1">#             break</span>
<span class="c1">#         else:</span>
<span class="c1">#             #if there are still one or more labels surrounding our unlabeled region</span>
<span class="c1">#             for curr_face,curr_neighbors in zip(curr_unmarked_faces,unmarked_face_neighbor_labels):</span>
<span class="c1">#                 curr_neighbors = curr_neighbors[curr_neighbors != -1]</span>
<span class="c1">#                 if len(curr_neighbors) &gt; 0:</span>
<span class="c1">#                     if propagation_type == &quot;random&quot;:</span>
<span class="c1">#                         total_mesh_correspondence[curr_face] = np.random.choice(curr_neighbors)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         raise Exception(&quot;Not implemented propagation_type&quot;)</span>
        
<span class="c1">#         # now replace the new curr_unmarked faces</span>
<span class="c1">#         curr_unmarked_faces = [k for k in submesh_indices if total_mesh_correspondence[k] == -1] #old dict way</span>
        
        
<span class="c1">#         if len(curr_unmarked_faces) == 0:</span>
<span class="c1">#             print(f&quot;breaking out of loop because zero unmarked faces left after {i} iterations&quot;)</span>
<span class="c1">#             break</span>
        
    
<span class="c1">#     #check that no more unmarked faces or error</span>
<span class="c1">#     end_unmarked_faces = [k for k in submesh_indices if total_mesh_correspondence[k] == -1]</span>
    
<span class="c1">#     if len(end_unmarked_faces) &gt; 0:</span>
<span class="c1">#         raise Exception(f&quot;After {i+1} iterations (with max_iterations = {max_iterations} there were still {len(end_unmarked_faces)} faces&quot;)</span>
        
    
<span class="c1">#     return total_mesh_correspondence</span>


<span class="c1"># ----- functions to help with the Neuron class ---- #</span>
<div class="viewcode-block" id="find_branch_endpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.find_branch_endpoints">[docs]</a><span class="k">def</span> <span class="nf">find_branch_endpoints</span><span class="p">(</span><span class="n">db</span><span class="p">,</span><span class="n">order_by_coordinate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">db_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="n">end_node_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">db_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">db_graph</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_node_coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not exactly 2 end nodes in the passed branch&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">order_by_coordinate</span><span class="p">:</span>
            <span class="n">end_node_coordinates</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span>
                <span class="n">end_node_coordinates</span><span class="p">,</span>
                <span class="n">descending</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">end_node_coordinates</span></div>
    
<div class="viewcode-block" id="compare_skeletons_ordered"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.compare_skeletons_ordered">[docs]</a><span class="k">def</span> <span class="nf">compare_skeletons_ordered</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">,</span><span class="n">skeleton_2</span><span class="p">,</span>
                             <span class="n">edge_threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="c1">#how much the edge distances can vary by</span>
                              <span class="n">node_threshold</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="c1">#how much the nodes can vary by</span>
                              <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span>
                             <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compare skeletons where the edges are ordered (not comparing overall skeletons)</span>
<span class="sd">    Those would be isomorphic graphs (not yet developed)</span>
<span class="sd">    </span>
<span class="sd">    Example of how to use: </span>
<span class="sd">    skeletons_idx_to_stack = [0,1,2,3]</span>
<span class="sd">    total_skeleton = sk.stack_skeletons([double_soma_obj.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;].concept_network.nodes[k][&quot;data&quot;].skeleton for k in skeletons_idx_to_stack])</span>
<span class="sd">    #sk.graph_skeleton_and_mesh(other_skeletons=[total_skeleton])</span>
<span class="sd">    </span>
<span class="sd">    skeleton_1 = copy.copy(total_skeleton)</span>
<span class="sd">    skeleton_2 = copy.copy(total_skeleton)</span>
<span class="sd">    skeleton_1[0][0] = np.array([558916.8, 1122107. ,  842972.8]) #change so there will be error</span>
<span class="sd">    </span>
<span class="sd">    sk.compare_skeletons_ordered(skeleton_1,</span>
<span class="sd">                          skeleton_2,</span>
<span class="sd">                             edge_threshold=0.01, #how much the edge distances can vary by</span>
<span class="sd">                              node_threshold = 0.01, #how much the nodes can vary by</span>
<span class="sd">                              print_flag = True</span>
<span class="sd">                             )</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_1_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">)</span>
    <span class="n">sk_2_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_networks</span><span class="p">(</span><span class="n">sk_1_graph</span><span class="p">,</span><span class="n">sk_2_graph</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                     <span class="n">edge_comparison_threshold</span><span class="o">=</span><span class="n">edge_threshold</span><span class="p">,</span>
                     <span class="n">node_comparison_threshold</span><span class="o">=</span><span class="n">node_threshold</span><span class="p">)</span></div>
    
    
<span class="c1"># ----------------- 7/22 Functions made to help with graph searching and visualizaiton ------------ #</span>
<div class="viewcode-block" id="skeleton_n_components"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_n_components">[docs]</a><span class="k">def</span> <span class="nf">skeleton_n_components</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the number of connected components represented by </span>
<span class="sd">    the current skeleton</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cleaned_branch_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cleaned_branch_components</span></div>

<div class="viewcode-block" id="check_skeleton_one_component"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.check_skeleton_one_component">[docs]</a><span class="k">def</span> <span class="nf">check_skeleton_one_component</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">):</span>
    <span class="n">cleaned_branch_components</span> <span class="o">=</span> <span class="n">skeleton_n_components</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cleaned_branch_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skeleton is not one component: n_components = </span><span class="si">{</span><span class="n">cleaned_branch_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    

<span class="c1"># ---------------- 9/17: Will help with creating branch points extending towards soma if not already exist ---</span>

<div class="viewcode-block" id="create_soma_extending_branches"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.create_soma_extending_branches">[docs]</a><span class="k">def</span> <span class="nf">create_soma_extending_branches</span><span class="p">(</span>
    <span class="n">current_skeleton</span><span class="p">,</span> <span class="c1">#current skeleton that was created</span>
    <span class="n">skeleton_mesh</span><span class="p">,</span> <span class="c1">#mesh that was skeletonized</span>
    <span class="n">soma_to_piece_touching_vertices</span><span class="p">,</span><span class="c1">#dictionary mapping a soma it is touching to the border vertices,</span>
    <span class="n">return_endpoints_must_keep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_created_branch_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">try_moving_to_closest_sk_to_endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#will try to move the closest skeleton point to an endpoint</span>
    <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span> <span class="c1">#maximum distance willling to move closest skeleton point to get to an endpoint</span>
    <span class="n">check_connected_skeleton</span><span class="o">=</span><span class="kc">True</span>
                                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To make sure there is one singular branch extending towards the soma</span>
<span class="sd">    </span>
<span class="sd">    Return value:</span>
<span class="sd">    endpoints_must_keep: dict mapping soma to array of the vertex points that must be kept</span>
<span class="sd">    because they are the soma extending branches of the skeleton</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterating through all of the somas and all of the groups of touching vertices</span>
<span class="sd">    a) project the skeleton and the soma boundary vertices on to the vertices of the mesh</span>
<span class="sd">    b) Find the closest skeleton point to the soma boundary vetices</span>
<span class="sd">    c) check the degree of the closest skeleton point:</span>
<span class="sd">    - if it is a degree one then leave alone</span>
<span class="sd">    - if it is not a degree one then create a new skeleton branch from the </span>
<span class="sd">    closest skeleton point and the average fo the border vertices and add to </span>
<span class="sd">    </span>
<span class="sd">    Extension: (this is the same method that would be used for adding on a floating skeletal piece)</span>
<span class="sd">    If we made a new skeleton branch then could pass back the closest skeleton point coordinates</span>
<span class="sd">    and the new skeleton segment so we could:</span>
<span class="sd">    1) Find the branch that it was added to </span>
<span class="sd">    2) Divide up the mesh correspondnece between the new resultant branches</span>
<span class="sd">    -- would then still reuse the old mesh correspondence</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">new_branches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="c1">#0) Create a graph of the mesh from the vertices and edges and a KDTree</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">vertex_graph</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_vertex_graph</span><span class="p">(</span><span class="n">skeleton_mesh</span><span class="p">)</span>
    <span class="n">mesh_KD</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">skeleton_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh KDTree = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">s_index</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_branches</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sbv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>


            <span class="c1">#1)  Project all skeleton points and soma boundary vertices onto the mesh</span>
            <span class="n">all_skeleton_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">current_skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sk_points_distances</span><span class="p">,</span><span class="n">sk_points_closest_nodes</span> <span class="o">=</span> <span class="n">mesh_KD</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">all_skeleton_points</span><span class="p">)</span>

            <span class="c1">#sbv = soma_to_piece_touching_vertices[s_index]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sbv[0].reshape(-1,3) = </span><span class="si">{</span><span class="n">sbv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">soma_border_distances</span><span class="p">,</span><span class="n">soma_border_closest_nodes</span> <span class="o">=</span> <span class="n">mesh_KD</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sbv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="w">            </span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; old way that relied on soley paths on the mesh graph</span>
<span class="sd">            start_time = time.time()</span>
<span class="sd">            #2) Find the closest skeleton point to the soma border (for that soma), find shortest path from many to many</span>
<span class="sd">            path,closest_sk_point,closest_soma_border_point = xu.shortest_path_between_two_sets_of_nodes(vertex_graph,sk_points_closest_nodes,soma_border_closest_nodes)</span>
<span class="sd">            print(f&quot;Shortest path between 2 nodes = {time.time() - start_time}&quot;)</span>

<span class="sd">            #3) Find closest skeleton point</span>
<span class="sd">            closest_sk_pt = np.where(sk_points_closest_nodes==closest_sk_point)[0][0]</span>
<span class="sd">            closest_sk_pt_coord = all_skeleton_points[closest_sk_pt]</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;New Method 10/27</span>
<span class="sd">            1) applies a mesh filter for only those within a certian distance along mesh graph (filter)</span>
<span class="sd">            2) Of filtered vertices, finds one closest to soma border average</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">curr_cut_distane</span> <span class="o">=</span> <span class="mi">10000</span>
            
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
                <span class="n">close_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span><span class="n">vertex_graph</span><span class="p">,</span><span class="n">target_node</span><span class="o">=</span><span class="n">soma_border_closest_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cutoff_distance</span><span class="o">=</span><span class="n">curr_cut_distane</span><span class="p">)</span>
                <span class="n">filter_1_skeleton_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk_pt</span> <span class="k">for</span> <span class="n">sk_pt</span><span class="p">,</span><span class="n">sk_pt_node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_skeleton_points</span><span class="p">,</span><span class="n">sk_points_closest_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">sk_pt_node</span> <span class="ow">in</span> <span class="n">close_nodes</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter_1_skeleton_points</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;On iteration </span><span class="si">{</span><span class="n">kk</span><span class="si">}</span><span class="s2"> the filter points were empty with close_nodes len = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">close_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">, len(all_skeleton_points) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_skeleton_points</span><span class="p">)</span><span class="si">}</span><span class="s2">, len(sk_points_closest_nodes) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sk_points_closest_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">curr_cut_distane</span> <span class="o">=</span> <span class="n">curr_cut_distane</span><span class="o">*</span><span class="mi">3</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter_1_skeleton_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Still No filter nodes with curr_cut_distane = </span><span class="si">{</span><span class="n">curr_cut_distane</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                
            

            <span class="n">border_average_coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sbv</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">closest_sk_point_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">filter_1_skeleton_points</span><span class="o">-</span><span class="n">border_average_coordinate</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">closest_sk_pt_coord</span> <span class="o">=</span> <span class="n">filter_1_skeleton_points</span><span class="p">[</span><span class="n">closest_sk_point_idx</span><span class="p">]</span>
            
            
            
            <span class="n">sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>
            
            <span class="n">distance_to_move_point_threshold</span>
            <span class="k">if</span> <span class="n">try_moving_to_closest_sk_to_endpoint</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_sk_pt_coord BEFORE = </span><span class="si">{</span><span class="n">closest_sk_pt_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_skeleton.shape = </span><span class="si">{</span><span class="n">current_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">closest_sk_pt_coord</span><span class="p">,</span><span class="n">change_status</span> <span class="o">=</span> <span class="n">move_point_to_nearest_branch_end_point_within_threshold</span><span class="p">(</span>
                                                        <span class="n">skeleton</span><span class="o">=</span><span class="n">current_skeleton</span><span class="p">,</span>
                                                        <span class="n">coordinate</span><span class="o">=</span><span class="n">closest_sk_pt_coord</span><span class="p">,</span>
                                                        <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="n">distance_to_move_point_threshold</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">consider_high_degree_nodes</span><span class="o">=</span><span class="kc">False</span>

                                                        <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;change_status for create soma extending pieces = </span><span class="si">{</span><span class="n">change_status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_sk_pt_coord AFTER = </span><span class="si">{</span><span class="n">closest_sk_pt_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1">#find the node that has the desired vertices and its&#39; degree</span>
            <span class="n">sk_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">closest_sk_pt_coord</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sk_node_degree</span> <span class="o">=</span> <span class="n">sk_graph</span><span class="o">.</span><span class="n">degree</span><span class="p">()[</span><span class="n">sk_node</span><span class="p">]</span>
    

            <span class="k">if</span> <span class="n">sk_node_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Found 0 degree node in skeleton&quot;</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">sk_node_degree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#3a) If it is a node of degree 1 --&gt; do nothing</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skipping soma </span><span class="si">{</span><span class="n">s_index</span><span class="si">}</span><span class="s2"> because closest skeleton node was already end node&quot;</span><span class="p">)</span>
                <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_sk_pt_coord</span><span class="p">)</span>
                <span class="n">new_branches</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#3b) If Not endpoint:</span>
                <span class="c1">#Add an edge from the closest skeleton point coordinate to vertex average of all soma boundaries</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adding new branch to skeleton&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;border_average_coordinate = </span><span class="si">{</span><span class="n">border_average_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">new_branch_sk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">closest_sk_pt_coord</span><span class="p">,</span><span class="n">border_average_coordinate</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">current_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">current_skeleton</span><span class="p">,</span><span class="n">new_branch_sk</span><span class="p">])</span>
                <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">border_average_coordinate</span><span class="p">)</span>
                
                <span class="c1">#will store the newly added branch and the corresponding border vertices</span>
                <span class="n">new_branches</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">new_branch</span> <span class="o">=</span> <span class="n">new_branch_sk</span><span class="p">,</span><span class="n">border_verts</span><span class="o">=</span><span class="n">sbv</span><span class="p">))</span>
                
        <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">s_index</span><span class="p">])</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints_must_keep = </span><span class="si">{</span><span class="n">endpoints_must_keep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#check if skeleton is connected component when finishes</span>
    <span class="k">if</span> <span class="n">check_connected_skeleton</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">,</span><span class="s2">&quot;current_skeleton&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The skeleton at end wasn&#39;t a connected component&quot;</span><span class="p">)</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_skeleton</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_endpoints_must_keep</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endpoints_must_keep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_created_branch_info</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_branches</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="find_branch_skeleton_with_specific_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.find_branch_skeleton_with_specific_coordinate">[docs]</a><span class="k">def</span> <span class="nf">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="p">,</span><span class="n">current_coordinate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: From list of skeletons find the ones that have a certain coordinate</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    curr_limb = current_neuron[0]</span>
<span class="sd">    branch_names = curr_limb.get_branch_names(return_int=True)</span>
<span class="sd">    curr_limb_divided_skeletons = [curr_limb[k].skeleton for k in branch_names]</span>
<span class="sd">    ideal_starting_endpoint = curr_limb.current_starting_coordinate</span>
<span class="sd">    </span>
<span class="sd">    sk = reload(sk)</span>
<span class="sd">    sk.find_branch_skeleton_with_specific_coordinate(curr_limb_divided_skeletons,ideal_starting_endpoint)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matching_branch</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b_idx</span><span class="p">,</span><span class="n">b_sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="p">):</span>
        <span class="n">match_result</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">b_sk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">current_coordinate</span><span class="p">)</span>
        <span class="c1">#print(f&quot;match_result = {match_result}&quot;)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_result</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">matching_branch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_idx</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">matching_branch</span></div>

<span class="c1">#----------- 9/24 -------------- #</span>
<div class="viewcode-block" id="find_skeleton_endpoint_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.find_skeleton_endpoint_coordinates">[docs]</a><span class="k">def</span> <span class="nf">find_skeleton_endpoint_coordinates</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">coordinates_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the endpoint coordinates </span>
<span class="sd">    of a skeleton</span>
<span class="sd">    </span>
<span class="sd">    Application: </span>
<span class="sd">    1) Can get the endpoints of a skeleton and </span>
<span class="sd">    then check that none of the spines contain </span>
<span class="sd">    an endpoint coordinate to help </span>
<span class="sd">    guard against false spines at the endpoints</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) convert the skeleton to a graph</span>
<span class="sd">    2) Find the endpoint nodes of the graph (with degree 1)</span>
<span class="sd">    3) return the coordinates of the graph nodes</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">endpoint_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">#print(f&quot;endpoint_nodes = {endpoint_nodes}&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoint_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">endpoint_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">endpoint_nodes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">coordinates_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">endpoint_coordinates</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoint_coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates_to_exclude</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">main_skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">endpoint_coordinates</span><span class="p">],</span>
            <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">endpoint_coordinates</span></div>


<div class="viewcode-block" id="path_ordered_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.path_ordered_skeleton">[docs]</a><span class="k">def</span> <span class="nf">path_ordered_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To order the edges in sequential order in</span>
<span class="sd">    a skeleton so skeleton[0] is one end edge</span>
<span class="sd">    and skeleton[-1] is the other end edge</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    How to order a skeleton: </span>
<span class="sd">    1) turn the skeleton into a graph</span>
<span class="sd">    2) start at an endpoint node</span>
<span class="sd">    3) output the skeleton edges for the edges of the graph until hit the other end node</span>


<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    skeleton = big_neuron[0][30].skeleton</span>
<span class="sd">    new_skeleton_ordered = path_ordered_skeleton(skeleton)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) turn the skeleton into a graph</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="c1">#2) start at an endpoint node</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">sk_node_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">target</span><span class="o">=</span><span class="n">end_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sk_node_path_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">sk_node_path</span><span class="p">)</span>

    <span class="n">ordered_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sk_node_path_coordinates</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">sk_node_path_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ordered_skeleton</span></div>

<span class="c1"># ----------- 1/6 Addition: To help and not filter away significant skeleton pieces --------- #</span>
<div class="viewcode-block" id="find_end_nodes_with_significant_mesh_correspondence"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.find_end_nodes_with_significant_mesh_correspondence">[docs]</a><span class="k">def</span> <span class="nf">find_end_nodes_with_significant_mesh_correspondence</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">mesh_threshold</span> <span class="o">=</span> <span class="mi">275</span><span class="p">,</span>
    <span class="n">skeleton_considered_min</span> <span class="o">=</span> <span class="mi">1600</span><span class="p">,</span>
    <span class="n">skeleton_considered_max</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">,</span>
    <span class="n">plot_viable_endpoint_correspondences</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_keep_endpoints</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>


    <span class="n">current_skeleton</span> <span class="o">=</span> <span class="n">skeleton</span>
    <span class="n">keep_node_coordinates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
        

    <span class="c1">#1) Turn the skeleton into a graph</span>
    <span class="n">sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>

    <span class="c1">#2) Get all of the end nodes</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#3) Get all of the high degree nodes in the graph</span>
    <span class="n">high_degree_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_greater_or_equal_degree_k</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checking that this went well:</span>

<span class="sd">    endnode_coordinates = xu.get_coordinate_by_graph_node(sk_graph,end_nodes)</span>
<span class="sd">    high_degree_coordinates = xu.get_coordinate_by_graph_node(sk_graph,high_degree_nodes)</span>

<span class="sd">    ipvu.plot_objects(mesh,</span>
<span class="sd">                     skeletons=[current_skeleton],</span>
<span class="sd">                     scatters=[endnode_coordinates,high_degree_coordinates],</span>
<span class="sd">                     scatters_colors=[&quot;red&quot;,&quot;blue&quot;],</span>
<span class="sd">                     scatter_size=1)</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_degree_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">viable_end_node</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">viable_end_node_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">viable_end_node_skeletons_len</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">e_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">):</span>

            <span class="c1">#a. Find the path to the nearest high degree node</span>
            <span class="n">curr_path</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,[</span><span class="n">e_node</span><span class="p">],</span><span class="n">high_degree_nodes</span><span class="p">)</span>

            <span class="c1">#b. Get the skeleton of that subgraph</span>
            <span class="n">subskeleton_graph</span> <span class="o">=</span> <span class="n">sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>
            <span class="n">end_node_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">subskeleton_graph</span><span class="p">)</span>

            <span class="c1">#c. If length of that skeleton is within a certain range:</span>
            <span class="n">end_node_skeleton_len</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">end_node_skeleton</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end_node_skeleton_len</span> <span class="o">&lt;=</span> <span class="n">skeleton_considered_max</span> <span class="ow">and</span> <span class="n">end_node_skeleton_len</span> <span class="o">&gt;=</span> <span class="n">skeleton_considered_min</span><span class="p">:</span>
                <span class="n">viable_end_node</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_node</span><span class="p">)</span>
                <span class="n">viable_end_node_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_node_skeleton</span><span class="p">)</span>
                <span class="n">viable_end_node_skeletons_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_node_skeleton_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">th endnode (</span><span class="si">{</span><span class="n">e_node</span><span class="si">}</span><span class="s2">) was not checked because length was </span><span class="si">{</span><span class="n">end_node_skeleton_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checking viable paths were made:</span>

<span class="sd">        ipvu.plot_objects(mesh,</span>
<span class="sd">                         skeletons=viable_end_node_skeletons,</span>
<span class="sd">                         scatters=[endnode_coordinates,high_degree_coordinates],</span>
<span class="sd">                         scatters_colors=[&quot;red&quot;,&quot;blue&quot;],</span>
<span class="sd">                         scatter_size=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_end_node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">viable_skeleton_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">skeleton_to_mesh_correspondence</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
                                                            <span class="n">skeletons</span> <span class="o">=</span> <span class="n">viable_end_node_skeletons</span><span class="p">,</span>
                                                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                               <span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_viable_endpoint_correspondences</span><span class="p">:</span>
                <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">viable_skeleton_meshes</span><span class="p">,</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                          <span class="n">skeletons</span><span class="o">=</span><span class="n">viable_end_node_skeletons</span><span class="p">,</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">)</span>



            <span class="n">mesh_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">viable_skeleton_meshes</span><span class="p">])</span>
            <span class="n">viable_end_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">viable_end_node</span><span class="p">)</span>

            <span class="n">viable_end_node_final</span> <span class="o">=</span> <span class="n">viable_end_node</span><span class="p">[</span><span class="n">mesh_lengths</span> <span class="o">&gt;</span> <span class="n">mesh_threshold</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final end nodes to keep = </span><span class="si">{</span><span class="n">viable_end_node_final</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_end_node_final</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">keep_node_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">viable_end_node_final</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot_keep_endpoints</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_node_coordinates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!!! NO KEEP ENDPOINTS FOUND !!!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">current_skeleton</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">keep_node_coordinates</span><span class="p">],</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">keep_node_coordinates</span></div>


<span class="c1"># ---------------------- For preprocessing of neurons revised ------------------ #</span>
<div class="viewcode-block" id="skeletonize_and_clean_connected_branch_CGAL"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeletonize_and_clean_connected_branch_CGAL">[docs]</a><span class="k">def</span> <span class="nf">skeletonize_and_clean_connected_branch_CGAL</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                       <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">total_border_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">filter_end_node_length</span><span class="o">=</span><span class="mi">4001</span><span class="p">,</span>
                       <span class="n">perform_cleaning_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span>
                                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="n">remove_cycles_at_end</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                <span class="n">remove_mesh_interior_face_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">error_on_bad_cgal_return</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">max_stitch_distance</span><span class="o">=</span><span class="n">max_stitch_distance_default</span><span class="p">,</span>
                                                <span class="n">restrict_end_nodes_filtered_by_corr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a clean skeleton from a mesh</span>
<span class="sd">    (used in the neuron preprocessing package)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">branch</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
<span class="c1">#         print(f&quot;curr_soma_to_piece_touching_vertices = {curr_soma_to_piece_touching_vertices}&quot;)</span>
<span class="c1">#         print(f&quot;total_border_vertices = {total_border_vertices}&quot;)</span>
<span class="c1">#         print(f&quot;filter_end_node_length = {filter_end_node_length}&quot;)</span>
<span class="c1">#         print(f&quot;kwargs = {kwargs}&quot;)</span>
        <span class="k">pass</span>
        
    
    <span class="n">current_skeleton</span> <span class="o">=</span> <span class="n">skeletonize_connected_branch</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                    <span class="n">remove_mesh_interior_face_threshold</span><span class="o">=</span><span class="n">remove_mesh_interior_face_threshold</span><span class="p">,</span>
                                                    <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="n">error_on_bad_cgal_return</span><span class="p">,</span>
                                                    <span class="n">max_stitch_distance</span><span class="o">=</span><span class="n">max_stitch_distance</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Checking connected components after skeletonize_connected_branch&quot;</span><span class="p">)</span>
    <span class="n">check_skeleton_connected_component</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">remove_cycles_at_end</span><span class="p">:</span>
        <span class="n">current_skeleton</span> <span class="o">=</span> <span class="n">remove_cycles_from_skeleton</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>
    



<span class="c1">#                     sk_debug = True</span>
<span class="c1">#                     if sk_debug:</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#                         su.compressed_pickle(branch,</span>
<span class="c1">#                                             &quot;curr_branch_saved&quot;)</span>
<span class="c1">#                     if sk_debug:</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#                         su.compressed_pickle(current_skeleton,</span>
<span class="c1">#                                             &quot;current_skeleton&quot;)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Total time for skeletonizing branch: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clean_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Checking connected components after removing cycles&quot;</span><span class="p">)</span>
    <span class="n">check_skeleton_connected_component</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>
    

    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">current_skeleton</span><span class="p">,</span> <span class="n">curr_limb_endpoints_must_keep</span> <span class="o">=</span> <span class="n">create_soma_extending_branches</span><span class="p">(</span>
                        <span class="n">current_skeleton</span><span class="o">=</span><span class="n">current_skeleton</span><span class="p">,</span> <span class="c1">#current skeleton that was created</span>
                        <span class="n">skeleton_mesh</span><span class="o">=</span><span class="n">branch</span><span class="p">,</span> <span class="c1">#mesh that was skeletonized</span>
                        <span class="n">soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">curr_soma_to_piece_touching_vertices</span><span class="p">,</span><span class="c1">#dictionary mapping a soma it is touching to the border vertices,</span>
                        <span class="n">return_endpoints_must_keep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not Creating soma extending branches because curr_soma_to_piece_touching_vertices is None&quot;</span><span class="p">)</span>
        <span class="n">curr_limb_endpoints_must_keep</span> <span class="o">=</span> <span class="kc">None</span>




    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Total time for Fixing Skeleton Soma Endpoint Extension : </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clean_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;  --------- END OF 9/17 Addition:  -------- &quot;&quot;&quot;</span>

    <span class="c1">#                     sk_debug = True</span>
    <span class="c1">#                     if sk_debug:</span>
    <span class="c1">#                         from python_tools import system_utils as su</span>
    <span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
    <span class="c1">#                         su.compressed_pickle(current_skeleton,</span>
    <span class="c1">#                                             &quot;current_skeleton_after_addition&quot;)</span>



        <span class="c1"># --------  Doing the cleaning ------- #</span>
    <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_end_node_length = </span><span class="si">{</span><span class="n">filter_end_node_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; 9/16 Edit: Now send the border vertices and don&#39;t want to clean anyy end nodes that are within certain distance of border&quot;&quot;&quot;</span>

    <span class="c1">#soma_border_vertices = total_border_vertices,</span>
    <span class="c1">#skeleton_mesh=branch,</span>
    
    <span class="c1">#gathering the endpoints to send to skeleton cleaning</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_limb_endpoints_must_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_limb_endpoints_must_keep</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">check_skeleton_connected_component</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; ----------- 1/6/21 Addition -----------------</span>
<span class="sd">    Can check for end-nodes that should not be filtered away </span>
<span class="sd">    because represent significant portions of mesh</span>
<span class="sd">    </span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinates_to_keep BEFORE significant mesh check = </span><span class="si">{</span><span class="n">coordinates_to_keep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">restrict_end_nodes_filtered_by_corr</span><span class="p">:</span>
        <span class="n">sign_coordinates_from_mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_end_nodes_with_significant_mesh_correspondence</span><span class="p">(</span>
                                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">skeleton</span> <span class="o">=</span> <span class="n">current_skeleton</span><span class="p">,</span>
                                    <span class="n">skeleton_considered_max</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">plot_viable_endpoint_correspondences</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">plot_keep_endpoints</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sign_coordinates_from_mesh</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sign_coordinates_from_mesh</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coordinates_to_keep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">coordinates_to_keep</span><span class="p">,</span><span class="n">sign_coordinates_from_mesh</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">sign_coordinates_from_mesh</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sign_coordinates_from_mesh = </span><span class="si">{</span><span class="n">sign_coordinates_from_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinates_to_keep AFTER significant mesh check = </span><span class="si">{</span><span class="n">coordinates_to_keep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    
    <span class="n">new_cleaned_skeleton</span> <span class="o">=</span> <span class="n">clean_skeleton</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">,</span>
                            <span class="n">distance_func</span><span class="o">=</span><span class="n">skeletal_distance</span><span class="p">,</span>
                      <span class="n">min_distance_to_junction</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="p">,</span> <span class="c1">#this used to be a tuple i think when moved the parameter up to function defintion</span>
                      <span class="n">return_skeleton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="c1">#                         soma_border_vertices = total_border_vertices,</span>
<span class="c1">#                         skeleton_mesh=branch,</span>
                        <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="n">coordinates_to_keep</span><span class="p">,</span>
                      <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1">#                     sk_debug = True</span>
<span class="c1">#                     if sk_debug:</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#                         su.compressed_pickle(new_cleaned_skeleton,</span>
<span class="c1">#                                             &quot;new_cleaned_skeleton&quot;)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Checking connected components after clean_skeleton&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">check_skeleton_connected_component</span><span class="p">(</span><span class="n">new_cleaned_skeleton</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No connected skeleton after cleaning so just going with older skeleton&quot;</span><span class="p">)</span>
        <span class="n">new_cleaned_skeleton</span> <span class="o">=</span> <span class="n">current_skeleton</span>
    
    <span class="c1">#--- 1) Cleaning each limb through distance and decomposition, checking that all cleaned branches are connected components and then visualizing</span>
    <span class="n">distance_cleaned_skeleton</span> <span class="o">=</span> <span class="n">new_cleaned_skeleton</span>

    <span class="k">if</span> <span class="n">perform_cleaning_checks</span><span class="p">:</span>
        <span class="c1">#make sure still connected componet</span>
        <span class="n">distance_cleaned_skeleton_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">distance_cleaned_skeleton</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">distance_cleaned_skeleton_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;distance_cleaned_skeleton </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> was not a single component: it was actually </span><span class="si">{</span><span class="n">distance_cleaned_skeleton_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;after DISTANCE cleaning limb size of skeleton = </span><span class="si">{</span><span class="n">distance_cleaned_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">cleaned_branch</span> <span class="o">=</span> <span class="n">clean_skeleton_with_decompose</span><span class="p">(</span><span class="n">distance_cleaned_skeleton</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">perform_cleaning_checks</span><span class="p">:</span>
        <span class="n">cleaned_branch_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cleaned_branch_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BEFORE COMBINE: cleaned_branch </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> was not a single component: it was actually </span><span class="si">{</span><span class="n">cleaned_branch_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>



    <span class="k">if</span> <span class="n">combine_close_skeleton_nodes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;********COMBINING CLOSE SKELETON NODES WITHIN </span><span class="si">{</span><span class="n">combine_close_skeleton_nodes_threshold</span><span class="si">}</span><span class="s2"> DISTANCE**********&quot;</span><span class="p">)</span>
        <span class="n">cleaned_branch</span> <span class="o">=</span> <span class="n">combine_close_branch_points</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">,</span>
                                                            <span class="n">combine_threshold</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes_threshold</span><span class="p">,</span>
                                                            <span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 

        
    
    <span class="k">if</span> <span class="n">remove_cycles_at_end</span><span class="p">:</span>
        <span class="n">cleaned_branch</span> <span class="o">=</span> <span class="n">remove_cycles_from_skeleton</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">)</span>
        
    <span class="n">cleaned_branch</span> <span class="o">=</span> <span class="n">clean_skeleton_with_decompose</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">perform_cleaning_checks</span><span class="p">:</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">))</span> 
        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After combine: Original limb was not a single component: it was actually </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>
            
        <span class="n">divided_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">)</span>
        
        <span class="c1">#check that when we downsample it is not one component:</span>
        <span class="n">curr_branch_meshes_downsampled</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">n_segments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">divided_branches</span><span class="p">]</span>
        <span class="n">downsampled_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">)</span>
        <span class="n">curr_sk_graph_debug</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">downsampled_skeleton</span><span class="p">)</span>


        <span class="n">con_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_sk_graph_debug</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">con_comp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were more than 1 component when downsizing: </span><span class="si">{</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">con_comp</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cleaned_branch</span><span class="p">,</span><span class="n">curr_limb_endpoints_must_keep</span></div>

<div class="viewcode-block" id="check_skeleton_connected_component"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.check_skeleton_connected_component">[docs]</a><span class="k">def</span> <span class="nf">check_skeleton_connected_component</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="n">sk_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">n_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_comp</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="n">n_comp</span><span class="si">}</span><span class="s2"> number of components detected in the skeleton&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_connected_components"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_connected_components">[docs]</a><span class="k">def</span> <span class="nf">skeleton_connected_components</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="n">total_limb_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">conn_comp_graph</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">total_limb_sk_graph</span><span class="p">))</span>
    <span class="n">conn_comp_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">total_limb_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp_graph</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">conn_comp_sk</span></div>
        
<div class="viewcode-block" id="remove_cycles_from_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.remove_cycles_from_skeleton">[docs]</a><span class="k">def</span> <span class="nf">remove_cycles_from_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
    <span class="n">max_cycle_distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">check_cycles_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_original_if_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">error_on_more_than_two_paths_between_high_degree_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove small cycles from a skeleton</span>
<span class="sd">    </span>

<span class="sd">    Pseudocode: How to resolve a cycle</span>
<span class="sd">    A) Convert the skeleton into a graph</span>
<span class="sd">    B) Find all cycles in the graph</span>

<span class="sd">    For each cycle</span>
<span class="sd">    -------------</span>
<span class="sd">    1) Get the length of the cycle </span>
<span class="sd">    --&gt; if length if too big then skip</span>
<span class="sd">    2) If only 1 high degree node, then just delete the other non high degree nodes</span>
<span class="sd">    3) Else, there should only be 2 high degree nodes in the vertices of the cycle</span>
<span class="sd">    --&gt; if more or less then skip</span>
<span class="sd">    3) Get the 2 paths between the high degree nodes</span>
<span class="sd">    4) Delete nodes on the path for the longer distance one</span>
<span class="sd">    ------------</span>

<span class="sd">    C) convert the graph back into a skeleton</span>


<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    remove_cycles_from_skeleton(skeleton = significant_poisson_skeleton)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">try</span><span class="p">:</span>

        <span class="c1">#A) Convert the skeleton into a graph</span>
        <span class="n">skeleton_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="c1">#B) Find all cycles in the graph</span>
        <span class="n">cycles_list</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_all_cycles</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>

        <span class="n">number_skipped</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">cyc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cycles_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> ---- Working on cycle </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">cyc</span><span class="si">}</span><span class="s2"> ----&quot;</span><span class="p">)</span>
            <span class="c1">#1) Get the length of the cycle </span>
            <span class="c1">#--&gt; if length if too big then skip</span>
            <span class="n">cyc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">cyc</span><span class="p">,</span><span class="n">skeleton_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- cycle </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> has nodes that don&#39;t exist anymore so skipping --&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">sk_dist_of_cycle</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_skeletal_distance_along_graph_node_path</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">cyc</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">max_cycle_distance</span> <span class="o">&lt;</span> <span class="n">sk_dist_of_cycle</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping cycle </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> because total distance (</span><span class="si">{</span><span class="n">sk_dist_of_cycle</span><span class="si">}</span><span class="s2">) is larger than max_cycle_distance (</span><span class="si">{</span><span class="n">max_cycle_distance</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">cyc</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="n">number_skipped</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>


            <span class="c1">#Find the degrees of all of the nodes</span>
            <span class="n">node_degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_node_degree</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cyc</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_degrees = </span><span class="si">{</span><span class="n">node_degrees</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#2) If only 1 high degree node, then just delete the other non high degree nodes</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">node_degrees</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deleting non-high degree nodes in cycle </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">cyc</span><span class="si">}</span><span class="s2"> becuase there was only one high degree node: </span><span class="si">{</span><span class="n">node_degrees</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">nodes_to_delete</span> <span class="o">=</span> <span class="n">cyc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">node_degrees</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="n">skeleton_graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_delete</span><span class="p">)</span>
                <span class="k">continue</span>


            <span class="c1">#3) Else, there should only be 2 high degree nodes in the vertices of the cycle</span>
            <span class="c1">#--&gt; if more or less then skip</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">node_degrees</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping cycle </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> because had </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">node_degrees</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> number of high degree nodes: </span><span class="si">{</span><span class="n">node_degrees</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="n">number_skipped</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">high_degree_nodes</span> <span class="o">=</span> <span class="n">cyc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">node_degrees</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_degree_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No higher degree (above 2) nodes detected&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            
            
            <span class="n">cycle_graph</span> <span class="o">=</span> <span class="n">skeleton_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>

            <span class="c1">#3) Get the 2 paths between the high degree nodes</span>
            <span class="n">both_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="n">cycle_graph</span><span class="p">,</span><span class="n">high_degree_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">high_degree_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle_graph</span><span class="p">)))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">both_paths</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error_on_more_than_two_paths_between_high_degree_nodes</span><span class="p">:</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not come up with only 2 paths between high degree nodes: both_paths = </span><span class="si">{</span><span class="n">both_paths</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not come up with only 2 paths between high degree nodes: both_paths = </span><span class="si">{</span><span class="n">both_paths</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

            <span class="n">path_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">find_skeletal_distance_along_graph_node_path</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">both_paths</span><span class="p">]</span>


            <span class="c1">#4) Delete nodes on the path for the longer distance one</span>
            <span class="n">longest_path_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span>
            <span class="n">longest_path</span> <span class="o">=</span> <span class="n">both_paths</span><span class="p">[</span><span class="n">longest_path_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">longest_path</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Longest path for deletion was only of size 2 or less: both_paths = </span><span class="si">{</span><span class="n">both_paths</span><span class="si">}</span><span class="s2">, longest_path = </span><span class="si">{</span><span class="n">longest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For cycle </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> deleting the following path because longest distance </span><span class="si">{</span><span class="n">path_lengths</span><span class="p">[</span><span class="n">longest_path_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">longest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">skeleton_graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">longest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


        <span class="c1">#C) check that all cycles removed except for those ones</span>
        <span class="k">if</span> <span class="n">check_cycles_at_end</span><span class="p">:</span>
            <span class="n">cycles_at_end</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_all_cycles</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_skipped</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycles_at_end</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The number of cycles skipped (</span><span class="si">{</span><span class="n">number_skipped</span><span class="si">}</span><span class="s2">) does not equal the number of cycles at the end (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cycles_at_end</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1">#C) convert the graph back into a skeleton</span>
        <span class="n">skeleton_removed_cycles</span> <span class="o">=</span> <span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_removed_cycles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#su.compressed_pickle(skeleton,&quot;remove_cycles_skeleton&quot;)</span>
            <span class="c1">#raise Exception(&quot;Removing the cycles made the skeleton of 0 size so returning old skeleton&quot;)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing the cycles made the skeleton of 0 size so returning old skeleton&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">skeleton</span>
        
        <span class="k">return</span> <span class="n">skeleton_removed_cycles</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_original_if_error</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">skeleton</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;remove_cycles_skeleton&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong in remove_cycles_from_skeleton (12/2 found because had disconnected skeleton)&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="skeleton_list_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_list_connectivity">[docs]</a><span class="k">def</span> <span class="nf">skeleton_list_connectivity</span><span class="p">(</span><span class="n">skeletons</span><span class="p">,</span>
    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the edge list for the connectivity of </span>
<span class="sd">    branches in a list of skeleton branches</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">sk_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skeletons</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">unique_endpoints</span><span class="p">,</span><span class="n">indices</span><span class="p">,</span><span class="n">counts</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sk_endpoints</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">total_edge_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">repeated_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">repeated_indices</span><span class="p">:</span>
        <span class="n">connect_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">ri</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">connect_branches_fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">connect_branches</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">total_edge_list</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">connect_branches_fixed</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">total_edge_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">total_edge_list</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">total_edge_list</span></div>

<div class="viewcode-block" id="skeleton_list_connectivity_slow"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_list_connectivity_slow">[docs]</a><span class="k">def</span> <span class="nf">skeleton_list_connectivity_slow</span><span class="p">(</span>
    <span class="n">skeletons</span><span class="p">,</span>
    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine which skeletons</span>
<span class="sd">    branches are connected to which and to</span>
<span class="sd">    record an edge list</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    For all branches i:</span>
<span class="sd">        a. get the endpoints</span>
<span class="sd">        For all branches j:</span>
<span class="sd">            a. get the endpoints</span>
<span class="sd">            b. compare the endpoints to the first</span>
<span class="sd">            c. if matching then add an edge</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeleton_connectivity_edge_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sk_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skeletons</span><span class="p">):</span>
        
        <span class="n">sk_j_ends</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">sk_j</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">sk_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skeletons</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">sk_i_ends</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">sk_i</span><span class="p">)</span>

            <span class="n">stacked_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">sk_j_ends</span><span class="p">,</span><span class="n">sk_i_ends</span><span class="p">])</span>
            <span class="n">endpoints_match</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">get_matching_vertices</span><span class="p">(</span><span class="n">stacked_endpoints</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_match</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">skeleton_connectivity_edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">skeleton_connectivity_edge_list</span></div>
            

    
<div class="viewcode-block" id="move_point_to_nearest_branch_end_point_within_threshold"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.move_point_to_nearest_branch_end_point_within_threshold">[docs]</a><span class="k">def</span> <span class="nf">move_point_to_nearest_branch_end_point_within_threshold</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">coordinate</span><span class="p">,</span>
        <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">return_coordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_change_status</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">consider_high_degree_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">possible_node_coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">excluded_node_coordinates</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To pick a branch or endpoint node that</span>
<span class="sd">    is within a certain a certain distance of the original </span>
<span class="sd">    node (if none in certain distance then return original)</span>
<span class="sd">    </span>
<span class="sd">    Arguments: </span>
<span class="sd">    possible_node_coordinates: this allows you to specify nodes that you want to select</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#check that an exlucde point is not already included</span>
    
    
    
    <span class="n">curr_skeleton_MAP</span> <span class="o">=</span> <span class="n">skeleton</span>
    <span class="n">MAP_stitch_point</span> <span class="o">=</span> <span class="n">coordinate</span>

    <span class="c1">#get a network of the skeleton</span>
    <span class="n">curr_skeleton_MAP_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_skeleton_MAP</span><span class="p">)</span>
    <span class="c1">#get the node where the stitching will take place</span>
    <span class="n">node_for_stitch</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">MAP_stitch_point</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#get all of the endnodes or high degree nodes</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_for_stitch = </span><span class="si">{</span><span class="n">node_for_stitch</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">node_for_stitch</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># -------- 1/2 Make sure that stitch point is not part of the exclude node point, and if so then move it ---------#</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">excluded_node_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">excluded_node_coordinates</span> <span class="o">=</span> <span class="n">excluded_node_coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">possible_node_loc_to_exclude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">zz</span><span class="p">,</span><span class="n">return_neg_one_if_not_find</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="n">excluded_node_coordinates</span><span class="p">])</span>
        <span class="n">node_for_stitch</span><span class="o">=</span><span class="n">xu</span><span class="o">.</span><span class="n">move_node_from_exclusion_list</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span>
                                        <span class="n">exclusion_list</span><span class="o">=</span><span class="n">possible_node_loc_to_exclude</span><span class="p">,</span>
                                        <span class="n">node</span><span class="o">=</span><span class="n">node_for_stitch</span><span class="p">,</span>
                                        <span class="n">return_coordinate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="p">)</span>
        <span class="c1"># --- 1/4 addition that helped debug where the stitch point was being connected to an exclude node -- #</span>
        <span class="n">MAP_stitch_point</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">node_for_stitch</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_for_stitch AFTER = </span><span class="si">{</span><span class="n">node_for_stitch</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">node_for_stitch</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># ----- 11/13 addition: Use the node locations sent or just use the high degree or end nodes from the graph</span>
    <span class="k">if</span> <span class="n">possible_node_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_MAP_end_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">consider_high_degree_nodes</span><span class="p">:</span>
            <span class="n">curr_MAP_branch_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_greater_or_equal_degree_k</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_MAP_branch_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">possible_node_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_MAP_end_nodes</span> <span class="o">+</span> <span class="n">curr_MAP_branch_nodes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">possible_node_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">zz</span><span class="p">)</span> <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="n">possible_node_coordinates</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;possible_node_loc = </span><span class="si">{</span><span class="n">possible_node_loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#removing the high degree coordinates that should not be there</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">excluded_node_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">possible_node_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">possible_node_loc</span><span class="p">,</span><span class="n">possible_node_loc_to_exclude</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;possible_node_loc AFTER = </span><span class="si">{</span><span class="n">possible_node_loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#get the distance along the skeleton from the stitch point to all of the end or branch nodes</span>
    <span class="n">curr_shortest_path</span><span class="p">,</span><span class="n">end_node_1</span><span class="p">,</span><span class="n">end_node_2</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span>
                                                                <span class="n">node_list_1</span><span class="o">=</span><span class="p">[</span><span class="n">node_for_stitch</span><span class="p">],</span>
                                                                <span class="n">node_list_2</span><span class="o">=</span><span class="n">possible_node_loc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_shortest_path = </span><span class="si">{</span><span class="n">curr_shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="n">changed_node</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_shortest_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
             <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current stitch point was a branch or endpoint&quot;</span><span class="p">)</span>
        <span class="n">MAP_stitch_point_new</span> <span class="o">=</span> <span class="n">MAP_stitch_point</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="c1">#get the length of the path</span>
        <span class="n">shortest_path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span>
                           <span class="n">end_node_1</span><span class="p">,</span>
                           <span class="n">end_node_2</span><span class="p">,</span>
                           <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current stitch point was not a branch or endpoint, shortest_path_length to one = </span><span class="si">{</span><span class="n">shortest_path_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">shortest_path_length</span> <span class="o">&lt;</span> <span class="n">distance_to_move_point_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Changing the stitch point becasue the distance to end or branch node was </span><span class="si">{</span><span class="n">shortest_path_length</span><span class="si">}</span><span class="s2">&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">New stitch point has degree </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_node_degree</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">end_node_2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">MAP_stitch_point_new</span> <span class="o">=</span> <span class="n">end_node_2</span>
            <span class="n">changed_node</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MAP_stitch_point_new</span> <span class="o">=</span> <span class="n">MAP_stitch_point</span>
    
    <span class="k">if</span> <span class="n">return_coordinate</span> <span class="ow">and</span> <span class="n">changed_node</span><span class="p">:</span>
        <span class="n">MAP_stitch_point_new</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_skeleton_MAP_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">MAP_stitch_point_new</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">MAP_stitch_point_new</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_change_status</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">changed_node</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="cut_skeleton_at_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.cut_skeleton_at_coordinate">[docs]</a><span class="k">def</span> <span class="nf">cut_skeleton_at_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="n">cut_coordinate</span><span class="p">,</span>
                              <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span> <span class="c1">#if have to find cut point that is not already coordinate</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    To cut a skeleton into 2 pieces at a certain cut coordinate</span>
<span class="sd">    </span>
<span class="sd">    Application: Used when the MP skeleton pieces </span>
<span class="sd">    connect to the middle of a MAP branch and have to split it</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    ex_sk = neuron_obj[1][0].skeleton</span>
<span class="sd">    cut_coordinate = np.array([ 560252., 1121040.,  842599.])</span>

<span class="sd">    new_sk_cuts = sk.cut_skeleton_at_coordinate(skeleton=ex_sk,</span>
<span class="sd">                              cut_coordinate=cut_coordinate)</span>

<span class="sd">    ipvu.plot_objects(skeletons=new_sk_cuts,</span>
<span class="sd">                     skeletons_colors=&quot;random&quot;,</span>
<span class="sd">                     scatters=[cut_coordinate])</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_MAP_sk_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#b) Convert the skeleton into a graph</span>
    <span class="n">curr_MAP_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="c1">#c) Find the node of the MAP stitch point (where need to do the breaking)</span>
    
    
    <span class="n">MP_stitch_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_MAP_sk_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">cut_coordinate</span><span class="p">))</span>
    
    <span class="c1"># --------- New Addition that accounts for if cut point is not an actual node but can interpolate between nodes -------#</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MP_stitch_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#then have to add the new stitch point</span>
        <span class="n">current_point</span> <span class="o">=</span> <span class="n">cut_coordinate</span>
        <span class="n">winning_edge</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span> <span class="ow">in</span> <span class="n">curr_MAP_sk_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">node_a_coord</span><span class="p">,</span><span class="n">node_b_coord</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_MAP_sk_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">])</span>

            <span class="n">AB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_a_coord</span><span class="o">-</span><span class="n">node_b_coord</span><span class="p">)</span>
            <span class="n">AC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_a_coord</span><span class="o">-</span><span class="n">cut_coordinate</span><span class="p">)</span>
            <span class="n">CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cut_coordinate</span><span class="o">-</span><span class="n">node_b_coord</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">AB</span> <span class="o">-</span> <span class="n">AC</span> <span class="o">-</span> <span class="n">CB</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">winning_edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">]</span>
                <span class="n">winning_edge_coord</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_a_coord</span><span class="p">,</span><span class="n">node_b_coord</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found winning edge: </span><span class="si">{</span><span class="n">winning_edge</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">winning_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cut point was neither a matching node nor a coordinate between 2 nodes &quot;</span><span class="p">)</span>
            
        <span class="n">new_node_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">curr_MAP_sk_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">curr_MAP_sk_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="n">new_node_name</span><span class="p">,{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span><span class="n">cut_coordinate</span><span class="p">})])</span>
        <span class="n">curr_MAP_sk_graph</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="n">winning_edge</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                            <span class="n">new_node_name</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">winning_edge_coord</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">cut_coordinate</span><span class="p">)</span>
                                           <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
        <span class="n">curr_MAP_sk_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">winning_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">winning_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">MP_stitch_node</span> <span class="o">=</span> <span class="n">new_node_name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">MP_stitch_node</span> <span class="o">=</span> <span class="n">MP_stitch_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="c1"># --------- End of Addition -------#</span>
    
    <span class="c1">#d) Find the degree one nodes</span>
    <span class="n">curr_end_nodes_for_break</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">curr_MAP_sk_graph</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#e) For each degree one node:</span>
    <span class="k">for</span> <span class="n">e_n</span> <span class="ow">in</span> <span class="n">curr_end_nodes_for_break</span><span class="p">:</span>
        <span class="c1">#- Find shortest path from stitch node to end node</span>
        <span class="n">stitch_to_end_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_MAP_sk_graph</span><span class="p">,</span><span class="n">MP_stitch_node</span><span class="p">,</span><span class="n">e_n</span><span class="p">)</span>
        <span class="c1">#- get a subgraph from that path</span>
        <span class="n">stitch_to_end_path_graph</span> <span class="o">=</span> <span class="n">curr_MAP_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">stitch_to_end_path</span><span class="p">)</span>
        <span class="c1">#- convert graph to a skeleton and save as new skeletons</span>
        <span class="n">new_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">stitch_to_end_path_graph</span><span class="p">)</span>
        <span class="n">curr_MAP_sk_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_sk</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">curr_MAP_sk_new</span></div>



<div class="viewcode-block" id="smooth_skeleton_branch"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.smooth_skeleton_branch">[docs]</a><span class="k">def</span> <span class="nf">smooth_skeleton_branch</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                    <span class="n">neighborhood</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                    <span class="n">coordinates_to_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">keep_endpoints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To smooth skeleton of branch while keeping the same endpoints</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) get the endpoint coordinates of the skeleton</span>
<span class="sd">    2) turn the skeleton into nodes and edges</span>
<span class="sd">    - if number of nodes is less than 3 then return</span>
<span class="sd">    3) Find the indexes that are the end coordinates</span>
<span class="sd">    4) Send the coordinates and edges off to get smoothed</span>
<span class="sd">    5) Replace the end coordinate smooth vertices with original</span>
<span class="sd">    6) Convert nodes and edges back to a skeleton</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    orig_smoothed_sk = smooth_skeleton(neuron_obj[limb_idx][branch_idx].skeleton,</span>
<span class="sd">                                  neighborhood=5)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    



    <span class="c1">#2) turn the skeleton into nodes and edges</span>
    <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes_edges</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>

    <span class="c1">#- if number of nodes is less than 3 then return</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Only 2 skeleton nodes so cannot do smoothing&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">skeleton</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coordinates_to_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates_to_keep</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">keep_endpoints</span><span class="p">:</span>
        <span class="c1">#1) get the endpoint coordinates of the skeleton</span>
        <span class="n">curr_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coordinates_to_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">curr_endpoints</span><span class="p">,</span><span class="n">coordinates_to_keep</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">curr_endpoints</span>
            

        
    <span class="c1">#3) Find the indexes that are the end coordinates</span>
    <span class="n">coordinates_to_keep_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinates_to_keep</span><span class="p">]</span>
        

    <span class="c1">#4) Send the coordinates and edges off to get smoothed</span>
    
    <span class="n">smoothed_nodes</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">smooth_graph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">neighborhood</span><span class="o">=</span><span class="n">neighborhood</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>

    <span class="c1">#5) Replace the end coordinate smooth vertices with original</span>
    <span class="k">for</span> <span class="n">endpt_idx</span><span class="p">,</span><span class="n">endpt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinates_to_keep_idx</span><span class="p">,</span><span class="n">coordinates_to_keep</span><span class="p">):</span>
        <span class="n">smoothed_nodes</span><span class="p">[</span><span class="n">endpt_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpt</span>

    <span class="c1">#6) Convert nodes and edges back to a skeleton</span>
    <span class="n">final_sk_smooth</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_nodes_edges_to_skeleton</span><span class="p">(</span><span class="n">smoothed_nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_sk_smooth</span></div>



<div class="viewcode-block" id="add_and_smooth_segment_to_branch"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.add_and_smooth_segment_to_branch">[docs]</a><span class="k">def</span> <span class="nf">add_and_smooth_segment_to_branch</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                              <span class="n">skeleton_stitch_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">new_stitch_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">new_seg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">resize_mult</span><span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                               <span class="n">n_resized_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                               <span class="n">smooth_branch_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">n_resized_cutoff_to_smooth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">smooth_width</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                <span class="n">max_stitch_distance_for_smoothing</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                              <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add on a new skeletal segment to a branch that will</span>
<span class="sd">    prevent the characteristic hooking when stitching a new point</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the distance of the stitch point = A</span>
<span class="sd">    2) Resize the skeleton to B*A (where B &lt; 1)</span>
<span class="sd">    3) Find all nodes that are CA away from the MP stitch point</span>
<span class="sd">    4) Delete those nodes (except the last one and set that as the new stitch point)</span>
<span class="sd">    5) Make the new stitch</span>

<span class="sd">    Ex: When using a new segment</span>
<span class="sd">    orig_sk_func_smoothed = add_and_smooth_segment_to_branch(orig_sk,</span>
<span class="sd">                           new_seg = np.array([stitch_point_MAP,stitch_point_MP]).reshape(-1,2,3))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 12/21 Addition: If the point you are trying to stitch to is already there then just return the skeleton</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">new_stitch_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sk_graph_at_beginning</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">match_nodes_to_new_stitch_point</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">sk_graph_at_beginning</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">new_stitch_point</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_nodes_to_new_stitch_point</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;New stitch point was already on the skeleton so don&#39;t need to add it&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">skeleton</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The skeleton passed to the smoothing function was empty&quot;</span><span class="p">)</span>
    
    <span class="n">orig_sk</span> <span class="o">=</span> <span class="n">skeleton</span>
    <span class="n">orig_sk_segment_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">orig_sk</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">skeleton_stitch_point</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_stitch_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_seg_reshaped</span> <span class="o">=</span> <span class="n">new_seg</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1">#try to get the stitch points from the new seg</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">([</span><span class="n">orig_sk</span><span class="p">],</span><span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">([</span><span class="n">orig_sk</span><span class="p">],</span><span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">stitch_point_MP</span> <span class="o">=</span> <span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">stitch_point_MAP</span> <span class="o">=</span> <span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">([</span><span class="n">orig_sk</span><span class="p">],</span><span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">([</span><span class="n">orig_sk</span><span class="p">],</span><span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">stitch_point_MP</span> <span class="o">=</span> <span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stitch_point_MAP</span> <span class="o">=</span> <span class="n">new_seg_reshaped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Could not find a stitch point that was on the existing skeleton and one that was not&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stitch_point_MAP</span> <span class="o">=</span> <span class="n">new_stitch_point</span>
        <span class="n">stitch_point_MP</span> <span class="o">=</span> <span class="n">skeleton_stitch_point</span>

    <span class="c1">#1) Get the distance of the stitch point = A</span>
    <span class="n">stitch_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">stitch_point_MAP</span><span class="o">-</span><span class="n">stitch_point_MP</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stitch_distance</span> <span class="o">&gt;</span> <span class="n">max_stitch_distance_for_smoothing</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using max stitch distance (</span><span class="si">{</span><span class="n">max_stitch_distance_for_smoothing</span><span class="si">}</span><span class="s2">) for smoothing because stitch_distance greater (</span><span class="si">{</span><span class="n">stitch_distance</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
        <span class="n">stitch_distance</span> <span class="o">=</span> <span class="n">max_stitch_distance_for_smoothing</span>
    
        

    <span class="c1">#2) Resize the skeleton to B*A (where B &lt; 1)</span>
    
    <span class="n">orig_sk_resized</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">orig_sk</span><span class="p">,</span><span class="n">segment_width</span> <span class="o">=</span> <span class="n">resize_mult</span><span class="o">*</span><span class="n">stitch_distance</span><span class="p">)</span>

    <span class="c1">#3) Find all nodes that are CA away from the MP stitch point</span>
    <span class="n">orig_resized_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">orig_sk_resized</span><span class="p">)</span>
    <span class="n">MP_stitch_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">orig_resized_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">stitch_point_MP</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MP_stitch_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">MP_stitch_node</span> <span class="o">=</span> <span class="n">MP_stitch_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP_stitch_node not len = 1: len = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">MP_stitch_node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">nodes_within_dist</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">dict_to_array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span><span class="n">orig_resized_graph</span><span class="p">,</span>
                                                         <span class="n">target_node</span><span class="o">=</span><span class="n">MP_stitch_node</span><span class="p">,</span>
                                                        <span class="n">cutoff_distance</span><span class="o">=</span><span class="n">n_resized_cutoff</span><span class="o">*</span><span class="n">stitch_distance</span><span class="p">,</span>
                                                                            <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">farthest_node_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">nodes_within_dist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">farthest_node</span> <span class="o">=</span> <span class="n">nodes_within_dist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">farthest_node_idx</span><span class="p">]</span>
    <span class="n">new_stitch_point_MP</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">orig_resized_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">farthest_node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#need to consider if the farthest node is an endpoint</span>
    <span class="n">farthest_node_degree</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_degree</span><span class="p">(</span><span class="n">orig_resized_graph</span><span class="p">,</span><span class="n">farthest_node</span><span class="p">)</span>

    <span class="n">keep_branch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">farthest_node_degree</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span><span class="c1">#then don&#39;t have to worry about having reached branch end</span>
        <span class="n">cut_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">cut_skeleton_at_coordinate</span><span class="p">(</span><span class="n">orig_sk</span><span class="p">,</span><span class="n">cut_coordinate</span><span class="o">=</span><span class="n">new_stitch_point_MP</span><span class="p">)</span>
        <span class="c1">#find which branch had the original cut point</span>
        <span class="n">branch_to_keep_idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">cut_branches</span><span class="p">,</span><span class="n">stitch_point_MP</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep_branch</span> <span class="o">=</span> <span class="n">cut_branches</span><span class="p">[</span><span class="n">branch_to_keep_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keep_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># nodes_to_delete = np.delete(nodes_within_dist[:,0],farthest_node_idx)</span>
    <span class="n">new_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">new_stitch_point_MP</span><span class="p">],[</span><span class="n">stitch_point_MAP</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">final_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">new_seg</span><span class="p">,</span><span class="n">keep_branch</span><span class="p">])</span> 
    <span class="n">final_sk</span><span class="o">=</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">final_sk</span><span class="p">))</span>
    
    

    <span class="k">if</span> <span class="n">smooth_branch_at_end</span><span class="p">:</span>
        <span class="c1">#resize the skeleton</span>
        <span class="n">coordinates_to_keep</span><span class="o">=</span><span class="kc">None</span>
        <span class="c1">#skeleton_reshaped = sk.resize_skeleton_branch(final_sk,segment_width=smooth_width)</span>
        <span class="n">skeleton_reshaped</span> <span class="o">=</span> <span class="n">final_sk</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_branch</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_resized_cutoff_to_smooth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_resized_cutoff_to_smooth</span> <span class="o">=</span> <span class="n">n_resized_cutoff</span> <span class="o">+</span> <span class="mi">2</span>
<span class="w">  </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode for smoothing only a certain portion:</span>
<span class="sd">            1) Convert the branch to a graph</span>
<span class="sd">            2) Find the node with the MP stitch point</span>
<span class="sd">            3) Find all nodes within n_resized_cutoff_to_smooth*stitch_distance</span>
<span class="sd">            4) Get all nodes not in that list</span>
<span class="sd">            5) Get all the coordinates of those nodes</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1">#1) Convert the branch to a graph</span>
            <span class="n">sk_gr</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton_reshaped</span><span class="p">)</span>
            <span class="c1">#2) Find the node with the MP stitch point</span>
            <span class="n">MP_stitch_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">sk_gr</span><span class="p">,</span><span class="n">new_stitch_point_MP</span><span class="p">)</span>
            <span class="n">MAP_stitch_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">sk_gr</span><span class="p">,</span><span class="n">stitch_point_MAP</span><span class="p">)</span>

            <span class="c1">#3) Find all nodes within n_resized_cutoff_to_smooth*stitch_distance</span>
            <span class="n">distance_to_smooth</span> <span class="o">=</span> <span class="n">n_resized_cutoff_to_smooth</span><span class="o">*</span><span class="n">stitch_distance</span>
            <span class="n">nodes_to_smooth_pre</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span><span class="n">sk_gr</span><span class="p">,</span><span class="n">target_node</span><span class="o">=</span><span class="n">MP_stitch_node</span><span class="p">,</span>
                                                                <span class="n">cutoff_distance</span><span class="o">=</span><span class="n">distance_to_smooth</span><span class="p">)</span>
            
            <span class="c1">#need to add in nodes to endpoint in case the distance_to_smooth doesn&#39;t exend there</span>
            <span class="n">nodes_to_MAP</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">sk_gr</span><span class="p">,</span><span class="n">MP_stitch_node</span><span class="p">,</span><span class="n">MAP_stitch_node</span><span class="p">)</span>

            <span class="n">nodes_to_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes_to_smooth_pre</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes_to_MAP</span><span class="p">))</span>
            <span class="c1">#print(f&quot;nodes_to_smooth = {nodes_to_smooth}&quot;)</span>

            <span class="c1">#4) Get all nodes not in that list</span>
            <span class="n">nodes_to_not_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sk_gr</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes_to_smooth</span><span class="p">))</span>
            <span class="c1">#print(f&quot;nodes_to_smooth = {nodes_to_not_smooth}&quot;)</span>

            <span class="c1">#5) Get all the coordinates of those nodes</span>
            <span class="n">coordinates_to_keep</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">sk_gr</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">nodes_to_not_smooth</span><span class="p">)</span>
            
        
        <span class="n">final_sk</span> <span class="o">=</span> <span class="n">smooth_skeleton_branch</span><span class="p">(</span><span class="n">skeleton_reshaped</span><span class="p">,</span><span class="n">coordinates_to_keep</span><span class="o">=</span><span class="n">coordinates_to_keep</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="c1">#need to resize the final_sk</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_sk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        3) Create a skeleton segment from the skeleton_stitch_point to the new point</span>
<span class="sd">        4) Stack the skeletons</span>
<span class="sd">        5) Return </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Skeleton at the end of smoothing was empty so just going to stitch the new point to skeleton without stitching&quot;</span><span class="p">)</span>
        
        
        <span class="n">new_sk_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">skeleton_stitch_point</span><span class="p">,</span><span class="n">new_stitch_point</span><span class="p">])</span>
        <span class="n">final_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">skeleton</span><span class="p">,</span><span class="n">new_sk_seg</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">final_sk</span>
        
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">final_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">final_sk</span><span class="p">,</span><span class="n">segment_width</span><span class="o">=</span><span class="n">orig_sk_segment_width</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_sk</span></div>

<div class="viewcode-block" id="number_connected_components"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.number_connected_components">[docs]</a><span class="k">def</span> <span class="nf">number_connected_components</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the number of connected components in a whole skeleton</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">))</span></div>

<div class="viewcode-block" id="number_connected_components_branches"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.number_connected_components_branches">[docs]</a><span class="k">def</span> <span class="nf">number_connected_components_branches</span><span class="p">(</span><span class="n">skeleton_branches</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the number of connected components in a list of skeleton branches</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">skeleton_branches</span><span class="p">)))</span></div>

    
<span class="c1"># ---------------- 11/26 Extra Utils for the Error Detection------------------</span>
<div class="viewcode-block" id="endpoint_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.endpoint_connectivity">[docs]</a><span class="k">def</span> <span class="nf">endpoint_connectivity</span><span class="p">(</span><span class="n">endpoints_1</span><span class="p">,</span><span class="n">endpoints_2</span><span class="p">,</span>
                         <span class="n">exceptions_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_coordinate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pupose: To determine where the endpoints of two branches are connected</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    end_1 = np.array([[759621., 936916., 872083.],</span>
<span class="sd">       [790891., 913598., 806043.]])</span>
<span class="sd">    end_2 = np.array([[790891., 913598., 806043.],</span>
<span class="sd">       [794967., 913603., 797825.]])</span>
<span class="sd">       </span>
<span class="sd">    endpoint_connectivity(end_1,end_2)</span>
<span class="sd">    &gt;&gt; {0: 1, 1: 0}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">connections_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">stacked_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">endpoints_1</span><span class="p">,</span><span class="n">endpoints_2</span><span class="p">])</span>
    <span class="n">endpoints_match</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">get_matching_vertices</span><span class="p">(</span><span class="n">stacked_endpoints</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">print_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No endpoints matching: </span><span class="si">{</span><span class="n">endpoints_match</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">exceptions_flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connections_dict</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">print_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Multiple endpoints matching: </span><span class="si">{</span><span class="n">endpoints_match</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">exceptions_flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
    
    
    <span class="c1">#look at the first connection</span>
    <span class="n">first_match</span> <span class="o">=</span> <span class="n">endpoints_match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">first_endpoint_match</span> <span class="o">=</span> <span class="n">first_match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;first_match = </span><span class="si">{</span><span class="n">first_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;first_endpoint_match = </span><span class="si">{</span><span class="n">endpoints_1</span><span class="p">[</span><span class="n">first_endpoint_match</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_coordinate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">endpoints_1</span><span class="p">[</span><span class="n">first_endpoint_match</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="n">first_endpoint_match</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">first_endpoint_match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non 0,1 matching node in first endpoint: </span><span class="si">{</span><span class="n">first_endpoint_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connections_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="n">first_endpoint_match</span><span class="p">})</span>
        
    <span class="n">second_endpoint_match</span> <span class="o">=</span> <span class="n">first_match</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">second_endpoint_match</span> <span class="ow">and</span> <span class="mi">3</span> <span class="o">!=</span> <span class="n">second_endpoint_match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non 2,3 matching node in second endpoint: </span><span class="si">{</span><span class="n">second_endpoint_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connections_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="n">second_endpoint_match</span><span class="o">-</span><span class="mi">2</span><span class="p">})</span>
    
    <span class="k">return</span> <span class="n">connections_dict</span></div>

<div class="viewcode-block" id="shared_endpoint"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.shared_endpoint">[docs]</a><span class="k">def</span> <span class="nf">shared_endpoint</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">,</span><span class="n">skeleton_2</span><span class="p">,</span><span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return the endpoint that joins two branches</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">end_1</span> <span class="o">=</span> <span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">)</span>
    <span class="n">end_2</span> <span class="o">=</span> <span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">skeleton_2</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">node_connectivity</span> <span class="o">=</span> <span class="n">endpoint_connectivity</span><span class="p">(</span><span class="n">end_1</span><span class="p">,</span><span class="n">end_2</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_coordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_possibly_two</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">end_1</span><span class="p">,</span><span class="n">end_2</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not exactly one shared endpoint&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node_connectivity</span></div>
    
<div class="viewcode-block" id="matching_endpoint_singular"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.matching_endpoint_singular">[docs]</a><span class="k">def</span> <span class="nf">matching_endpoint_singular</span><span class="p">(</span>
    <span class="n">array_1</span><span class="p">,</span>
    <span class="n">array_2</span><span class="p">,</span>
    <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    purpose: To find the one matching coordinate between two arrays</span>
<span class="sd">    and can return the index of each</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shared_coord</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">array_1</span><span class="p">,</span>
                                   <span class="n">array_2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shared_coord = </span><span class="si">{</span><span class="n">shared_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">array_1_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_row_index</span><span class="p">(</span><span class="n">array_1</span><span class="p">,</span><span class="n">shared_coord</span><span class="p">)</span>
        <span class="n">array_2_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_row_index</span><span class="p">(</span><span class="n">array_2</span><span class="p">,</span><span class="n">shared_coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array_1_idx</span><span class="p">,</span><span class="n">array_2_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shared_coord</span></div>
    

<div class="viewcode-block" id="flip_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.flip_skeleton">[docs]</a><span class="k">def</span> <span class="nf">flip_skeleton</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will flip the absolute order of a skeleton</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_sk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">new_sk</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="order_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.order_skeleton">[docs]</a><span class="k">def</span> <span class="nf">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_indexes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">error_on_non_start_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the skeleton in ordered vertices</span>
<span class="sd">    1) Convert to graph</span>
<span class="sd">    2) Find the endpoint nodes</span>
<span class="sd">    3) Find the shortest path between endpoints</span>
<span class="sd">    4) Get the coordinates of all of the nodes</span>
<span class="sd">    5) Create the skeleton by indexing into the coordinates by the order of the path</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start_endpoint_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="c1">#1) Convert to graph</span>
    <span class="n">sk_graph</span> <span class="o">=</span> <span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="c1">#2) Find the endpoint nodes</span>
    <span class="n">sk_graph_endpt_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_graph_endpt_nodes = </span><span class="si">{</span><span class="n">sk_graph_endpt_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#2b) If a starting endpoint coordinate was picked then use that</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">start_endpoint_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using start_endpoint_coordinate = </span><span class="si">{</span><span class="n">start_endpoint_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_st_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="p">)</span>
        <span class="n">start_node_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sk_graph_endpt_nodes</span><span class="o">==</span><span class="n">curr_st_node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_node_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_on_non_start_coordinate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The start endpoint was not an end node: </span><span class="si">{</span><span class="n">start_endpoint_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: start endpoint was not an end node: </span><span class="si">{</span><span class="n">start_endpoint_coordinate</span><span class="si">}</span><span class="s2"> but not erroring&quot;</span><span class="p">)</span>
            <span class="n">first_start_node</span> <span class="o">=</span> <span class="n">curr_st_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_node_idx = </span><span class="si">{</span><span class="n">start_node_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">start_node_idx</span> <span class="o">=</span> <span class="n">start_node_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">first_start_node</span> <span class="o">=</span> <span class="n">sk_graph_endpt_nodes</span><span class="p">[</span><span class="n">start_node_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_node_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first_start_node</span> <span class="o">=</span> <span class="n">sk_graph_endpt_nodes</span><span class="p">[</span><span class="n">start_node_idx</span><span class="p">]</span>
        
    
    <span class="n">leftover_start_nodes</span> <span class="o">=</span> <span class="n">sk_graph_endpt_nodes</span><span class="p">[</span><span class="n">sk_graph_endpt_nodes</span><span class="o">!=</span><span class="n">first_start_node</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover_start_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">other_end_node</span> <span class="o">=</span> <span class="n">leftover_start_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#find the </span>
        <span class="n">shortest_path</span><span class="p">,</span><span class="n">orig_st</span><span class="p">,</span><span class="n">other_end_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,[</span><span class="n">first_start_node</span><span class="p">],</span><span class="nb">list</span><span class="p">(</span><span class="n">leftover_start_nodes</span><span class="p">))</span>

    <span class="c1">#3) Find the shortest path between endpoints</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">first_start_node</span><span class="p">,</span><span class="n">other_end_node</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path = </span><span class="si">{</span><span class="n">shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#4) Get the coordinates of all of the nodes</span>
    <span class="n">node_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">node_list</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">)</span>

    <span class="c1">#5) Create the skeleton by indexing into the coordinates by the order of the path</span>
    
    <span class="n">ordered_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">node_coordinates</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">node_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_indexes</span><span class="p">:</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shortest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">original_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sk_graph</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">(),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">orig_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows_old</span><span class="p">(</span><span class="n">original_edges</span><span class="p">,</span><span class="n">ne</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ne</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ordered_skeleton</span><span class="p">,</span><span class="n">orig_indexes</span>
    
    <span class="k">return</span> <span class="n">ordered_skeleton</span></div>


<div class="viewcode-block" id="order_skeletons_connecting_endpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.order_skeletons_connecting_endpoints">[docs]</a><span class="k">def</span> <span class="nf">order_skeletons_connecting_endpoints</span><span class="p">(</span><span class="n">skeletons</span><span class="p">,</span>
                                         <span class="n">starting_endpoint_coordinate</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get a list of the endpoints in the order</span>
<span class="sd">    that the list of skeletons are connected</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    order_skeletons_connecting_endpoints([neuron_obj[0][k].skeleton for</span>
<span class="sd">                                                              k in ex_path],</span>
<span class="sd">                                    starting_endpoint_coordinate=st_coord)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                                                              <span class="n">n_segments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">skeletons</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">total_skeleton</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">starting_endpoint_coordinate</span><span class="p">)</span></div>
    


<div class="viewcode-block" id="align_skeletons_at_connectivity"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.align_skeletons_at_connectivity">[docs]</a><span class="k">def</span> <span class="nf">align_skeletons_at_connectivity</span><span class="p">(</span><span class="n">sk_1</span><span class="p">,</span><span class="n">sk_2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To align 2 skeletons where both starts with the endpoint</span>
<span class="sd">    that they share</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">common_coordinate</span> <span class="o">=</span> <span class="n">shared_endpoint</span><span class="p">(</span><span class="n">sk_1</span><span class="p">,</span><span class="n">sk_2</span><span class="p">)</span>
    <span class="n">sk_1</span> <span class="o">=</span> <span class="n">order_skeleton</span><span class="p">(</span><span class="n">sk_1</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">common_coordinate</span><span class="p">)</span>
    <span class="n">sk_2</span> <span class="o">=</span> <span class="n">order_skeleton</span><span class="p">(</span><span class="n">sk_2</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">common_coordinate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sk_1</span><span class="p">,</span><span class="n">sk_2</span></div>




<div class="viewcode-block" id="restrict_skeleton_from_start"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.restrict_skeleton_from_start">[docs]</a><span class="k">def</span> <span class="nf">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                     <span class="n">cutoff_distance</span><span class="p">,</span>
                    <span class="n">subtract_cutoff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">return_indexes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">return_success</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">resize_skeleton_to_help_success</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">tolerance</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                    <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To restrict a skeleton to a certain cutoff distance from the start</span>
<span class="sd">    which keeps that distance or subtracts it (and does not resize or reorder the skeleton but keeps the existing segment lengths)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    restrict_skeleton_from_start(skeleton = base_skeleton_ordered,</span>
<span class="sd">    cutoff_distance = offset)</span>

<span class="sd">    **** warning only works if skeletal segment *****\</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#handling if the cutof is 0</span>
    <span class="k">if</span> <span class="n">cutoff_distance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">return_indexes</span><span class="p">:</span>
                <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">return_success</span><span class="p">:</span>
                <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">return_values</span>
        
    <span class="k">if</span> <span class="n">starting_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">starting_coordinate</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">resize_skeleton_to_help_success</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                    <span class="n">segment_width</span> <span class="o">=</span> <span class="n">tolerance</span><span class="p">)</span>
        
    <span class="n">distance_of_segs</span> <span class="o">=</span> <span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">offset_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">distance_of_segs</span><span class="p">)</span><span class="o">&gt;=</span><span class="p">(</span><span class="n">cutoff_distance</span><span class="o">-</span><span class="n">tolerance</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_idxs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">offset_idxs</span> <span class="o">=</span> <span class="n">offset_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">subtract_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_of_segs</span><span class="p">)),</span><span class="n">offset_idxs</span><span class="p">)</span>
        
    <span class="n">subtract_sk</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">subtract_idxs</span><span class="p">]</span>
    <span class="n">subtract_sk_len</span> <span class="o">=</span> <span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">subtract_sk</span><span class="p">)</span>
<span class="c1">#     print(f&quot;subtract_sk_len = {subtract_sk_len}&quot;)</span>
<span class="c1">#     print(f&quot;(cutoff_distance-tolerance) = {(cutoff_distance-tolerance)}&quot;)</span>
    <span class="n">success_subtraction</span> <span class="o">=</span> <span class="n">subtract_sk_len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">cutoff_distance</span><span class="o">-</span><span class="n">tolerance</span><span class="p">)</span>
<span class="c1">#     print(f&quot;success_subtraction = {success_subtraction}&quot;)</span>

    <span class="c1">#flip the indexes if want to keep the segment</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">subtract_cutoff</span><span class="p">:</span> 
        <span class="n">keep_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_of_segs</span><span class="p">)),</span><span class="n">offset_idxs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keep_indexes</span> <span class="o">=</span> <span class="n">offset_idxs</span>

    <span class="c1">#restrict the skeleton</span>
    <span class="n">return_sk</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">keep_indexes</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_sk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_indexes</span><span class="p">:</span>
            <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">return_success</span><span class="p">:</span>
            <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_values</span>

    <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">return_sk</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_indexes</span><span class="p">:</span>
        <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_indexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_success</span><span class="p">:</span>
        <span class="n">return_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">success_subtraction</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_values</span></div>



<div class="viewcode-block" id="matching_skeleton_branches_by_vertices"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.matching_skeleton_branches_by_vertices">[docs]</a><span class="k">def</span> <span class="nf">matching_skeleton_branches_by_vertices</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
    
    <span class="n">decomposed_branches</span> <span class="o">=</span> <span class="n">branches</span>
    <span class="n">kdtree_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">KDTree</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">decomposed_branches</span><span class="p">]</span>
    <span class="n">matching_edges_kdtree</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d_br_1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">decomposed_branches</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">d_br_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decomposed_branches</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">dist</span><span class="p">,</span> <span class="n">nearest</span> <span class="o">=</span> <span class="n">kdtree_branches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">d_br_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">matching_edges_kdtree</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                    
    <span class="k">return</span> <span class="n">matching_edges_kdtree</span></div>
                    
                    
<div class="viewcode-block" id="matching_skeleton_branches_by_endpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.matching_skeleton_branches_by_endpoints">[docs]</a><span class="k">def</span> <span class="nf">matching_skeleton_branches_by_endpoints</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
    <span class="n">matching_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">decomposed_branches</span> <span class="o">=</span> <span class="n">branches</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d_br_1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">decomposed_branches</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">d_br_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decomposed_branches</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">c_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">br_1_end</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">d_br_1</span><span class="p">)</span>
                <span class="n">br_2_end</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">d_br_2</span><span class="p">)</span>
                <span class="c1">#print(f&quot;branch: {time.time() - c_t}&quot;)</span>
                <span class="n">c_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sk</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="n">br_1_end</span><span class="p">,</span><span class="n">br_2_end</span><span class="p">):</span>
                    <span class="n">matching_edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">matching_edges</span></div>
    

<div class="viewcode-block" id="check_correspondence_branches_have_2_endpoints"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.check_correspondence_branches_have_2_endpoints">[docs]</a><span class="k">def</span> <span class="nf">check_correspondence_branches_have_2_endpoints</span><span class="p">(</span><span class="n">correspondence</span><span class="p">,</span>
                                                  <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">raise_error</span><span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: check that all branches have 2 endpoints</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">irregular_branches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">piece_idx</span><span class="p">,</span><span class="n">piece_correspondence</span> <span class="ow">in</span> <span class="n">correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="k">if</span> <span class="s2">&quot;branch_skeleton&quot;</span> <span class="ow">in</span> <span class="n">piece_correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">piece_idx</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">piece_correspondence</span>
            
            <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
            <span class="n">curr_sk_endpoint_coord</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">curr_sk</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_endpoint_coord</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_endpoint_coord</span><span class="p">)</span><span class="si">}</span><span class="s2"> endpoints&quot;</span><span class="p">)</span>
                <span class="n">irregular_branches</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">piece_idx</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_endpoint_coord</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">piece_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
                <span class="n">curr_sk_endpoint_coord</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">curr_sk</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_endpoint_coord</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Piece </span><span class="si">{</span><span class="n">piece_idx</span><span class="si">}</span><span class="s2">, Branch </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_endpoint_coord</span><span class="p">)</span><span class="si">}</span><span class="s2"> endpoints&quot;</span><span class="p">)</span>
                    <span class="n">irregular_branches</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">piece_idx</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_sk_endpoint_coord</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">raise_error</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">irregular_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found the following irregular branches: </span><span class="si">{</span><span class="n">irregular_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">irregular_branches</span></div>


<span class="c1"># ---------------- 12/23 -------------------- #</span>
<div class="viewcode-block" id="offset_skeletons_aligned_at_shared_endpoint"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.offset_skeletons_aligned_at_shared_endpoint">[docs]</a><span class="k">def</span> <span class="nf">offset_skeletons_aligned_at_shared_endpoint</span><span class="p">(</span><span class="n">skeletons</span><span class="p">,</span>
                                               <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                            <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                                <span class="n">min_comparison_distance</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">common_endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="n">comparison_endpoints</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span>
                                               <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>

<span class="sd">    1) Get the shared endpoint of the branches</span>
<span class="sd">    2) Reorder the branches so both start with the endpoint and then resize</span>

<span class="sd">    For each edge skeleton (in order to get the final edge skeletons):</span>
<span class="sd">    3) Use the restrict skeelton function to subtract the offset</span>
<span class="sd">    - if not then add whole skeleton to final skeleton</span>
<span class="sd">    4) if it was a sucess, see if the distance is greater than comparison distance</span>
<span class="sd">    - if not then add current skeleton to final</span>
<span class="sd">    5) Use the subtract skeleton to only keep the comparison distance of skeleton</span>
<span class="sd">    6) Add to final skeleton</span>

<span class="sd">    offset_skeletons_aligned_at_shared_endpoint()</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    vis_branches_idx = [7,9]</span>
<span class="sd">    vis_branches = [curr_limb[k] for k in vis_branches_idx]</span>
<span class="sd">    vis_branches</span>


<span class="sd">    curr_skeletons = [k.skeleton for k in vis_branches]</span>
<span class="sd">    stripped_skeletons = sk.offset_skeletons_aligned_at_shared_endpoint(curr_skeletons)</span>

<span class="sd">    curr_colors = [&quot;red&quot;,&quot;black&quot;]</span>
<span class="sd">    ipvu.plot_objects(meshes=[k.mesh for k in vis_branches],</span>
<span class="sd">                      meshes_colors=curr_colors,</span>
<span class="sd">                      skeletons=stripped_skeletons,</span>
<span class="sd">                      skeletons_colors=curr_colors,</span>
<span class="sd">                      scatters=[np.array([stripped_skeletons[0][-1][-1],stripped_skeletons[1][-1][-1]])],</span>
<span class="sd">                      scatter_size=1</span>
<span class="sd">                     )</span>


<span class="sd">    sk.parent_child_skeletal_angle(stripped_skeletons[1],stripped_skeletons[0])</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge_skeletons</span> <span class="o">=</span> <span class="n">skeletons</span>
    <span class="n">seg_size</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="k">if</span> <span class="n">common_endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">edge_skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">edge_skeletons</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">common_endpoint</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;More than one common endpoint so just choosing the first&quot;</span><span class="p">)</span>
            <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">common_endpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">comparison_endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edge_skeletons_ordered</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">seg_size</span><span class="p">),</span><span class="n">common_endpoint</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_skeletons</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge_skeletons_ordered</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">seg_size</span><span class="p">),</span><span class="n">cm</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">comm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edge_skeletons</span><span class="p">,</span><span class="n">comparison_endpoints</span><span class="p">)]</span>
    
    <span class="n">final_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_skeletons_ordered</span><span class="p">:</span>
        
        <span class="c1"># -------- Making sure that we don&#39;t take off too much so it&#39;s just a spec</span>
        <span class="n">original_sk_length</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">original_sk_length</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">min_comparison_distance</span><span class="p">:</span>
            <span class="n">offset_adjusted</span> <span class="o">=</span> <span class="n">original_sk_length</span> <span class="o">-</span> <span class="n">min_comparison_distance</span>
            <span class="k">if</span> <span class="n">offset_adjusted</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset_adjusted</span> <span class="o">=</span> <span class="mi">0</span>
                
            <span class="c1">#print(f&quot; Had to Adjust Offset to {offset_adjusted}&quot;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset_adjusted</span>  <span class="o">=</span> <span class="n">offset</span>
            
        <span class="n">ret_sk</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">success</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">e</span><span class="p">,</span>
                                                           <span class="n">cutoff_distance</span> <span class="o">=</span> <span class="n">offset_adjusted</span><span class="p">,</span>
                                                           <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">final_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">comparison_distance</span><span class="p">:</span>
                <span class="n">ret_sk</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">success</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">,</span>
                                                           <span class="n">cutoff_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                                           <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">final_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_skeletons</span></div>


<div class="viewcode-block" id="parent_child_skeletal_angle"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.parent_child_skeletal_angle">[docs]</a><span class="k">def</span> <span class="nf">parent_child_skeletal_angle</span><span class="p">(</span><span class="n">parent_skeleton</span><span class="p">,</span><span class="n">child_skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To find the angle from continuation that the</span>
<span class="sd">    second skeleton deviates from the parent angle </span>
<span class="sd">    </span>
<span class="sd">    angles are just computed from the vectors of the endpoints</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">up_sk</span> <span class="o">=</span> <span class="n">parent_skeleton</span>
    <span class="n">d_sk</span> <span class="o">=</span> <span class="n">child_skeleton</span>
    
    <span class="n">up_sk_flipped</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">up_sk</span><span class="p">)</span>

    <span class="n">up_vec</span> <span class="o">=</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">d_vec_child</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">parent_child_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">up_vec</span><span class="p">,</span><span class="n">d_vec_child</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parent_child_angle</span></div>




<div class="viewcode-block" id="offset_skeletons_aligned_parent_child_skeletal_angle"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.offset_skeletons_aligned_parent_child_skeletal_angle">[docs]</a><span class="k">def</span> <span class="nf">offset_skeletons_aligned_parent_child_skeletal_angle</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">,</span><span class="n">skeleton_2</span><span class="p">,</span>
                                                        <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                                        <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                                        <span class="n">min_comparison_distance</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the parent child skeletal angle</span>
<span class="sd">    of 2 skeletons while using the offset and comparison distance</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">edge_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton_1</span><span class="p">,</span><span class="n">skeleton_2</span><span class="p">]</span>
    <span class="n">aligned_sk_parts</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">offset_skeletons_aligned_at_shared_endpoint</span><span class="p">(</span><span class="n">edge_skeletons</span><span class="p">,</span>
                                                                     <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                        <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                        <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">)</span>


    <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">parent_child_skeletal_angle</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">curr_angle</span></div>



<div class="viewcode-block" id="map_between_branches_lists"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.map_between_branches_lists">[docs]</a><span class="k">def</span> <span class="nf">map_between_branches_lists</span><span class="p">(</span><span class="n">branches_1</span><span class="p">,</span><span class="n">branches_2</span><span class="p">,</span><span class="n">check_all_matched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">min_to_match</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    Will create a unique mapping of a branch</span>
<span class="sd">    in the first list to the best fitting branch in the second</span>
<span class="sd">    in terms of the most matching coordinates with a distance of 0</span>
<span class="sd">    </span>
<span class="sd">    min_to_match is the number of vertices that must match in order to</span>
<span class="sd">    be considered for the matching </span>
<span class="sd">    Ex:</span>
<span class="sd">    cleaned_branches = sk.decompose_skeleton_to_branches(curr_limb_sk_cleaned)</span>
<span class="sd">    original_branches = [k.skeleton for k in curr_limb]</span>
<span class="sd">    map_between_branches_lists(original_branches,cleaned_branches)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_branches</span> <span class="o">=</span> <span class="n">branches_1</span>
    <span class="n">cleaned_branches</span> <span class="o">=</span> <span class="n">branches_2</span>
    
    <span class="n">reshape_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cleaned_branches</span><span class="p">]</span>
    <span class="n">reshaped_skeleton_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reshape_skeletons</span><span class="p">)])</span>
    <span class="n">stacked_reshaped_skeletons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">reshape_skeletons</span><span class="p">)</span>

    <span class="n">old_to_new_branch_mapping</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">o_br</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">original_branches</span><span class="p">):</span>
        <span class="n">o_br_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">o_br</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="n">zero_distance_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">o_br_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">stacked_reshaped_skeletons</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">zero_distance_branch_idx</span> <span class="o">=</span> <span class="n">reshaped_skeleton_labels</span><span class="p">[</span><span class="n">zero_distance_points</span><span class="p">]</span>

        <span class="n">n_matches</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">zero_distance_branch_idx</span><span class="o">==</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">br_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cleaned_branches</span><span class="p">)]</span>
        
        <span class="n">max_matched_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">n_matches</span><span class="p">)</span>
        <span class="n">max_matched_index_number</span> <span class="o">=</span> <span class="n">n_matches</span><span class="p">[</span><span class="n">max_matched_index</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">max_matched_index_number</span> <span class="o">&gt;=</span> <span class="n">min_to_match</span><span class="p">:</span>
            <span class="n">old_to_new_branch_mapping</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_matched_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_to_new_branch_mapping</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">old_to_new_branch_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_to_new_branch_mapping</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_all_matched</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">old_to_new_branch_mapping</span><span class="p">[</span><span class="n">old_to_new_branch_mapping</span><span class="o">!=-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not all of the new branches had at least one mapping&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old_to_new_branch_mapping</span></div>

<div class="viewcode-block" id="map_between_branches_lists_old"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.map_between_branches_lists_old">[docs]</a><span class="k">def</span> <span class="nf">map_between_branches_lists_old</span><span class="p">(</span><span class="n">branches_1</span><span class="p">,</span><span class="n">branches_2</span><span class="p">,</span><span class="n">check_all_matched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">min_to_match</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    Will create a unique mapping of a branch</span>
<span class="sd">    in the first list to the best fitting branch in the second</span>
<span class="sd">    in terms of the most matching coordinates with a distance of 0</span>
<span class="sd">    </span>
<span class="sd">    min_to_match is the number of vertices that must match in order to</span>
<span class="sd">    be considered for the matching </span>
<span class="sd">    Ex:</span>
<span class="sd">    cleaned_branches = sk.decompose_skeleton_to_branches(curr_limb_sk_cleaned)</span>
<span class="sd">    original_branches = [k.skeleton for k in curr_limb]</span>
<span class="sd">    map_between_branches_lists(original_branches,cleaned_branches)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_branches</span> <span class="o">=</span> <span class="n">branches_1</span>
    <span class="n">cleaned_branches</span> <span class="o">=</span> <span class="n">branches_2</span>
    
    <span class="n">cleaned_branches_endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cleaned_branches</span><span class="p">]</span>
    
    <span class="n">old_to_new_branch_mapping</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">o_br</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">original_branches</span><span class="p">):</span>
        <span class="n">o_br_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">o_br</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="c1">#n_matches = [len(np.where(o_br_kd.query(c_br.reshape(-1,3))[0]==0)[0]) for c_br in cleaned_branches]</span>
        <span class="n">n_matches</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">o_br_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">c_br</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">c_br</span> <span class="ow">in</span> <span class="n">cleaned_branches_endpoints</span><span class="p">]</span>
        
        <span class="n">max_matched_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">n_matches</span><span class="p">)</span>
        <span class="n">max_matched_index_number</span> <span class="o">=</span> <span class="n">n_matches</span><span class="p">[</span><span class="n">max_matched_index</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">max_matched_index_number</span> <span class="o">&gt;=</span> <span class="n">min_to_match</span><span class="p">:</span>
            <span class="n">old_to_new_branch_mapping</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_matched_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_to_new_branch_mapping</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">old_to_new_branch_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_to_new_branch_mapping</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_all_matched</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">old_to_new_branch_mapping</span><span class="p">[</span><span class="n">old_to_new_branch_mapping</span><span class="o">!=-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not all of the new branches had at least one mapping&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old_to_new_branch_mapping</span></div>



<span class="c1"># ---------------- 1/17: Helper function with the axon identification----- #</span>

<span class="c1"># ---------------- 12/23 -------------------- #</span>
<div class="viewcode-block" id="restrict_skeleton_from_start_plus_offset"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.restrict_skeleton_from_start_plus_offset">[docs]</a><span class="k">def</span> <span class="nf">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                               <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                            <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                                <span class="n">min_comparison_distance</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">start_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                             <span class="n">skeleton_resolution</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                                             <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will get a portion of the skeleton relative the start </span>
<span class="sd">    that </span>
<span class="sd">    1) subtracts off the offset</span>
<span class="sd">    2) keeps the next comparison distance length</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>

<span class="sd">    3) Use the restrict skeelton function to subtract the offset</span>
<span class="sd">    - if not then add whole skeleton to final skeleton</span>
<span class="sd">    4) if it was a sucess, see if the distance is greater than comparison distance</span>
<span class="sd">    - if not then add current skeleton to final</span>
<span class="sd">    5) Use the subtract skeleton to only keep the comparison distance of skeleton</span>
<span class="sd">    6) Add to final skeleton</span>

<span class="sd">    offset_skeletons_aligned_at_shared_endpoint()</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    vis_branches_idx = [7,9]</span>
<span class="sd">    vis_branches = [curr_limb[k] for k in vis_branches_idx]</span>
<span class="sd">    vis_branches</span>


<span class="sd">    curr_skeletons = [k.skeleton for k in vis_branches]</span>
<span class="sd">    stripped_skeletons = sk.offset_skeletons_aligned_at_shared_endpoint(curr_skeletons)</span>

<span class="sd">    curr_colors = [&quot;red&quot;,&quot;black&quot;]</span>
<span class="sd">    ipvu.plot_objects(meshes=[k.mesh for k in vis_branches],</span>
<span class="sd">                      meshes_colors=curr_colors,</span>
<span class="sd">                      skeletons=stripped_skeletons,</span>
<span class="sd">                      skeletons_colors=curr_colors,</span>
<span class="sd">                      scatters=[np.array([stripped_skeletons[0][-1][-1],stripped_skeletons[1][-1][-1]])],</span>
<span class="sd">                      scatter_size=1</span>
<span class="sd">                     )</span>


<span class="sd">    sk.parent_child_skeletal_angle(stripped_skeletons[1],stripped_skeletons[0])</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">start_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">start_coordinate</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">skeleton_resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">skeleton_resolution</span><span class="p">)</span>
    
    <span class="n">e</span> <span class="o">=</span> <span class="n">skeleton</span>
        
    <span class="c1"># -------- Making sure that we don&#39;t take off too much so it&#39;s just a spec</span>
    <span class="n">original_sk_length</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">original_sk_length</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">min_comparison_distance</span><span class="p">:</span>
        <span class="n">offset_adjusted</span> <span class="o">=</span> <span class="n">original_sk_length</span> <span class="o">-</span> <span class="n">min_comparison_distance</span>
        <span class="k">if</span> <span class="n">offset_adjusted</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">offset_adjusted</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#print(f&quot; Had to Adjust Offset to {offset_adjusted}&quot;)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">offset_adjusted</span>  <span class="o">=</span> <span class="n">offset</span>

    <span class="n">ret_sk</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">success</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">e</span><span class="p">,</span>
                                                       <span class="n">cutoff_distance</span> <span class="o">=</span> <span class="n">offset_adjusted</span><span class="p">,</span>
                                                       <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
        <span class="n">ret_sk</span> <span class="o">=</span> <span class="n">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">comparison_distance</span><span class="p">:</span>
            <span class="n">ret_sk</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">success</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">,</span>
                                                       <span class="n">cutoff_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                                       <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ended with empty skeleton at end so returning original skeleton&quot;</span><span class="p">)</span>
            
        <span class="n">ret_sk</span> <span class="o">=</span> <span class="n">skeleton</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret_sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                                 <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">ret_sk</span><span class="p">,</span><span class="n">skeleton</span><span class="p">],</span>
                                 <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span>
                                  <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">start_coordinate</span><span class="p">,</span><span class="n">ret_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ret_sk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                                  <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">],</span>
                                <span class="n">scatter_size</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span>
                                 <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No skeleton to plot&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">ret_sk</span></div>


<div class="viewcode-block" id="skeleton_endpoint_vector"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_endpoint_vector">[docs]</a><span class="k">def</span> <span class="nf">skeleton_endpoint_vector</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                             <span class="n">normalize_vector</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the vector made by the endpoints of a skeleton</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) if the starting coordinate is specified then order the skeleton </span>
<span class="sd">    according to that starting coordinate</span>
<span class="sd">    2) Get the endpoints of the skeleton</span>
<span class="sd">    3) Subtract the endpoints from each other (Normalize if requested)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">starting_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">restricted_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                                            <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">starting_coordinate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">restricted_skeleton</span> <span class="o">=</span> <span class="n">skeleton</span>
    
    <span class="n">restricted_skeleton_endpoints_sk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="n">restricted_skeleton_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">normalize_vector</span><span class="p">:</span>
        <span class="n">restricted_skeleton_vector</span> <span class="o">=</span> <span class="n">restricted_skeleton_vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">restricted_skeleton_vector</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">restricted_skeleton_vector</span></div>

    
    
<span class="c1"># ----------- 1 /21  -------------------- #</span>
<div class="viewcode-block" id="high_degree_coordinates_on_path"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.high_degree_coordinates_on_path">[docs]</a><span class="k">def</span> <span class="nf">high_degree_coordinates_on_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">curr_path_to_cut</span><span class="p">,</span>
                                   <span class="n">degree_to_check</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find coordinates on a skeleton of the path speciifed (in terms of node ids)</span>
<span class="sd">    that are above the degree_to_check (in reference to the skeleton)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_divergent_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_path_to_cut</span><span class="p">]</span>
    <span class="n">endpoint_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">path_divergent_points</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">limb_sk_gr</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">endpoint_degrees</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_degree</span><span class="p">(</span><span class="n">limb_sk_gr</span><span class="p">,</span><span class="n">endpoint_coordinates</span><span class="p">)</span>
    <span class="n">high_degree_endpoint_coordinates</span> <span class="o">=</span> <span class="n">endpoint_coordinates</span><span class="p">[</span><span class="n">endpoint_degrees</span><span class="o">&gt;=</span><span class="n">degree_to_check</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">high_degree_endpoint_coordinates</span></div>


<span class="c1"># ---------- 2/15: Help with Getting path from synapses from to soma ------- #</span>



<div class="viewcode-block" id="skeleton_path_between_skeleton_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_path_between_skeleton_coordinates">[docs]</a><span class="k">def</span> <span class="nf">skeleton_path_between_skeleton_coordinates</span><span class="p">(</span><span class="n">starting_coordinate</span><span class="p">,</span>
                                               <span class="n">destination_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skeleton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skeleton_graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">destination_node</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">only_skeleton_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">plot_skeleton_path</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">return_singular_node_path_if_no_path</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>

<span class="sd">    Purpose: To find the skeleton_path_between two coordinates (that lie on a skeleton)</span>
<span class="sd">    (can just request the distances and not the path)</span>


<span class="sd">    Pseudocode:</span>
<span class="sd">    0) Convert the skeleton into a graph</span>
<span class="sd">    1) Find the graph node of the destination coordinate</span>
<span class="sd">    2) For each coordinate:</span>
<span class="sd">    - find the node in the skeleton graph</span>

<span class="sd">    a. if skeleton path is requested</span>
<span class="sd">    - find the shortest path between the start and destiation node (and convert )</span>
<span class="sd">    - find the shortest path length between start node and destination node</span>

<span class="sd">    b. if only skeleton distance is requested</span>
<span class="sd">    - find shortest path distance between 2 nodes</span>

<span class="sd">    3) return list of skeleton paths or skeleton path distances</span>


<span class="sd">    Ex:</span>
<span class="sd">    skeleton_path_between_skeleton_coordinates(</span>
<span class="sd">            #skeleton = filtered_neuron[0].skeleton,</span>
<span class="sd">    skeleton = None,</span>
<span class="sd">            starting_coordinate = skeleton[[10000]].reshape(-1,3),</span>

<span class="sd">            destination_coordinate = None,</span>
<span class="sd">            skeleton_graph = limb_graphs[0],</span>
<span class="sd">            destination_node = 15310,</span>
<span class="sd">            only_skeleton_distance = False,</span>
<span class="sd">            plot_skeleton_path = True,</span>
<span class="sd">            verbose = True,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#0) Convert the skeleton into a graph</span>
    <span class="k">if</span> <span class="n">skeleton_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skeleton Graph: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#1) Find the graph node of the destination coordinate</span>
    <span class="k">if</span> <span class="n">destination_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">destination_node</span><span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span>
                                                                        <span class="n">destination_coordinate</span><span class="p">,</span>
                                                                        <span class="n">return_single_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;destination_node: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;destination_node= </span><span class="si">{</span><span class="n">destination_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">singular_output_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">starting_coordinate</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">singular_output_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="p">[</span><span class="n">starting_coordinate</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2) For each coordinate:</span>
<span class="sd">    - find the node in the skeleton graph</span>

<span class="sd">    a. if skeleton path is requested</span>
<span class="sd">    - find the shortest path between the start and destiation node (and convert to a skeleton)</span>

<span class="sd">    b. if only skeleton distance is requested</span>
<span class="sd">    - find shortest path distance between 2 nodes</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_skeleton_path</span> <span class="ow">and</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_skeleton_path</span> <span class="ow">and</span> <span class="n">destination_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">destination_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span>
                                                                <span class="n">destination_node</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">st_coord</span> <span class="ow">in</span> <span class="n">starting_coordinate</span><span class="p">:</span>
        <span class="n">st_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span>
                                                    <span class="n">st_coord</span><span class="p">,</span>
                                                    <span class="n">return_single_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;st_node: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">only_skeleton_distance</span><span class="p">:</span>
            <span class="c1"># how to generate the shortest path length</span>
            <span class="n">shortest_path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span>
                                       <span class="n">st_node</span><span class="p">,</span>
                                       <span class="n">destination_node</span><span class="p">,</span>
                                       <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shortest_path_length</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path_length = </span><span class="si">{</span><span class="n">shortest_path_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path_length: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">skeleton_graph</span><span class="p">,</span>
                            <span class="n">st_node</span><span class="p">,</span>
                            <span class="n">destination_node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path = </span><span class="si">{</span><span class="n">shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">curr_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span>
                    <span class="n">skeleton_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">return_singular_node_path_if_no_path</span><span class="p">:</span>
                <span class="n">curr_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="n">starting_coordinate</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_skeleton_path</span><span class="p">:</span>
                <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                                 <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">curr_skeleton</span><span class="p">],</span>
                                 <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                 <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">st_coord</span><span class="p">,</span><span class="n">destination_coordinate</span><span class="p">],</span>
                                 <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span>
                                 <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                
    <span class="k">if</span> <span class="n">singular_output_flag</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;whole time: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">total_st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="closest_skeleton_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.closest_skeleton_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_skeleton_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                               <span class="n">coordinate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: will map a coordinate to the closest skeleton coordinate</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Turn the skeleton into a KDTree of coordinates</span>
<span class="sd">    2) Find the closest coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeleton_points</span> <span class="o">=</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">skeleton_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_coord</span> <span class="o">=</span> <span class="n">skeleton_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">skeleton_points</span><span class="p">[</span><span class="n">closest_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>

<div class="viewcode-block" id="kd_tree_from_unique_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.kd_tree_from_unique_coordinates">[docs]</a><span class="k">def</span> <span class="nf">kd_tree_from_unique_coordinates</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="n">unique_coords</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_unique_coordinates</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">unique_coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="closest_skeleton_coordinates"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.closest_skeleton_coordinates">[docs]</a><span class="k">def</span> <span class="nf">closest_skeleton_coordinates</span><span class="p">(</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">skeleton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skeleton_coordinates</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_distances</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: will map a coordinate to the closest skeleton coordinate</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Turn the skeleton into a KDTree of coordinates</span>
<span class="sd">    2) Find the closest coordinate</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.closest_skeleton_coordinates(</span>
<span class="sd">        restr_skeleton,</span>
<span class="sd">        coordinates = soma_center,</span>
<span class="sd">        plot = True,</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        radius = 50_000,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">skeleton_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_coords</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_unique_coordinates</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">skeleton_coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">unique_coords</span><span class="p">)</span>
        <span class="n">total_dists</span><span class="p">,</span><span class="n">closest_coords_idx</span> <span class="o">=</span> <span class="n">skeleton_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
        
        <span class="n">closest_coords_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">closest_coords_idx</span><span class="p">)</span>
        <span class="n">closest_coords</span> <span class="o">=</span> <span class="n">unique_coords</span><span class="p">[</span><span class="n">closest_coords_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">closest_coords_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unique_coords</span><span class="o">-</span><span class="n">c</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">closest_coords_idx_curr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_coords_idx_curr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">closest_coords_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_coords_idx_curr</span><span class="p">)</span>
                <span class="n">total_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">closest_coords_idx_curr</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_coords_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">closest_coords_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">closest_coords_idx</span><span class="p">)</span>
            <span class="n">total_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">total_dists</span><span class="p">)</span>
            <span class="n">closest_coords_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">closest_coords_idx</span><span class="p">)</span>
            
        
            
        <span class="n">closest_coords</span> <span class="o">=</span> <span class="n">unique_coords</span><span class="p">[</span><span class="n">closest_coords_idx</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of coordinates found = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">closest_coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
<span class="c1">#     if len(closest_coords) == 0:</span>
<span class="c1">#         raise Exception(&quot;&quot;)</span>
        
    <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coord_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="n">skeleton_coord_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinates = </span><span class="si">{</span><span class="n">coord_color</span><span class="si">}</span><span class="s2">, found skeleton colors = </span><span class="si">{</span><span class="n">skeleton_coord_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
            <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinates</span><span class="p">,</span><span class="n">closest_coords</span><span class="p">],</span>
            <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_color</span><span class="p">,</span><span class="n">skeleton_coord_color</span><span class="p">]</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_coords_idx</span>
    
    <span class="k">if</span> <span class="n">return_distances</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_dists</span>
        
    <span class="k">return</span> <span class="n">closest_coords</span></div>
        
    

<div class="viewcode-block" id="high_degree_coordinates_on_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.high_degree_coordinates_on_skeleton">[docs]</a><span class="k">def</span> <span class="nf">high_degree_coordinates_on_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                       <span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                             <span class="n">exactly_equal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">plot_high_degree_points</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the high degree coordinates on a skeleton</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">limb_sk_gr</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="c1">#3) Find all nodes with a degree above five</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exactly_equal</span><span class="p">:</span>
        <span class="n">curr_high_degree_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_greater_or_equal_degree_k</span><span class="p">(</span><span class="n">limb_sk_gr</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_high_degree_nodes for get_nodes_greater_or_equal_degree_k = </span><span class="si">{</span><span class="n">curr_high_degree_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_high_degree_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">limb_sk_gr</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_high_degree_nodes for get_nodes_of_degree_k = </span><span class="si">{</span><span class="n">curr_high_degree_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_high_degree_nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

        <span class="c1">#4) Get the coordinates of all of those nodes</span>
        <span class="n">curr_high_degree_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">limb_sk_gr</span><span class="p">,</span><span class="n">curr_high_degree_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_high_degree_coordinates = </span><span class="si">{</span><span class="n">curr_high_degree_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_high_degree_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
            
            
    <span class="k">if</span> <span class="n">plot_high_degree_points</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_high_degree_coordinates</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** No HIGH DEGREE COORDINATES TO PLOT ****&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton</span><span class="p">],</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="n">curr_high_degree_coordinates</span><span class="p">,</span>
                             <span class="n">scatters_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                             <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">curr_high_degree_coordinates</span></div>
    
    
<div class="viewcode-block" id="shortest_path_between_two_sets_of_skeleton_coordiantes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.shortest_path_between_two_sets_of_skeleton_coordiantes">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_between_two_sets_of_skeleton_coordiantes</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">coordinates_list_1</span><span class="p">,</span>
        <span class="n">coordinates_list_2</span><span class="p">,</span>
        <span class="n">return_closest_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_path_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_closest_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
        <span class="n">G</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find the shortest skeleton path between 2 sets</span>
<span class="sd">    of skeleton coordinates</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) convert the skeleton into a graph</span>
<span class="sd">    2) Find the nodes of the skeleton coordinates in both groups</span>
<span class="sd">    3) Find the shortest path between the nodes (along with the winning nodes)</span>
<span class="sd">    4) Find the coordinates of these end nodes (if just asked for this return here)</span>
<span class="sd">    5) Get a subgraph of the shortest path and convert back into a skeleton</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    shortest_path_between_two_sets_of_skeleton_coordiantes(</span>
<span class="sd">                    skeleton = limb_skeleton,</span>
<span class="sd">                    coordinates_list_1 = [starting_coordinate],</span>
<span class="sd">                    coordinates_list_2 = closest_branch_endpoints,</span>
<span class="sd">                    return_closest_coordinates = True,</span>
<span class="sd">                    plot_closest_coordinates = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>



    <span class="n">coordinates_list_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates_list_1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">coordinates_list_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates_list_2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#1) convert the skeleton into a graph</span>
    <span class="k">if</span> <span class="n">G</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sk_graph</span> <span class="o">=</span> <span class="n">G</span>

    <span class="c1">#2) Find the nodes of the skeleton coordinates in both groups</span>
    <span class="n">coordinates_list_1_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_nodes_by_coordinates</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">coordinates_list_1</span><span class="p">)</span>
    <span class="n">coordinates_list_2_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_nodes_by_coordinates</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">coordinates_list_2</span><span class="p">)</span>

    <span class="c1">#3) Find the shortest path between the nodes (along with the winning nodes)</span>
    <span class="n">path</span><span class="p">,</span><span class="n">node_1</span><span class="p">,</span><span class="n">node_2</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span>
        <span class="n">sk_graph</span><span class="p">,</span>
        <span class="n">coordinates_list_1_nodes</span><span class="p">,</span>
        <span class="n">coordinates_list_2_nodes</span><span class="p">,</span>
        <span class="n">return_path_distance</span><span class="o">=</span><span class="n">return_path_distance</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_path_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="n">shortest_skeleton_path</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">return_closest_coordinates</span><span class="p">:</span>
        <span class="n">node_1_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">node_1</span><span class="p">)</span>
        <span class="n">node_2_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">node_2</span><span class="p">)</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_1_coordinate</span><span class="p">,</span><span class="n">node_2_coordinate</span> <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">plot_closest_coordinates</span><span class="p">:</span>
            <span class="n">node_1_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">node_1</span><span class="p">)</span>
            <span class="n">node_2_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">,</span><span class="n">node_2</span><span class="p">)</span>
        <span class="n">sk_graph_subgraph</span> <span class="o">=</span> <span class="n">sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">shortest_skeleton_path</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">sk_graph_subgraph</span><span class="p">)</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">shortest_skeleton_path</span>

    <span class="k">if</span> <span class="n">plot_closest_coordinates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">shortest_skeleton_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sk_graph_subgraph</span> <span class="o">=</span> <span class="n">sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">shortest_skeleton_path</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">sk_graph_subgraph</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">sk_graph</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">shortest_skeleton_path</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">node_1_coordinate</span><span class="p">,</span><span class="n">node_2_coordinate</span><span class="p">],</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lime&quot;</span><span class="p">,</span><span class="s2">&quot;black&quot;</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        
    
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="restrict_skeleton_to_distance_from_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.restrict_skeleton_to_distance_from_coordinate">[docs]</a><span class="k">def</span> <span class="nf">restrict_skeleton_to_distance_from_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                                     <span class="n">coordinate</span><span class="p">,</span>
                                                 <span class="n">distance_threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose:</span>
<span class="sd">    To restrict a skeleton to only those points within a certain distance</span>
<span class="sd">    of a starting coordinate</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    retr_skeleton = sk.restrict_skeleton_to_distance_from_coordinate(neuron_obj[0].skeleton,</span>
<span class="sd">                                                 neuron_obj[0].current_starting_coordinate,</span>
<span class="sd">                                                 10000,)</span>
<span class="sd">    ipvu.plot_objects(main_skeleton=neuron_obj[0].skeleton,</span>
<span class="sd">                     skeletons=[restr_skeleton],</span>
<span class="sd">                     skeletons_colors=&quot;red&quot;)     </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidate_sk</span> <span class="o">=</span> <span class="n">skeleton</span>
    <span class="n">starting_sk_coord</span> <span class="o">=</span> <span class="n">coordinate</span>
    
    <span class="c1">#1) Convert skeleton to graph</span>
    
    <span class="n">candidate_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">candidate_sk</span><span class="p">)</span>
    
    <span class="c1">#2) Find all skeleton points that are within a certain distance of the starting coordinate</span>
    <span class="n">starting_sk_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">candidate_sk_graph</span><span class="p">,</span><span class="n">starting_sk_coord</span><span class="p">)</span>
    <span class="n">skeletons_nodes_for_comparison</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span>
        <span class="n">candidate_sk_graph</span><span class="p">,</span>
        <span class="n">starting_sk_node</span><span class="p">,</span>
        <span class="n">distance_threshold</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">skeletons_nodes_for_comparison</span><span class="p">))</span>
    <span class="n">comparison_subgraph</span> <span class="o">=</span> <span class="n">candidate_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">skeletons_nodes_for_comparison</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="p">)</span></div>


<div class="viewcode-block" id="skeleton_coordinate_offset_from_endpoint"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_coordinate_offset_from_endpoint">[docs]</a><span class="k">def</span> <span class="nf">skeleton_coordinate_offset_from_endpoint</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                            <span class="n">endpoint_coordinate</span><span class="p">,</span>
                                             <span class="n">offset_distance</span><span class="p">,</span>
                                             <span class="n">plot_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">return_success</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return a skeleton coordinate</span>
<span class="sd">    that is a certain distance offset from an endpoint coordinate</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    new_point = skeleton_coordinate_offset_from_endpoint(v_skeleton,</span>
<span class="sd">                                        coord,</span>
<span class="sd">                                        #offset_distance=offset_distance_for_points,</span>
<span class="sd">                                        offset_distance=50000,</span>
<span class="sd">                                        verbose=True,</span>
<span class="sd">                                                    plot_coordinate=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                 <span class="n">endpoint_coordinate</span><span class="p">)</span>
    
    <span class="n">restr_skeleton</span><span class="p">,</span><span class="n">success</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="c1">#.reshape(-1,2,3),</span>
                            <span class="n">cutoff_distance</span><span class="o">=</span><span class="n">offset_distance</span><span class="p">,</span>
                           <span class="n">subtract_cutoff</span><span class="o">=</span><span class="n">subtract_cutoff</span><span class="p">,</span>
                                            <span class="n">return_indexes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
        <span class="n">curr_point</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_point</span> <span class="o">=</span> <span class="n">restr_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Restriction of skeleton by </span><span class="si">{</span><span class="n">offset_distance</span><span class="si">}</span><span class="s2"> was success = </span><span class="si">{</span><span class="n">success</span><span class="si">}</span><span class="s2">&quot;</span>
             <span class="sa">f</span><span class="s2">&quot; and point is </span><span class="si">{</span><span class="n">curr_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_coordinate</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">skeleton</span><span class="p">],</span>
                 <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">endpoint_coordinate</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                          <span class="n">curr_point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">return_success</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_point</span><span class="p">,</span><span class="n">success</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_point</span></div>

<div class="viewcode-block" id="shared_coordiantes"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.shared_coordiantes">[docs]</a><span class="k">def</span> <span class="nf">shared_coordiantes</span><span class="p">(</span><span class="n">skeletons</span><span class="p">,</span><span class="n">return_one</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the shared coordinates by skeletons</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_coords</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersect2d_multi_list</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skeletons</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_one</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s_coords</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of shared coordinates was not one: </span><span class="si">{</span><span class="n">s_coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
        
        
<div class="viewcode-block" id="skeleton_coordinate_path_from_start"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_coordinate_path_from_start">[docs]</a><span class="k">def</span> <span class="nf">skeleton_coordinate_path_from_start</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
    <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: will just give vertex path</span>
<span class="sd">    of skeleton from the first </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start_endpoint_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">start_endpoint_coordinate</span><span class="p">)</span>
    <span class="n">ordered_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">skeleton</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">ordered_path</span></div>


<div class="viewcode-block" id="skelton_coordinate_path_to_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skelton_coordinate_path_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">skelton_coordinate_path_to_skeleton</span><span class="p">(</span><span class="n">skeleton_coordinate_path</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">skeleton_coordinate_path</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span></div>


<div class="viewcode-block" id="closest_distances_from_skeleton_vertices_to_base_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.closest_distances_from_skeleton_vertices_to_base_skeleton">[docs]</a><span class="k">def</span> <span class="nf">closest_distances_from_skeleton_vertices_to_base_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                                               <span class="n">base_skeleton</span><span class="p">,</span>
                                                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                              <span class="n">plot_min_pair</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purposes: To measure the distance from one skeleton&#39;s vertices</span>
<span class="sd">    to the closest vertices on a base skeleton</span>
<span class="sd">    </span>
<span class="sd">    Application: To help determine if a merge</span>
<span class="sd">    error has occured where the skeletons pass too close</span>
<span class="sd">    to each other</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.closest_distances_from_skeleton_vertices_to_base_skeleton(new_sks[0],</span>
<span class="sd">                                                          new_sks[1],</span>
<span class="sd">                                                          verbose= True,</span>
<span class="sd">                                                          plot_min_pair=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk1_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">base_skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sk2_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sk1_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sk1_coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">dist</span><span class="p">,</span> <span class="n">closest_index</span> <span class="o">=</span> <span class="n">sk1_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sk2_coords</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Min of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span><span class="si">}</span><span class="s2"> dist = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_min_pair</span><span class="p">:</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">sk2_min_coord</span> <span class="o">=</span> <span class="n">sk2_coords</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
        <span class="n">sk1_min_coord</span> <span class="o">=</span> <span class="n">sk1_coords</span><span class="p">[</span><span class="n">closest_index</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]]</span>
        
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton</span><span class="p">,</span><span class="n">base_skeleton</span><span class="p">],</span>
                          <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">sk2_min_coord</span><span class="p">,</span><span class="n">sk1_min_coord</span><span class="p">],</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="resize_skeleton_with_branching"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.resize_skeleton_with_branching">[docs]</a><span class="k">def</span> <span class="nf">resize_skeleton_with_branching</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">segment_width</span><span class="p">,</span>
    <span class="n">optimal_speed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To resize a skeleton that may have</span>
<span class="sd">    some branching points</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Decompose the skeleton into segments</span>
<span class="sd">    2) Resize all of the skeleton segments</span>
<span class="sd">    3) Recompose the skeleton</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">sk_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">sk_branches_resized</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">segment_width</span><span class="o">=</span><span class="n">segment_width</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_branches</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">optimal_speed</span><span class="p">:</span>
        <span class="n">return_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">sk_branches_resized</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_sk</span> <span class="o">=</span>  <span class="n">sk</span><span class="o">.</span><span class="n">recompose_skeleton_from_branches</span><span class="p">(</span><span class="n">sk_branches_resized</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for resize_skeleton_with_branching = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">return_sk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_sk</span></div>

<span class="c1"># --------- 7/29: helped with apical classifications ---------- #</span>
<div class="viewcode-block" id="order_resize_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.order_resize_skeleton">[docs]</a><span class="k">def</span> <span class="nf">order_resize_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                          <span class="n">start_endpoint_coordinate</span><span class="p">,</span>
                         <span class="n">segment_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">n_segments</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To order a skeleton and then resize it</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.order_resize_skeleton(branch_obj.skeleton,</span>
<span class="sd">                         nru.upstream_endpoint(limb_obj,branch_idx),</span>
<span class="sd">                         skeleton_resize_distance,</span>
<span class="sd">                         plot_skeleton=True</span>
<span class="sd">                        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_ord</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span> 
                               <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="n">start_endpoint_coordinate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">segment_width</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_segments</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sk_ord_resize</span> <span class="o">=</span> <span class="n">sk_ord</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sk_ord_resize</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">sk_ord</span><span class="p">,</span>
                                                 <span class="n">segment_width</span><span class="o">=</span><span class="n">segment_width</span><span class="p">,</span>
                                                 <span class="n">n_segments</span><span class="o">=</span><span class="n">n_segments</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">sk_ord_resize</span><span class="p">],</span>
                     <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">sk_ord_resize</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                     <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">scatters_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sk_ord_resize</span></div>

<div class="viewcode-block" id="skeleton_vectors"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_vectors">[docs]</a><span class="k">def</span> <span class="nf">skeleton_vectors</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                    <span class="n">start_endpoint_coordinate</span><span class="p">,</span>
                    <span class="n">segment_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">n_segments</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">plot_skeleton</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get skeleton vectors of a reshaped and ordered skeleton</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branch_sk_ord_resized</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_resize_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                         <span class="n">start_endpoint_coordinate</span><span class="p">,</span>
                         <span class="n">segment_width</span><span class="o">=</span><span class="n">segment_width</span><span class="p">,</span>
                        <span class="n">n_segments</span><span class="o">=</span><span class="n">n_segments</span><span class="p">,</span>
                         <span class="n">plot_skeleton</span><span class="o">=</span><span class="n">plot_skeleton</span>
                        <span class="p">)</span>
    <span class="n">skeleton_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">skeleton_endpoint_vector</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_sk_ord_resized</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">skeleton_vectors</span></div>

<div class="viewcode-block" id="angle_between_skeleton_vectors_and_ref_vector"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.angle_between_skeleton_vectors_and_ref_vector">[docs]</a><span class="k">def</span> <span class="nf">angle_between_skeleton_vectors_and_ref_vector</span><span class="p">(</span><span class="n">reference_vector</span><span class="p">,</span>
    <span class="n">skeleton_vectors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">segment_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
     <span class="n">n_segments</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
     <span class="n">plot_skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the angles between a reference </span>
<span class="sd">    vector and certain skeleton vectors created </span>
<span class="sd">    by sections of a skeleton that has</span>
<span class="sd">    been ordered and reshaped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">skeleton_vectors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sk_vectors</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_vectors</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                         <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">start_endpoint_coordinate</span><span class="p">,</span>
                         <span class="n">segment_width</span><span class="o">=</span><span class="n">segment_width</span><span class="p">,</span>
                        <span class="n">n_segments</span><span class="o">=</span><span class="n">n_segments</span><span class="p">,</span>           
                            <span class="n">plot_skeleton</span><span class="o">=</span><span class="n">plot_skeleton</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">reference_vector</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_vectors</span><span class="p">])</span></div>

<div class="viewcode-block" id="percentage_skeleton_match_to_ref_vector"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.percentage_skeleton_match_to_ref_vector">[docs]</a><span class="k">def</span> <span class="nf">percentage_skeleton_match_to_ref_vector</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                         <span class="n">reference_vector</span><span class="p">,</span>
                                        <span class="n">max_angle</span><span class="p">,</span>
                                        <span class="n">min_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="c1">#arguments for computing the vectors</span>
                                          <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">segment_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">n_segments</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">plot_skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             
                                             <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                          <span class="c1">#argmuments for what will be returned</span>
                                             <span class="n">return_match_length</span> <span class="o">=</span> <span class="kc">False</span>
                                         <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the percentage (and distance) that match angle requirements to a given vector</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.percentage_skeleton_match_to_ref_vector(branch_obj.skeleton,</span>
<span class="sd">                                          reference_vector=reference_vector,</span>
<span class="sd">                                           max_angle=angle_threshold,</span>
<span class="sd">                                          start_endpoint_coordinate=nru.upstream_endpoint(limb_obj,branch_idx),</span>
<span class="sd">                                        segment_width=skeleton_resize_distance,</span>
<span class="sd">                                         plot_skeleton=True,</span>
<span class="sd">                                          verbose=True,</span>
<span class="sd">                                          return_match_length = True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_angles_between_ref_vector</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">angle_between_skeleton_vectors_and_ref_vector</span><span class="p">(</span><span class="n">reference_vector</span><span class="p">,</span>
                                                                                    <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                                                                                   <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">start_endpoint_coordinate</span><span class="p">,</span>
                         <span class="n">segment_width</span><span class="o">=</span><span class="n">segment_width</span><span class="p">,</span>
                        <span class="n">n_segments</span><span class="o">=</span><span class="n">n_segments</span><span class="p">,</span>           
                            <span class="n">plot_skeleton</span><span class="o">=</span><span class="n">plot_skeleton</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">min_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">max_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
    <span class="n">skeleton_segment_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">sk_angles_between_ref_vector</span> <span class="o">&gt;</span> <span class="n">min_angle</span><span class="p">)</span> <span class="o">&amp;</span> 
                                 <span class="p">(</span><span class="n">sk_angles_between_ref_vector</span> <span class="o">&lt;</span> <span class="n">max_angle</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_angles_between_ref_vector = </span><span class="si">{</span><span class="n">sk_angles_between_ref_vector</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;with min_angle = </span><span class="si">{</span><span class="n">min_angle</span><span class="si">}</span><span class="s2"> and max_angle = </span><span class="si">{</span><span class="n">max_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of matches = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_segment_matches</span><span class="p">)</span><span class="si">}</span><span class="s2"> : skeleton_segment_matches = </span><span class="si">{</span><span class="n">skeleton_segment_matches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">perc_match</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_segment_matches</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">sk_angles_between_ref_vector</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_match = </span><span class="si">{</span><span class="n">perc_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_match_length</span><span class="p">:</span>
        <span class="n">match_length</span> <span class="o">=</span> <span class="n">perc_match</span><span class="o">*</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_length = </span><span class="si">{</span><span class="n">match_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">perc_match</span><span class="p">,</span><span class="n">match_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">perc_match</span></div>
    
    
<div class="viewcode-block" id="bounding_box_corners"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.bounding_box_corners">[docs]</a><span class="k">def</span> <span class="nf">bounding_box_corners</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the minimum and maximum </span>
<span class="sd">    coordinates of the skeleton bounding box</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_nodes</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">min_max_3D_coordinates</span><span class="p">(</span><span class="n">sk_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="bbox_volume"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.bbox_volume">[docs]</a><span class="k">def</span> <span class="nf">bbox_volume</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
    <span class="n">sk_nodes</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">bounding_box_volume</span><span class="p">(</span><span class="n">sk_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordinates_along_skeleton_offset_from_start"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.coordinates_along_skeleton_offset_from_start">[docs]</a><span class="k">def</span> <span class="nf">coordinates_along_skeleton_offset_from_start</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">starting_coordinate</span><span class="p">,</span>
    <span class="n">n_points</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_starting_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_restricted_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_points</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate a certain number of points from the start of a skeleton.</span>
<span class="sd">    Ideally the points are a certain distance away from the start , but if there</span>
<span class="sd">    is not enough distance to do this then just space the points out as much as possible</span>

<span class="sd">    Pseudocode:  </span>
<span class="sd">    1) Restrict the skeleton to n_points*offset from the start</span>
<span class="sd">    For the number of points going to take</span>
<span class="sd">    2) Resize the skeleton</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from mesh_tools import skeleton_utils as sk</span>
<span class="sd">    from python_tools import numpy_dep as np</span>


<span class="sd">    skeleton = neuron_obj[0][42].skeleton</span>
<span class="sd">    starting_coordinate =  neuron_obj[0].current_starting_coordinate</span>


<span class="sd">    sk.coordinates_along_skeleton_offset_from_start(</span>
<span class="sd">    skeleton,</span>
<span class="sd">    starting_coordinate,</span>
<span class="sd">        offset = 3000,</span>
<span class="sd">        n_points = 10,</span>
<span class="sd">        plot_points=True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># skeleton = sk.resize_skeleton_branch(skeleton,</span>
    <span class="c1">#                                     segment_width = 20)</span>

    <span class="k">if</span> <span class="n">plot_starting_skeleton</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton distance = </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">skeleton_rest</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">cutoff_distance</span> <span class="o">=</span> <span class="n">n_points</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span>
        <span class="n">return_indexes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_success</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">resize_skeleton_to_help_success</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">starting_coordinate</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">curr_skeleton_dist</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton_rest</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_rest distance = </span><span class="si">{</span><span class="n">curr_skeleton_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_restricted_skeleton</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
                          <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton_rest</span><span class="p">],</span>
                          <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


    <span class="c1">#skeleton_rest_resize = sk.resize_skeleton_branch(skeleton_rest,n_segments=n_points)</span>
    <span class="n">skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span>
        <span class="n">skeleton_rest</span><span class="p">,</span>
        <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="n">starting_coordinate</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1">#print(f&quot;skeleton_ordered  = {skeleton_ordered}&quot;)</span>
    <span class="c1">#Simpler method: Could maybe skip this process with the following; </span>
    <span class="n">new_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">skeleton_ordered</span><span class="p">,</span>
                                       <span class="n">n_segments</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span>
                                      <span class="p">)</span>
    <span class="c1">#print(f&quot;new_sk = {new_sk}&quot;)</span>
    <span class="k">if</span> <span class="n">n_points</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">points_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">points_array</span> <span class="o">=</span> <span class="n">new_sk</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1">#points_array = sk.convert_skeleton_to_nodes(new_sk[1:])</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    #calculate the middle points</span>
<span class="sd">    last_point = skeleton_ordered[-1][-1]</span>
<span class="sd">    points_array = []</span>
<span class="sd">    new_offset = curr_skeleton_dist/n_points</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;New offset = {new_offset}&quot;)</span>

<span class="sd">    curr_skeleton = skeleton_ordered</span>
<span class="sd">    for i in range(1,n_points):</span>
<span class="sd">        curr_rest = sk.restrict_skeleton_from_start_plus_offset(</span>
<span class="sd">        skeleton = skeleton,</span>
<span class="sd">        offset = i*new_offset,</span>
<span class="sd">        min_comparison_distance = 0,</span>
<span class="sd">        start_coordinate = starting_coordinate,</span>
<span class="sd">        skeleton_resolution = 10,</span>
<span class="sd">        comparison_distance = np.inf</span>
<span class="sd">        )</span>


<span class="sd">        print(sk.calculate_skeleton_distance(curr_rest))</span>

<span class="sd">        new_point = curr_rest[0][0]</span>
<span class="sd">        curr_skeleton = curr_rest</span>
<span class="sd">        points_array.append(new_point)</span>

<span class="sd">    points_array.append(last_point)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">plot_points</span><span class="p">:</span>
        <span class="n">start_point_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="n">points_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_point_color = </span><span class="si">{</span><span class="n">start_point_color</span><span class="si">}</span><span class="s2">, points_color = </span><span class="si">{</span><span class="n">points_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
                      <span class="c1">#skeletons = [skeleton_rest],</span>
                      <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
                     <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="n">points_array</span><span class="p">],</span>
                      <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="n">start_point_color</span><span class="p">,</span>
                                       <span class="n">points_color</span><span class="p">],</span>
                     <span class="n">scatter_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of points layed down = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">points_array</span><span class="p">)</span><span class="si">}</span><span class="s2"> (desired </span><span class="si">{</span><span class="n">n_points</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">points_array</span></div>


<div class="viewcode-block" id="skeleton_from_h5py"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.skeleton_from_h5py">[docs]</a><span class="k">def</span> <span class="nf">skeleton_from_h5py</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hf</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">hf</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">][()]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">hf</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][()]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="n">skeleton_manual</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton shape = </span><span class="si">{</span><span class="n">skeleton_manual</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">skeleton_manual</span></div>



<div class="viewcode-block" id="mesh_subtraction_by_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.mesh_subtraction_by_skeleton">[docs]</a><span class="k">def</span> <span class="nf">mesh_subtraction_by_skeleton</span><span class="p">(</span>

    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">,</span>

    <span class="n">buffer</span><span class="o">=</span><span class="n">mesh_subtraction_buffer_default</span><span class="p">,</span>
    <span class="n">bbox_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#,1.2</span>
    <span class="n">distance_threshold</span><span class="o">=</span><span class="n">mesh_subtraction_distance_threshold_default</span><span class="p">,</span>
    <span class="n">resize_length</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">initial_plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">edge_idx_to_process</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_loop_print</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">edge_loop_plotting_slice</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">edge_loop_plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>


    <span class="n">edge_length_to_process</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">submesh_face_min</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>

    <span class="n">edge_loop_plot_winning_faces</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_subtracted_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">plot_final_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">final_split_n_faces_min</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="p">):</span>



<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return significant mesh pieces that are</span>
<span class="sd">        not already accounteed for by the skeleton</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Restrict the mesh with a bounding box if requested</span>
<span class="sd">    2) Optionally downsample the skeleton</span>
<span class="sd">    Iterate through all of the edges in skeleton and find matching faces</span>
<span class="sd">    3) Concatenate into one mesh</span>
<span class="sd">    </span>
<span class="sd">    ------Example 1:-----</span>
<span class="sd">    segment_id = 31504318800</span>

<span class="sd">    neuron_obj = hdju.neuron_obj_from_table(</span>
<span class="sd">        segment_id=segment_id,</span>
<span class="sd">        table = h01auto.Decomposition.Object(),</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        return_one=True,</span>
<span class="sd">    )</span>

<span class="sd">    from neurd import neuron_visualizations as nviz</span>
<span class="sd">    nviz.visualize_neuron(neuron_obj,limb_branch_dict=&quot;all&quot;)</span>


<span class="sd">    ret_mesh = sk.mesh_subtraction_by_skeleton(</span>

<span class="sd">        mesh = neuron_obj[0].mesh,</span>
<span class="sd">        edges = neuron_obj[0][3].skeleton,</span>

<span class="sd">        buffer=2000,</span>
<span class="sd">        bbox_ratio=None,#,1.2</span>
<span class="sd">        distance_threshold=8_000,</span>
<span class="sd">        resize_length = 2000,</span>
<span class="sd">        verbose =True,</span>
<span class="sd">        initial_plotting = False,</span>

<span class="sd">        #edge_idx_to_process = [0,3],</span>
<span class="sd">        edge_loop_print=False,</span>
<span class="sd">        edge_loop_plotting_slice = False,</span>
<span class="sd">        edge_loop_plotting = False,</span>


<span class="sd">        edge_length_to_process = 0.001,</span>
<span class="sd">        submesh_face_min = 200,</span>

<span class="sd">        edge_loop_plot_winning_faces= False,</span>
<span class="sd">        return_subtracted_mesh = True,</span>

<span class="sd">        plot_final_mesh = True,</span>
<span class="sd">        final_split_n_faces_min = 500,</span>
<span class="sd">        )</span>

<span class="sd">    </span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">main_mesh_bbox_restricted</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">bbox_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">main_mesh_bbox_restricted</span><span class="p">,</span> <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bbox_mesh_restriction</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                                            <span class="n">nu</span><span class="o">.</span><span class="n">bouning_box_corners</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span>
                                                                                   <span class="n">bbox_ratio</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inside mesh subtraction, len(main_mesh_bbox_restricted.faces) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_mesh_bbox_restricted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">main_mesh_bbox_restricted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">main_mesh_bbox_restricted</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">initial_plotting</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before Resize&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">,</span>
                         <span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">edges</span><span class="p">)</span>  

    <span class="k">if</span> <span class="n">resize_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">edges</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_with_branching</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="n">resize_length</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Was able to resize skeleton to length: </span><span class="si">{</span><span class="n">resize_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_plotting</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After Resize&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">,</span>
                         <span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">edges</span><span class="p">)</span>  


    <span class="c1"># Iterate through edges of the skeleton: </span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#face_subtract_color = []</span>
    <span class="n">face_subtract_indices</span> <span class="o">=</span> <span class="p">[]</span>



    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ex_edge</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on Edge </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">---&quot;</span><span class="p">)</span>
        <span class="c1">#print(&quot;\n------ New loop ------&quot;)</span>
        <span class="c1">#print(ex_edge)</span>
        <span class="k">if</span> <span class="n">edge_idx_to_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_idx_to_process</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="c1"># ----------- creating edge and checking distance ----- #</span>
        <span class="n">loop_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edge_line</span> <span class="o">=</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ex_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#a) Skip the very small edges</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">edge_line</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">edge_length_to_process</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge number </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ex_edge</span><span class="si">}</span><span class="s2">: has sum less than </span><span class="si">{</span><span class="n">sum_threshold</span><span class="si">}</span><span class="s2"> so skipping&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1">#b) Create change of basis matrix that will align z axis with vector</span>
        <span class="n">cob_edge</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">change_basis_matrix</span><span class="p">(</span><span class="n">edge_line</span><span class="p">)</span>

        <span class="c1">#c) Find range of the edge slice</span>
        <span class="n">edge_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">cob_edge</span><span class="o">@</span><span class="p">(</span><span class="n">ex_edge</span><span class="o">-</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1">#this will be [0,magnitude of vector]</span>
        <span class="n">slice_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span> 
        <span class="n">slice_range_buffer</span> <span class="o">=</span> <span class="n">slice_range</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">buffer</span><span class="p">,</span><span class="n">buffer</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;slice_range_buffer=</span><span class="si">{</span><span class="n">slice_range_buffer</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#d) transform the face midpoints of mesh</span>
        <span class="n">face_midpoints</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">triangles_center</span> <span class="o">-</span> <span class="n">base</span>
        <span class="n">fac_midpoints_trans</span> <span class="o">=</span> <span class="n">cob_edge</span><span class="nd">@face_midpoints</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#e) find the mask for indices within the buffer along the z axis</span>
        <span class="n">slice_mask_z_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&gt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                          <span class="p">(</span><span class="n">fac_midpoints_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">&lt;</span><span class="n">slice_range_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(slice_mask_z_idx) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">slice_mask_z_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_loop_plotting_slice</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;slice_mask_z_idx&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">,</span>
                             <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">slice_mask_z_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)],</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">ex_edge</span><span class="p">]</span>
                             <span class="p">)</span>


        <span class="c1">#f) find the mask for the indices within the buffer on the x,y plane</span>
        <span class="n">slice_mask_xy_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fac_midpoints_trans</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(slice_mask_xy_idx) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">slice_mask_xy_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_loop_plotting_slice</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;slice_mask_xy_idx&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">,</span>
                             <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">slice_mask_xy_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)],</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">ex_edge</span><span class="p">]</span>
                             <span class="p">)</span>

        <span class="c1">#g) Combine the x/y and z distance masks</span>
        <span class="n">slice_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">slice_mask_xy_idx</span><span class="p">,</span><span class="n">slice_mask_z_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(slice_idx) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">slice_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_loop_plotting_slice</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;slice_idx&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh_bbox_restricted</span><span class="p">,</span>
                             <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">slice_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)],</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">ex_edge</span><span class="p">]</span>
                             <span class="p">)</span>

        <span class="c1">#h) Continue to next edge if no faces in the search</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slice_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;slice_idx empty so continuing&quot;</span><span class="p">)</span>
            <span class="k">continue</span>


        <span class="c1">#i) Get the submesh and split into connected components (and filter for significant ones)</span>
        <span class="n">face_list</span> <span class="o">=</span> <span class="n">slice_idx</span>
        <span class="n">main_mesh_sub</span> <span class="o">=</span> <span class="n">main_mesh_bbox_restricted</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">face_list</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sub_components</span><span class="p">,</span><span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">main_mesh_sub</span><span class="p">,</span>
                                                              <span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                             <span class="n">return_mesh_list</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sub_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span>
        <span class="n">sub_components_face_indexes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sub_components_face_indexes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span><span class="si">}</span><span class="s2">)= </span><span class="si">{</span><span class="n">sub_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">submesh_face_min</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">filt_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_size</span><span class="p">(</span><span class="n">sub_components</span><span class="p">,</span>
                                             <span class="n">size_threshold</span><span class="o">=</span><span class="n">submesh_face_min</span><span class="p">,</span>
                                             <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sub_components</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">filt_idx</span><span class="p">]</span>
                <span class="n">sub_components_face_indexes</span> <span class="o">=</span> <span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">filt_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components AFTER FILTERING (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span><span class="si">}</span><span class="s2">)= </span><span class="si">{</span><span class="n">sub_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">edge_loop_plotting</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_components&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">sub_components</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                             <span class="n">main_skeleton</span><span class="o">=</span><span class="n">ex_edge</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="c1">#j) Filter the sub components to only one based on 1) bbox containing vertices and then </span>
        <span class="c1">#   closest bounding box center to skeleton center to find winning component idx</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">winning_subcomponent_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Psuedocode: </span>
<span class="sd">            1) Test to see which meshes have a bounding box that contains the skeleton</span>
<span class="sd">            2a) only one then make that the winner</span>
<span class="sd">            2b) Find the mesh with the closest mesh center</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">containing_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sub_components</span><span class="p">)</span>
                                  <span class="k">if</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_bbox_contains_skeleton</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">ex_edge</span><span class="p">)])</span>

            <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;containing_indices = </span><span class="si">{</span><span class="n">containing_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only one mesh with bbox containing skeleton&quot;</span><span class="p">)</span>
                <span class="n">winning_subcomponent_idx</span> <span class="o">=</span> <span class="n">containing_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resorting to finding mesh with the closest bounding box center&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">containing_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_components</span><span class="p">))</span>

                <span class="n">edge_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ex_edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">closest_containing_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_to_coordinate</span><span class="p">(</span><span class="n">mesh_list</span><span class="o">=</span><span class="n">sub_components</span><span class="p">[</span><span class="n">containing_indices</span><span class="p">],</span>
                                              <span class="n">coordinate</span><span class="o">=</span><span class="n">edge_center</span><span class="p">,</span>
                                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                              <span class="n">distance_method</span><span class="o">=</span><span class="s2">&quot;mesh_center&quot;</span><span class="p">,</span>
                                              <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="p">)</span>

                <span class="n">winning_subcomponent_idx</span> <span class="o">=</span> <span class="n">containing_indices</span><span class="p">[</span><span class="n">closest_containing_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_subcomponent_idx = </span><span class="si">{</span><span class="n">winning_subcomponent_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#k) Find the faces that belong to the winning mesh    </span>
        <span class="n">edge_skeleton_faces</span> <span class="o">=</span> <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">face_list</span><span class="p">[</span><span class="n">sub_components_face_indexes</span><span class="p">[</span><span class="n">winning_subcomponent_idx</span><span class="p">]]]</span>
        <span class="n">submesh_by_faces_idx</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">edge_skeleton_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">submesh_by_trimesh</span> <span class="o">=</span> <span class="n">sub_components</span><span class="p">[</span><span class="n">winning_subcomponent_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;submesh_by_faces_idx= </span><span class="si">{</span><span class="n">submesh_by_faces_idx</span><span class="si">}</span><span class="s2">,submesh_by_trimesh = </span><span class="si">{</span><span class="n">submesh_by_trimesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edge_loop_plot_winning_faces</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning mesh without faces&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">submesh_by_trimesh</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning mesh WITH faces&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">submesh_by_faces_idx</span><span class="p">)</span>



        <span class="c1">#l) Append the faces to running list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">edge_loop_print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;****** Warning the edge index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: had no faces in the edge_skeleton_faces*******&quot;</span><span class="p">)</span>

        <span class="n">face_subtract_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_skeleton_faces</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Mesh subtraction time = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#m) Find the final submesh and split</span>



    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">all_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">face_subtract_indices</span><span class="p">)</span>
        <span class="n">unique_removed_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_removed_faces</span><span class="p">)</span>

        <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">unique_removed_faces</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_subtracted_mesh</span><span class="p">:</span>
            <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">unique_removed_faces</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">unique_removed_faces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_subtracted_mesh</span><span class="p">:</span>
            <span class="n">faces_to_keep</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

    <span class="n">new_submesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">faces_to_keep</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_mesh</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_final_mesh&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">final_split_n_faces_min</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_subtracted_mesh</span><span class="p">:</span>
        <span class="n">significant_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">new_submesh</span><span class="p">,</span>
                                                             <span class="n">final_split_n_faces_min</span><span class="p">,</span>
                                                             <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_final_mesh</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;significant_pieces&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">significant_pieces</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">)</span>

        <span class="n">return_value</span> <span class="o">=</span> <span class="n">significant_pieces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">new_submesh</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="jitter_skeleton_from_coordinate"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.jitter_skeleton_from_coordinate">[docs]</a><span class="k">def</span> <span class="nf">jitter_skeleton_from_coordinate</span><span class="p">(</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">jitter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_noise</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: generate a skeleton segment to</span>
<span class="sd">    slightly shift and endpoint and return the skeleton</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Compute the new jittered endpoint</span>
<span class="sd">    2) Create the new skeleton segment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">jitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">jitter</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">jitter</span><span class="p">,</span><span class="n">jitter</span><span class="p">,</span><span class="n">jitter</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">random_noise</span><span class="p">:</span>
            <span class="n">jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">jitter</span>

    <span class="n">jitter</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;jitter = </span><span class="si">{</span><span class="n">jitter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span><span class="p">,</span><span class="n">jitter</span> <span class="o">+</span> <span class="n">coordinate</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_skeleton: </span><span class="si">{</span><span class="n">new_skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_skeleton</span></div>


<div class="viewcode-block" id="vector_away_from_endpoint"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.vector_away_from_endpoint">[docs]</a><span class="k">def</span> <span class="nf">vector_away_from_endpoint</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">,</span>    
    <span class="n">offset</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">3_000</span><span class="p">,</span><span class="c1">#2_000,</span>
    <span class="n">skeleton_resolution</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">min_comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">plot_restricted_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize_vector</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="c1">#plot_restricted_skeleton = True</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the upstream or downstream vector</span>
<span class="sd">    from the offest start of a skeleton</span>

<span class="sd">    Result: The vector naturally points away from the start coordinate</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.vector_away_from_endpoint(</span>
<span class="sd">        skeleton = branch_obj.skeleton,</span>
<span class="sd">        endpoint = np.array([2504610. ,  480431. ,   33741.2]),</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        plot_restricted_skeleton = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">restr_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                                       <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                    <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                        <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                     <span class="n">start_coordinate</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span>
                                                    <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="n">skeleton_resolution</span><span class="p">,</span>
                                                    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_restricted_skeleton</span>
                                                       <span class="p">)</span>

    <span class="n">sk_vec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_endpoint_vector</span><span class="p">(</span>
        <span class="n">restr_skeleton</span><span class="p">,</span>
        <span class="n">normalize_vector</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_vec = </span><span class="si">{</span><span class="n">sk_vec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sk_vec</span></div>


<div class="viewcode-block" id="coordinates_from_downstream_dist"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.coordinates_from_downstream_dist">[docs]</a><span class="k">def</span> <span class="nf">coordinates_from_downstream_dist</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">donwstream_dists</span><span class="p">,</span>
    <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">segment_width</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Get skeleton coordinates as dictated by the skeletal lengths downstream</span>
<span class="sd">    - would be nice to chop up a skeleton by lengths from upstream</span>

<span class="sd">    Psueodocode: </span>
<span class="sd">    1) Order skeleton</span>
<span class="sd">    2) Compute the skeletal distances of each coordinate</span>
<span class="sd">    3) Get the coordinates that are closest in downstream dist to those sent</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="n">curr_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_resize_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="n">start_endpoint_coordinate</span><span class="p">,</span>
        <span class="n">segment_width</span><span class="o">=</span><span class="n">segment_width</span><span class="p">)</span>
    
    <span class="n">skeletal_distances</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_coordinate_distances_cumsum</span><span class="p">(</span>
        <span class="n">curr_skeleton</span><span class="p">)</span>
    
    <span class="n">sk_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">skeletal_distances</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_idx</span> <span class="o">=</span> <span class="n">sk_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">donwstream_dists</span><span class="p">)</span>
    
    <span class="n">sk_coords</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_coordinate_path_from_start</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">)</span>
    
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">sk_coords</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinates = </span><span class="si">{</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">],</span>
            <span class="n">scatters_colors</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">color_transition</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))),</span>
            <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.5</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">coordinates</span></div>



<div class="viewcode-block" id="coordinate_restriction_to_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.coordinate_restriction_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">coordinate_restriction_to_skeleton</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">15_000</span><span class="p">,</span>
    <span class="n">keep_skeleton_within_threshold</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  
    <span class="n">return_graph</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Purpose: To keep or eliminate all skeletal </span>
<span class="sd">    points within a certain distance of a coordinate: </span>

<span class="sd">    1) convert skeleton to graph</span>
<span class="sd">    2) find all node coordinates and names</span>
<span class="sd">    3) Find the closest distance from coordinates to cancel points</span>
<span class="sd">    4) Either take the subgraph of nodes with range or outside of range</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.coordinate_restriction_to_skeleton(</span>
<span class="sd">        skeleton = skeleton_proof_stitch,</span>
<span class="sd">        coordinates = hdju.nucleus_center_from_segment_id(segment_id_raw),</span>
<span class="sd">        distance_threshold = 40_000,</span>
<span class="sd">        keep_skeleton_within_threshold = False,</span>
<span class="sd">        plot = True,</span>
<span class="sd">        verbose = True,  </span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton</span>
    
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#1) Turn skeleton into nodes</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>

    <span class="c1">#2) Find skeleton coordinates</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">node_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">])</span>

    <span class="n">kd_obj</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">kd_obj</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_skeleton_within_threshold</span><span class="p">:</span>
        <span class="n">node_mask</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;=</span>  <span class="n">distance_threshold</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node_mask</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">distance_threshold</span>

    
    <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">node_names</span><span class="p">[</span><span class="n">node_mask</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of nodes in original = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of nodes after restriction = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G_sub</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    
    <span class="n">skeleton_new</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">G_sub</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">original_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">final_color</span>  <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original_color = </span><span class="si">{</span><span class="n">original_color</span><span class="si">}</span><span class="s2">, fianl_color = </span><span class="si">{</span><span class="n">final_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">skeleton</span><span class="p">,</span><span class="n">skeleton_new</span><span class="p">],</span>
            <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="n">original_color</span><span class="p">,</span><span class="n">final_color</span><span class="p">]</span>

        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_graph</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G_sub</span>
    
    <span class="k">return</span> <span class="n">skeleton_new</span></div>

<div class="viewcode-block" id="node_names_and_coord_from_G"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.node_names_and_coord_from_G">[docs]</a><span class="k">def</span> <span class="nf">node_names_and_coord_from_G</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">skeleton</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">G</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    
    <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">node_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">node_names</span><span class="p">,</span><span class="n">node_coords</span></div>

<div class="viewcode-block" id="subtract_exact_coordinates_from_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.subtract_exact_coordinates_from_skeleton">[docs]</a><span class="k">def</span> <span class="nf">subtract_exact_coordinates_from_skeleton</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">return_graph</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">coordinate_restriction_to_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="p">,</span>
        <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_graph</span> <span class="o">=</span> <span class="n">return_graph</span>
        
    <span class="p">)</span></div>

<div class="viewcode-block" id="empty_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.empty_skeleton">[docs]</a><span class="k">def</span> <span class="nf">empty_skeleton</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span></div>

<div class="viewcode-block" id="subskeleton_from_vertices_idx"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.subskeleton_from_vertices_idx">[docs]</a><span class="k">def</span> <span class="nf">subskeleton_from_vertices_idx</span><span class="p">(</span>
    <span class="n">vertices_idx</span><span class="p">,</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get a skeleton from a list of indices</span>
<span class="sd">    referencing a subset of the original vertices</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk.subskeleton_from_vertices_idx(</span>
<span class="sd">        vertices_idx = np.arange(0,1000),</span>
<span class="sd">        skeleton = truth_skeleton,</span>
<span class="sd">        plot=True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertices</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes_edges</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">empty_skeleton</span><span class="p">()</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertices_idx</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">G_sub_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G_sub</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G_sub_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">G_sub_edges</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">empty_skeleton</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">original_sk</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>
        
        <span class="n">original_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
        <span class="n">sub_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original skeleton (</span><span class="si">{</span><span class="n">original_color</span><span class="si">}</span><span class="s2">), subskeleton color (</span><span class="si">{</span><span class="n">sub_color</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_sk</span><span class="p">,</span><span class="n">new_skeleton</span><span class="p">],</span>
            <span class="n">skeletons_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_color</span><span class="p">,</span><span class="n">sub_color</span><span class="p">]</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">new_skeleton</span></div>

<div class="viewcode-block" id="mesh_restriction_to_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.mesh_restriction_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">mesh_restriction_to_skeleton</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">6_000</span><span class="p">,</span>
    <span class="n">keep_skeleton_within_threshold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="n">new_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">coordinate_restriction_to_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
        <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">distance_threshold</span><span class="p">,</span>
        <span class="n">keep_skeleton_within_threshold</span> <span class="o">=</span> <span class="n">keep_skeleton_within_threshold</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_graph</span> <span class="o">=</span> <span class="n">return_graph</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_graph</span><span class="p">:</span>
            <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">new_sk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">new_sk</span>
            
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">new_sk</span><span class="p">,</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">new_sk</span></div>

<div class="viewcode-block" id="accuracy_stats_from_true_predicted_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.accuracy_stats_from_true_predicted_skeleton">[docs]</a><span class="k">def</span> <span class="nf">accuracy_stats_from_true_predicted_skeleton</span><span class="p">(</span>
    <span class="n">true_skeleton</span><span class="p">,</span>
    <span class="n">predicted_skeleton</span><span class="p">,</span>
    <span class="c1">#exclude_skeleton = None,</span>
    <span class="n">search_radius</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">include_skeletons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_subskeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_skeleton_categories</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute all TP/FP... skeletons and skeletal lengths</span>
<span class="sd">    and all other stats: precision, recall between 2 skeletons</span>

<span class="sd">    What to do with an exclude skeleton? It should not be included in the false negative</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">manual_skeleton</span> <span class="o">=</span> <span class="n">true_skeleton</span>
    <span class="n">auto_skeleton</span> <span class="o">=</span> <span class="n">predicted_skeleton</span>
    
    <span class="n">result_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># --- Do the TP and FP</span>
    <span class="n">manual_vertices</span><span class="p">,</span><span class="n">manual_edges</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes_edges</span><span class="p">(</span><span class="n">manual_skeleton</span><span class="p">)</span>
    <span class="n">auto_vertices</span><span class="p">,</span><span class="n">auto_edges</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes_edges</span><span class="p">(</span><span class="n">auto_skeleton</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">auto_vertices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">manual_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">manual_vertices</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">manual_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">auto_vertices</span><span class="p">)</span>
        <span class="n">tp_mask</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">search_radius</span>
        <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">auto_vertices</span><span class="p">))</span>
        <span class="n">valid_idx</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="n">tp_mask</span><span class="p">]</span>
        <span class="n">invalid_idx</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="o">~</span><span class="n">tp_mask</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">invalid_idx</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="n">tp_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">subskeleton_from_vertices_idx</span><span class="p">(</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">auto_vertices</span><span class="p">,</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">auto_edges</span><span class="p">,</span>
            <span class="n">vertices_idx</span> <span class="o">=</span> <span class="n">valid_idx</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot_subskeleton</span>
        <span class="p">)</span>
    <span class="n">result_dict</span><span class="p">[</span><span class="s2">&quot;TP_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tp_skeleton</span>

    <span class="n">fp_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">subskeleton_from_vertices_idx</span><span class="p">(</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">auto_vertices</span><span class="p">,</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">auto_edges</span><span class="p">,</span>
            <span class="n">vertices_idx</span> <span class="o">=</span> <span class="n">invalid_idx</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot_subskeleton</span>
        <span class="p">)</span>
    <span class="n">result_dict</span><span class="p">[</span><span class="s2">&quot;FP_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fp_skeleton</span>

    <span class="c1"># ----- Doing the FN skeletons ------------</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">auto_vertices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">auto_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">auto_vertices</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">auto_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">manual_vertices</span><span class="p">)</span>
        <span class="n">tp_mask</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">search_radius</span>
        <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">manual_vertices</span><span class="p">))</span>
        <span class="n">valid_idx</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="n">tp_mask</span><span class="p">]</span>
        <span class="n">invalid_idx</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="o">~</span><span class="n">tp_mask</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">manual_vertices</span><span class="p">))</span>
        <span class="n">invalid_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">fn_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">subskeleton_from_vertices_idx</span><span class="p">(</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">manual_vertices</span><span class="p">,</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">manual_edges</span><span class="p">,</span>
            <span class="n">vertices_idx</span> <span class="o">=</span> <span class="n">invalid_idx</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot_subskeleton</span>
        <span class="p">)</span>
    <span class="n">result_dict</span><span class="p">[</span><span class="s2">&quot;FN_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn_skeleton</span>


    <span class="c1"># plotting the different categories</span>
    <span class="k">if</span> <span class="n">plot_skeleton_categories</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">curr_sk</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---Plotting </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">curr_sk</span><span class="p">)</span>


    <span class="c1"># calculates the skeletal length</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">result_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">result_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="n">result_dict</span><span class="p">[</span><span class="s2">&quot;total_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">predicted_skeleton</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;results: </span><span class="si">{</span><span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">result_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;length&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">k</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#compute the precision, recall and f1</span>
    <span class="n">pre_recall_score</span> <span class="o">=</span> <span class="n">stu</span><span class="o">.</span><span class="n">calculate_scores</span><span class="p">(</span>
            <span class="n">TP</span> <span class="o">=</span> <span class="n">result_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;TP_skeleton_length&quot;</span><span class="p">],</span>
            <span class="n">FP</span> <span class="o">=</span> <span class="n">result_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;FP_skeleton_length&quot;</span><span class="p">],</span>
            <span class="n">FN</span> <span class="o">=</span> <span class="n">result_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;FN_skeleton_length&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pre_recall_score = </span><span class="si">{</span><span class="n">pre_recall_score</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">result_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">pre_recall_score</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_skeletons</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">result_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">result_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> 

    <span class="k">return</span> <span class="n">result_dict</span></div>

<div class="viewcode-block" id="center_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.center_skeleton">[docs]</a><span class="k">def</span> <span class="nf">center_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">skeleton</span> <span class="o">-</span> <span class="n">center</span></div>
    

<div class="viewcode-block" id="resize_center_and_coordinates_from_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.resize_center_and_coordinates_from_skeleton">[docs]</a><span class="k">def</span> <span class="nf">resize_center_and_coordinates_from_skeleton</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">resize_skeleton</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">segment_width</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span>
    <span class="n">plot_resized_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">center_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">return_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To resize, center export as </span>
<span class="sd">    coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#2) Resize the skeleton</span>
    <span class="k">if</span> <span class="n">resize_skeleton</span><span class="p">:</span>
        <span class="n">skeleton_scaled</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_with_branching</span><span class="p">(</span>
            <span class="n">skeleton</span><span class="p">,</span>
            <span class="n">segment_width</span> <span class="o">=</span><span class="n">segment_width</span><span class="p">,</span>
            <span class="n">optimal_speed</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_resized_skeleton</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton_scaled</span> <span class="o">=</span> <span class="n">skeleton</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    4) If requested to center coordinates</span>
<span class="sd">    a. Pull down the soma center if None given</span>
<span class="sd">    b. Subtract soma center from coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">center_coordinates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">skeleton_scaled</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="n">skeleton_scaled</span> <span class="o">=</span> <span class="n">skeleton_scaled</span> <span class="o">-</span> <span class="n">center</span>
        
    <span class="k">if</span> <span class="n">return_coordinates</span><span class="p">:</span>
        <span class="c1">#3) Convert into coordinates</span>
        <span class="n">skeleton_scatter</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_coordinates</span><span class="p">(</span><span class="n">skeleton_scaled</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton_scatter</span> <span class="o">=</span> <span class="n">skeleton_scaled</span>
        
    <span class="k">return</span> <span class="n">skeleton_scatter</span></div>

<div class="viewcode-block" id="resize_and_center_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.resize_and_center_skeleton">[docs]</a><span class="k">def</span> <span class="nf">resize_and_center_skeleton</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">resize_skeleton</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">segment_width</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span>
    <span class="n">plot_resized_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">center_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">resize_center_and_coordinates_from_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="p">,</span>
        <span class="n">resize_skeleton</span> <span class="o">=</span> <span class="n">resize_skeleton</span><span class="p">,</span>
        <span class="n">segment_width</span> <span class="o">=</span> <span class="n">segment_width</span><span class="p">,</span>
        <span class="n">plot_resized_skeleton</span> <span class="o">=</span> <span class="n">plot_resized_skeleton</span><span class="p">,</span>

        <span class="n">center_coordinates</span> <span class="o">=</span> <span class="n">center_coordinates</span><span class="p">,</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>

        <span class="n">return_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="intersect_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.intersect_skeleton">[docs]</a><span class="k">def</span> <span class="nf">intersect_skeleton</span><span class="p">(</span>
    <span class="n">skeleton_1</span><span class="p">,</span>
    <span class="n">skeleton_2</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">empty_skeleton</span><span class="p">()</span>
    
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_coordinates</span><span class="p">(</span><span class="n">skeleton_2</span><span class="p">)</span>
    
    <span class="n">sk</span><span class="o">.</span><span class="n">coordinate_restriction_to_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton_1</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
        <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_threshold</span><span class="p">,</span>
        <span class="n">keep_skeleton_within_threshold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="setdiff_skeleton"><a class="viewcode-back" href="../../mesh_tools.html#mesh_tools.skeleton_utils.setdiff_skeleton">[docs]</a><span class="k">def</span> <span class="nf">setdiff_skeleton</span><span class="p">(</span>
    <span class="n">skeleton_1</span><span class="p">,</span>
    <span class="n">skeleton_2</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">empty_skeleton</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_coordinates</span><span class="p">(</span><span class="n">skeleton_2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">coordinate_restriction_to_skeleton</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton_1</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
        <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_threshold</span><span class="p">,</span>
        <span class="n">keep_skeleton_within_threshold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>


<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">meshparty_skeletonize</span> <span class="k">as</span> <span class="n">m_sk</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>
<span class="kn">from</span> <span class="nn">.trimesh_utils</span> <span class="kn">import</span> <span class="n">split_significant_pieces</span><span class="p">,</span><span class="n">split</span><span class="p">,</span><span class="n">combine_meshes</span><span class="p">,</span><span class="n">write_neuron_off</span>


<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">mesh_utils</span> <span class="k">as</span> <span class="n">meshu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">statistics_utils</span> <span class="k">as</span> <span class="n">stu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="n">unique_vertices_edges_from_vertices_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">unique_vertices_edges_from_vertices_edges</span>
<span class="n">graph_from_unique_vertices_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">graph_from_unique_vertices_edges</span>
<span class="n">graph_from_non_unique_vertices_edges</span><span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">graph_from_non_unique_vertices_edges</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>